{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"Child","functions":[{"name":"value_internal","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"5ZXtasMgFIbv5fwOw/OhxtzKGMO26QgEU5p0MELufaZzso/CBtlKS3/J0cfX96iHM8KmXh2eHpuw7Xqo7kdou7Ufmi7EaASU41y/82EO+8HvB6hUAXXYxHEqYNu0NVTMdiq+cWTQJZSMYKaR8ATNVijRXCr3A+3ESaKd1pxpEjU9FID6Wo2b8xkXtJhoIcaFxu0S41ySyneoTaadHLXLf9R2v9eOOKklVoyYMqFGK/5ihXCRtmbK2vqT9kX9cKKbyJIvNMs/LXpSd3jyOdHYtA2d/nBGrKEYPft941dtPfeYefEQ1u8tJ4bDy+5tJbKv"},{"name":"private_set_value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"new_value","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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m5X5aB769ifpE2M22/loGccFyPq8/w5i/VtxjlefpAIjGYxUYaQGI3UYacBIE0ZyGGmhSA1WIxqsRjRYjWiwGtFgNaLBakSD1YgGqxENViMarEZ0WI3osBrRYTWiw2pEh9WIDqsRHVYjOqxGdFiN6LAaMWA1YsBqxIDViAGrEQNWIwasRgxYjRiwGjFgNWLAasSE1YgJqxETViMmrEZMWI2YsBoxYTViwmrEhNWICasRDqsRDqsRDqsRDqsRDqsRDqsRDqsRDqsRDqsRDqsRC1YjFqxGLFiNWLAasWA1YsFqxILViAWrEQtWIxasRjya9UlBFRzKcKiKQzUcquNQA4eaOJTjULhqUXDVouCqRcFVi4KrFgVXLQquWhRctSi4alFw1aLgqoXhqoXhqoXhqoXhqoXhqoXhqoXhqoXhqoXhqoXhqgVuDLPg5jALbhCz4CYxC24Us+BmMQtuGLPgpjELbhyz4OYxC24gs+AmMgtuJLPgZjILbiiz4KYyC24ss+DmMgtuMLPgJjMLbjSz4GYzC244s+CmMwtuPLPg5jMLbkCz4CY0C25Es+BmNAtuSLPgpjQLbkyz4OY0C25Qs+AmNQtuVLPgZjULbliz4KY1C25cs+DmNQtuYLPgJjYLbmSz4GY2C25os+CmNgtubLPg5jYLbnCz4CY3C250s+BmNwtueLPgpjcLbnyz4OY3C26As+AmOAtuhLPgZjgLboiz4KY4C26Ms+DmOAtukLPgJjkLbpSz4GY5DTfLabhZTsPNchpultOOhkN1HGrgUBOHchwKVy1ws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+U03Cyn4WY5DTfLabhZTsPNchpultNws5yGm+WsuFnOipvlrLhZzoqb5axHw6FwyYS4Wc6Km+WsuFnOipvlrAUYYYqrFrhZzoqb5ay4Wc6Km+WsuFnOipvlrLhZzoqb5ay4Wc5qwMRjXLV4NMt5KyMnqvbjCapOv5tVN3/y6tXWPSJ79V7PV1v7LtZYxTqr2GAVm6xiziq2SMUeTcP+vFhhFTNWMdbKX1krf2Wt/JW18lfWyl9ZK//DWeVVvsRGf4Ia1f5+9fBvr6128dpWx9+vbX3+47Wn1MOp5jSp25fzLjXKA6nCKGWMUpVRqjFKdUap8RGpMk+p8UTKR79XKh/Dvl7d1zetyanlnFqLUqsfnFqFU8vgWvO4/69v/7keaFVOrcap1Tm1BqfW5NRyTi18lZ99nVpjXmuNg1OrcGoZp1bl1GqcWp1T6weqfJ1fWv4PrYu/GbXzT0zWvn3+cfsw5NubmP8Lb8L/F97Eo78T+DrfRLPx5E3cXn1+jLXqRz7GerR98vNihVXMWMUqq1hjFeusYoNVbLKKOasYa+V31srvrJXfWSu/s1Z+Z638j/albj8yf4m18uyHys/+/eDRZtXPSk1GKWeUWoRSjzbA/qXUv/jtaVm9H+5l7fuv199+H3q0LfbTWsapVTm1GqdW59QaeC07vrT8H1oX4yW2zmpSy9er4/38nxfPfu/Ic7VvH3l8e7vzv/V2/b/1dtd/6e224/hvvd1C/nbr+QFtq61/f7tf78H+B95D/R94D439Pcx2vgc/rt9Dp38P9es9rOv3wP7jx5+8B/zPFLePMO7v4dYFLn+ya4dzai1KrXL8gFY9tUp9oFU4tewHtOzUMnugVTm1GqcWvn+0dv5G2uZ6oDU4teYPaPmp5fOBFr7K93J+tXp79NVaP6B1frX6988dv2vZwalVfkBrnlrzQU80fJXv599U1jB/oFU5tdoPaJ3/iKOOB1r4Kj/m+RP2fPTzlg1OLXyVH2N9aV18b9n46/qLNc/KMue3n9Nu35/nc/PF5/zF59Zrz12vhf/Bc+XF5+zF5y4rj5dz9cMePNdefK6/+Nx48bn54nP+4nPrteeuF0r9/MXFl10/V158zl58rr74XHvxuf7ic+PF5y6/X9a56bDKcf2cv/jceu256zW1P3iuvPicvfhcffG5y++X28db9+fq9Tm63mX6g+fGi8/NF5/zF59brz13vfDyB8+VJ8+163+/65WRP3iuvvjc9fdLr18/5F4/1198brz43HzxOX/xufXac9fj6n/w3PX3i99/Ti1H9388+P/9mxefFINQKoTSIJQOoQwIZUIoDqEsBOV6BPnjFMjZd8jZd8jZd8jZd8jZd8jZd8jZd8jZd8jZX5CzvyBnf0HO/oKc/QU5++v989LPLd4+vz4mtPn1Yd5yAKQc73+L9fNviN+vf/0nxSCUCqE0CKVDKP+2vXw9OV990iri+9oahNIhlAGhTAjlA1Vt9ftfTY7+gLIQlHpAKAVCMQjlA2f/vDhhHOMBpUEoHUIZEMqEUBxCWYjO2Q4IBfLTWYP8dNYgP501yE9nDfLTWRsQyoRQHEKBnP0OOfsdcvY75Ox3yNnvkLPfIWe/Q85+h5z9Djn7HXL2B+TsD8jZH5CzPyBnf0DO/oCc/QE5+wNy9gfk7A/I2Z+Qsz8hZ39Czv6EnP0JOfsTcvYn5OzP9LNf7a/rEenezgnp/u36Uru8yrLfGe7l9y8txe/5IhFg9/Xievo4mc8i83mw2viDQoVNyNiEKptQYxPqbEKDTYitThe2Ql3YKrWxVWpjq9TGVqmNrVIbW6U2tkptiZX6ZEwA4/16+m21pB7vf2EXmVA92IQKm5CxCVU2ocYm1NmEBpvQZBNiq9SVrVI3tkrd2Cp1Y6vUja1SN7ZK3dgqdWOr1C2xUp8MBzBWPqMfAEYBMAzAqABGAzA6gDEADMA5H+9/75bjuK9sl6PYJcUglPf/3Yu1r+o7Lj9AGAvxXuYBoUD+9Wf7AOW876kc326H+k7pEMqAUCaE4hDKJ87LKF+UeUXxA0IpEIpBKBVCaRBKh1AGhDIhFIdQPnD2y3mx2e2/Ln+GWQeEUiAUg1AqhNIglA6hDAhlQigfOPtl2kn5PvH2jbIQlHIcGExF/G7xYJ3+85iOwQwMZkEwH5gI/CNMwWAMgwGcm3Y9XDvPx+Z88qFrO+6X2Dbrv3+pn7ViHf9IXHrho9x2PYWrIL5Uxa9PsYR5kTU3WfMqa95kzbus+ZA1l+2gRbaFFtkearI91GR7qMn2UJPtoSbbQ022h1paDz0JM53wdk86L0FvvV0SVjahHumEkk6wdMLbte1cHG5eLwktndDTCSOd8O6Z7sf9A6l++CXB0wkrm9COdEJJJ7z73drt/tJu14SRTnj3X3rU+9TF6HZF6Ec6If2r1N8+0+eHzL3PS4KnE1Y2YRzphJJOsHRCTSe0dEJPJ4x0wgfP9BiXBE8nvH+mz8o3Lwnz7TNd1xNCSSdYOuHdMz3OydVxrEtCSyf0dMJIJ8x0wttn+usy7nJcElY2wY90QkknWDqhphNaOqGnE0Y6YX6QcHmm3dMJ75/p+yTdsEvCevtMnx+HPiKUdIKlE97u089+F10tndDTCSOdMNMJnk5I/+TkwUDpxxDtwbRaGfWc2x39yZ9cSjvuxa+0Uq4gD6YV/x2l+UmZz/4K9LnbhtqjWScZe5O2r9L2Tdq+S9sPafspbe/S9kvZ3qR7rUn3WpPutSbda02615p0rzXpXmvSvdake62x9Nq7UGVpn6cQuCN+8Hqw9mjqTca+Sts3afsubT+k7ae0vUvbL2X7dkjbS/faJt1rm3SvbdK9tkn32ibda5t0r23SvbZJ99rO0mtPIZb2eQqxdMRTiKXJnUIsfesUYmlFpxBLdzmFWBrGKcTSA04hlrJ+FxpslXqAj/2zi5nbo42Sn1UCf2M/u1ysPdqV+NGv0jQ+pcqnNNBKv78Muz3alfhZJedTWnRKfvApwevS7+97bo8WRH5WqfIpNT6lzqc0+JQmn5LzKS06pXXwKaGr95N7wdujVaCfVap8So1PqfMpDT6lyafkfEqLTunRHf+JTr8PBNhOhdDJCJ063Qc6j3IJftZpEjrxfRhX0JuBf+RkhE6V0KkROpHVp15E0yxu4ppXcd/ENW/ivomLplmEueZN3GGueRN3mGvexB3mTdZc8ybuMNdMswhz2Q4qmmYR5rI9VDTNIsxle6homkWYy/ZQ0TSLMJftoclpFkGY6YTcNIsgrGxCcppFEEo6wdIJuWkWQWjphJ5OGOmE3DSLIHg6YWUTktMsglDSCblpFkEY6YTcOxlvhOQ0iyCkf5WS0yyC4OmElU1ITrMIQkknWDqhphNaOqGnE0Y6ITfNIgieTshNs4g/Z+WmWQShpBMsnZCbZhGElk7o6YSRTpjphNw0iyCsbEJymkUQSjrB0gk1ndDSCT2dMNIJuWkWQfB0Qm6aRQxB5KZZBKGkEyydkJtmEYSWTujphJFOmOkETyekf3KSnWYxDkCaxQ0inGYR9ro3bIe97g3bYa97w3bYN2l73Ru2w173hu2w171hO+x1b9gOe900i5u9cJpF2Ev3WuE0i7CX7rXCaRZhL91rhdMswl661wqnWYQ9VZrFTYgrzSKEdG/YDnvdG7bDXveG7bBv0va6N2yHve4N22Gve8N22OvesB32ujds3+yF0yzCXrrXCqdZhL10rxVOswh76V4rnGYR9tK9VjjNIuyley1XmkUIUaVZhBBVmkUIUaVZhBBL3zqFqNIsQogqzSKEqNIsQogqzSKEqNIsbkJcaRYhBD72z677DyWyNItQIrtAL8a1yNIsQokszSKUyNIsQokszSKUyNIsQokszSKUyNIsbkpsaRahRJZmEUpkaRahRJZmEUqNT4kszSKUyNIsQokszSKUyNIsQokszeKmxJZmEUpkaRahRJZmEUpkaRah1PiUyNIsQokszSKUyNIsQokszSKUyNIs9ioTWZrFdiJLs9hOZGkW24nstvjtRJZmsZ3I0iy2E9+HcXRpFtuJLM1iO5GlWWynRujEVp8mYj94Su8HT+n94Cm9Hzyl94On9H7wlN4PntL7wVN6P3hK7wdP6f3gKb0fPKX3g6f0fvCU3g+e0vvBU3o/eErvB0/p/eApvR882faDJ9t+8JTeD57S+8FTej94Su8HT+n94Cm9Hzyl94On9H7wlN4PntL7wVN6P3hK7wdP6f3gKb0fPKX3g6f0fvCU3g+e0vvBU3o/eLLtB0+2/eDJth882faDJ9t+8GTbD55s+8GTbT94su0HT7b94Mm2Hzz59oMn337w5NsPnnz7wZNvP3jy7QdPvv3gybcfPPn2gyfffvDk2w+efPvBk28/ePLtB0++/eDJtx88+faDJ99+8OTbD558+8GTbz948u0HT7794Mm3Hzz59oMn337w5NsPnnz7wZNvP3jy7QdPwv3gSbgfPAn3gyfhfvAk3A+ehPvBk3A/eBLuB0/C/eBJuB88CfeDJ99+8Ox/vZvj3I67TrMnNn4W8HW0r5fWF/46fhN3VfGlKl4OWfMia26y5lXWvMmad1nzIWsu20GLbAstsj3UZHuoyfZQk+2hJttDTbaHmmwPtbQeehJmOuHtntTvkzqtt0vCyibUI51Q0gmWTni7tvn98DSvl4SWTujphJFOePdM92P+/dJ++CXB0wkrm9COdEJJJ7z73drt/tJu14SRTnj3X3rU+6jb6HZF6Ec6If2r1N8+0+38XurzkuDphJVNGEc6oaQTLJ1Q0wktndDTCSOd8MEzPcYlwdMJ75/ps/LNS8J8+0yf1fsRoaQTLJ3w7pke5z7EONYloaUTejphpBNmOuHtM73ulz+PclwSVjbBj3RCSSdYOqGmE1o6oacTRjphfpBweabd0wnvn+n7RMuwS8J6+0yfH4c+IpR0gqUT3u7Tz34XXS2d0NMJI50w0wmeTkj/5OTB6PTHEN4BaRbeldMsvCunWXhXTrPwrpxm4V05zcK7cpqFd+U0C+/KaRbeldMsvCunWXhXTrPwrpxm4V05zcK7cpqFd+U0C+/KaRbeldMsvCunWXhXTrPwTpZm4Z0szcK7cpqFd+U0C+/KaRbeldMsvCunWXhXTrPwrpxm4V05zcK7cpqFd+U0C+/KaRZhL91rhdMswl661wqnWXhXTrMIe+leK5xm4V05zcI7WZpFCFGlWYQQVZpFCFGlWYQQS986hajSLLyTpVl4J0uz8E6WZuGdLM3CO1mahXe6NAvvdGkW3unSLLzTpVl4p0uz8E6XZuGdLs3CO12ahXe6NAvvdGkW3unSLLzTpVl4p0uz8E6XZuGdLs3CO12ahXe6NAvvdGkW3unSLLzTpVl4p0uz8E6XZuGdLs3CO12ahXe6NAvvdGkW3unSLLzTpVl4p0uz8E6XZuGdL81iO5GlWWwnsjSL7UR2W/x2Ikuz2E5kaRbbie/DOLo0i+1ElmaxncjSLLZTI3Qiq0/LRNMsbuKaV3HfxDVv4r6Ji6ZZhLnmTdxhrnkTd5hr3sQd5k3WXPMm7jDXTLMIc9kOKppmEeayPVQ0zSLMZXuoaJpFmMv2UNE0izCX7aHJaRZBmOmE3DSLIKxsQnKaRRBKOsHSCblpFkFo6YSeThjphNw0iyB4OmFlE5LTLIJQ0gm5aRZBGOmE3DsZb4TkNIsgpH+VktMsguDphJVNSE6zCEJJJ1g6oaYTWjqhpxNGOiE3zSIInk7ITbOIP2flplkEoaQTLJ2Qm2YRhJZO6OmEkU6Y6YTcNIsgrGxCcppFEEo6wdIJNZ3Q0gk9nTDSCblpFkHwdEJumkUMQeSmWQShpBMsnZCbZhGElk7o6YSRTpjpBE8npH9ykpxmUY+Sn2YREN00i20ve8P2tpe9YXvby96wve2btL3sDdvbXvaG7W0ve8P2tpe9YXvby6ZZhL1umsW2l+61umkW21661+qmWWx76V6rm2ax7aV7rW6axbZnSrMIIao0iy0ke8P2tpe9YXvby96wve2btL3sDdvbXvaG7W0ve8P2tpe9YXvby96wHfa6aRbbXrrX6qZZbHvpXqubZrHtpXutbprFtpfutbppFtteutdSpVlsIaY0iy3ElGaxhZjSLLYQS986hZjSLLYQU5rFFmJKs9hCTGkWW4gpzSKEqNIsthD42D+57n8rcaVZbCWuC/T2uBZXmsVW4kqz2EpcaRZbiSvNYitxpVlsJa40i63ElWYRSmRpFluJK81iK3GlWWwlrjSLrdT4lLjSLLYSV5rFVuJKs9hKXGkWW4krzSKUyNIsthJXmsVW4kqz2EpcaRZbqfEpcaVZbCWuNIutxJVmsZW40iy2Eleaxa9VJq40i19OXGkWv5y40ix+OXHdFv/LiSvN4pcTV5rFLye+D+PY0ix+OXGlWfxy4kqz+OXUCJ3Y6pMj9oNdej/YpfeDXXo/2KX3g116P9il94Ndej/YpfeDXXo/2KX3g116P9il94Ndej/YpfeDXXo/2KX3g116P9il94Ndej/Y2faDnW0/2KX3g116P9il94Ndej/YpfeDXXo/2KX3g116P9il94Ndej/YpfeDXXo/2KX3g116P9il94Ndej/YpfeDXXo/2KX3g51tP9jZ9oOdbT/Y2faDnW0/2Nn2g51tP9jZ9oOdbT/Y2faDnW0/2Pn2g51vP9j59oOdbz/Y+faDnW8/2Pn2g51vP9j59oOdbz/Y+faDnW8/2Pn2g51vP9j59oOdbz/Y+faDnW8/2Pn2g51vP9j59oOdbz/Y+faDnW8/2Pn2g51vP9j59oOdbz/Y+faDnW8/2An3g51wP9gJ94OdcD/YCfeDnXA/2An3g51wP9gJ94OdcD/YCfeDnW8/2I4H+8G9zftzfczfQz44MH7zcTKfRebzYNX6B4UKm5CxCVU2ocYm1NmEBpsQW50ubIW6sFVqY6vUxlapja1SG1ulNrZKbWyV2hIr9cmYAMb79fSD06chtMiE6sEmVNiEjE2osgk1NqHOJjTYhCabEFulrmyVurFV6sZWqRtbpW5slbqxVerGVqkbW6VuiZX6ZDiAsfIZ/QAwCoBhAEYFMBqA0QGMAWAAzvl4/3v32dB+UAxCef/f/Q/+kDcW4r3MA0KB/OvP9gHK7yfng9IhlAGhTAjFIZRPnJffT97Gn7MPCKVAKAahVAilQSgdQhkQyoRQHEL5wNl/MkoaoyMHhFIgFINQKoTSIJQOoQwIZUIoHzj7T4aEg7IQlEdj5B/HVMTvFuVoGEzHYAYGsyCYD0wE/hGmYDCGwQDOjV0P187zsTmffOjajvusb7Mno75+1op1tP/37dPZFz7KtespXAXxpSp+fYolzIusucmaV1nzJmveZc2HrLlsBy2yLbTI9lCT7aEm20NNtoeabA812R5qsj3U0nroSZjphLd7Ur//TbX1dklY2YR6pBNKOsHSCW/XNr8fnub1ktDSCT2dMNIJ757pftw/kOqHXxI8nbCyCe1IJ5R0wrvfrd3uL+12TRjphHf/pUe9T12MbleEfqQT0r9K/e0zfX7I3Pu8JHg6YWUTxpFOKOkESyfUdEJLJ/R0wkgnfPBMj3FJ8HTC+2f6rHzzkjDfPtNn9X5EKOkESye8e6bHObk6jnVJaOmEnk4Y6YSZTnj7TK9+J5TjkrCyCX6kE0o6wdIJNZ3Q0gk9nTDSCfODhMsz7Z5OeP9M3yfphl0S1ttn+vw49BGhpBMsnfB2n372u+hq6YSeThjphJlO8HRC+icnDwZKP4aoD6bV/uXllMe9+JVWyhWkgK9X/uBtQ/XRrJOMvUnbV2n7Jm3fpe2HtP2Utndp+6Vsb9K91qR7rUn3WpPutSbda02615p0rzXpXmvSvdZYeu1dqLK0z1MI3BE/eD1YfTT1JmNfpe2btH2Xth/S9lPa3qXtl7J9O6TtpXttk+61TbrXNule26R7bZPutU261zbpXtuke21n6bWnEEv7PIVYOuIpxNLkTiGWvnUKsbSiU4ilu5xCLA3jFGLpAacQS1m/Cw22Sj3Ax/7Zxcz10UbJzyqRpVPXR7sSP/pVmsanVPmU0InwTy7Dro92JX5WyfmUFp2SH3xK8Lr0+/ue66MFkZ9VqnxKjU+p8ykNPqXJp+R8SotOaR18Sujq/eRe8PpoFehnlSqfUuNT6nxKg09p8ik5n9KiU3p0x3+i0+8DAbZTIXQyQqdO94HOo1yCn3WahE58H8YV9GbgHzkZoVMldGqETmz1aYmmWdzENa/ivolr3sR9ExdNswhzzZu4w1zzJu4w17yJO8ybrLnmTdxhrplmEeayHVQ0zSLMZXuoaJpFmMv2UNE0izCX7aGiaRZhLttDk9MsgjDTCblpFkFY2YTkNIsglHSCpRNy0yyC0NIJPZ0w0gm5aRZB8HTCyiYkp1kEoaQTctMsgjDSCbl3Mt4IyWkWQUj/KiWnWQTB0wkrm5CcZhGEkk6wdEJNJ7R0Qk8njHRCbppFEDydkJtmEX/Oyk2zCEJJJ1g6ITfNIggtndDTCSOdMNMJuWkWQVjZhOQ0iyCUdIKlE2o6oaUTejphpBNy0yyC4OmE3DSLGILITbMIQkknWDohN80iCC2d0NMJI50w0wmeTkj/5CQ7zaI5IM3iBhFOswh73Ru2w173hu2w171hO+ybtL3uDdthr3vDdtjr3rAd9ro3bIe9bprFzV44zSLspXutcJpF2Ev3WuE0i7CX7rXCaRZhL91rhdMswp4qzeImxJVmEUK6N2yHve4N22Gve8N22Ddpe90btsNe94btsNe9YTvsdW/YDnvdG7Zv9sJpFmEv3WuF0yzCXrrXCqdZhL10rxVOswh76V4rnGYR9tK9livNIoSo0ixCiCrNIoSo0ixCiKVvnUJUaRYhRJVmEUJUaRYhRJVmEUJUaRY3Ia40ixACH/tn1/2HElmaRSiRXaAX41pkaRahRJZmEUpkaRahRJZmEUpkaRahRJZmEUpkaRY3JbY0i1AiS7MIJbI0i1AiS7MIpcanRJZmEUpkaRahRJZmEUpkaRahRJZmcVNiS7MIJbI0i1AiS7MIJbI0i1BqfEpkaRahRJZmEUpkaRahRJZmEUpkaRZ7lYkszWI7kaVZbCeyNIvtRHZb/HYiS7PYTmRpFtuJ78M4ujSL7USWZrGdyNIstlMjdCKrT70D9oNvEOH94LDX3VkKe92dpbDX3VkK+yZtr7uzFPa6O0thr7uzFPa6O0thr7sffLMX3g8Oe+leK7wfHPbSvVZ4PzjspXut8H5w2Ev3WuH94LCn2g++CXHtB4eQ7s5S2OvuLIW97s5S2Ddpe92dpbDX3VkKe92dpbDX3VkKe92dpZu98H5w2Ev3WuH94LCX7rXC+8FhL91rhfeDw1661wrvB4e9dK/l2g8OIar94BCi2g8OIar94BBi6VunENV+cAhR7QeHENV+cAhR7QeHENV+8E2Iaz84hMDH/tkCZSiR7QeHEtlIYoxrke0HhxLZfnAoke0HhxLZfnAoke0HhxLZfnAoke0H35TY9oNDiWw/OJTI9oNDiWw/OJQanxLZfnAoke0HhxLZfnAoke0HhxLZfvBNiW0/OJTI9oNDiWw/OJTI9oNDqfEpke0HhxLZfnAoke0HhxLZfnAoke0H71Umsv3g7US2H7ydyPaDtxPf/h3dfvB2ItsP3k58H8bR7QdvJ7L94O1Eth+8nRqhE1l9GvWvd3Oc23HXafbExs8Cvo729dL6wl/Hb+KuKr5Uxcsha15kzU3WvMqaN1nzLms+ZM1lO2iRbaFFtoeabA812R5qsj3UZHuoyfZQk+2hltZDT8JMJ7zdk/p9Uqf1dklY2YR6pBNKOsHSCW/XNr8fnub1ktDSCT2dMNIJ757pfsy/X9oPvyR4OmFlE9qRTijphHe/W7vdX9rtmjDSCe/+S496H3Ub3a4I/UgnpH+V+ttnup3fS31eEjydsLIJ40gnlHSCpRNqOqGlE3o6YaQTPnimx7gkeDrh/TN9Vr55SZhvn+mzej8ilHSCpRPePdPj3IcYx7oktHRCTyeMdMJMJ7x9ptf98udRjkvCyib4kU4o6QRLJ9R0Qksn9HTCSCfMDxIuz7R7OuH9M32faBl2SVhvn+nz49BHhJJOsHTC23362e+iq6UTejphpBNmOsHTCemfnDwYnf4YYlZAmsWsymkWsyqnWcyqnGYxq3KaxazKaRazKqdZzKqcZjGrcprFrMppFrMqp1nMqpxmMatymsWsymkWsyqnWcyqnGYxq3KaxazKaRazKqdZzKqcZjErWZrFrGRpFrMqp1nMqpxmMatymsWsymkWsyqnWcyqnGYxq3KaxazKaRazKqdZzKqcZjGrcppF2Ev3WuE0i7CX7rXCaRazKqdZhL10rxVOs5hVOc1iVrI0ixCiSrMIIao0ixCiSrMIIZa+dQpRpVnMSpZmMStZmsWsZGkWs5KlWcxKlmYxK12axax0aRaz0qVZzEqXZjErXZrFrHRpFrPSpVnMSpdmMStdmsWsdGkWs9KlWcxKl2YxK12axax0aRaz0qVZzEqXZjErXZrFrHRpFrPSpVnMSpdmMStdmsWsdGkWs9KlWcxKl2YxK12axax0aRaz0qVZzEqXZjErXZrFrHRpFrPypVlsJ7I0i+1Elmaxnchui99OZGkW24kszWI78X0YR5dmsZ3I0iy2E1maxXZqhE5k9ckP0TSLm7jmVdw3cc2buG/iomkWYa55E3eYa97EHeaaN3GHeZM117yJO8w10yzCXLaDiqZZhLlsDxVNswhz2R4qmmYR5rI9VDTNIsxle2hymkUQZjohN80iCCubkJxmEYSSTrB0Qm6aRRBaOqGnE0Y6ITfNIgieTljZhOQ0iyCUdEJumkUQRjoh907GGyE5zSII6V+l5DSLIHg6YWUTktMsglDSCZZOqOmElk7o6YSRTshNswiCpxNy0yziz1m5aRZBKOkESyfkplkEoaUTejphpBNmOiE3zSIIK5uQnGYRhJJOsHRCTSe0dEJPJ4x0Qm6aRRA8nZCbZhFDELlpFkEo6QRLJ+SmWQShpRN6OmGkE2Y6wdMJ6Z+cZKdZ+AKkWdwgwmkWYa97w3bY696wHfa6N2yHfZO2171hO+x1b9gOe90btsNe94btsNdNs7jZC6dZhL10rxVOswh76V4rnGYR9tK9VjjNIuyle61wmkXYU6VZ3IS40ixCSPeG7bDXvWE77HVv2A77Jm2ve8N22OvesB32ujdsh73uDdthr3vD9s1eOM0i7KV7rXCaRdhL91rhNIuwl+61wmkWYS/da4XTLMJeutdypVmEEFWaRQhRpVmEEFWaRQix9K1TiCrNIoSo0ixCiCrNIoSo0ixCiCrN4ibElWYRQuBj/+y6/1AiS7MIJbIL9GJciyzNIpTI0ixCiSzNIpTI0ixCiSzNIpTI0ixCiSzN4qbElmYRSmRpFqFElmYRSmRpFqHU+JTI0ixCiSzNIpTI0ixCiSzNIpTI0ixuSmxpFqFElmYRSmRpFqFElmYRSo1PiSzNIpTI0ixCiSzNIpTI0ixCiSzNYq8ykaVZbCeyNIvtRJZmsZ3YbotffGkW24kszWI78X0YR5dmsZ3I0iy2E1maxXZqhE5k9WkNwH7wDSK8Hxz2ujtLYa+7sxT2ujtLYd+k7XV3lsJed2cp7HV3lsJed2cp7HX3g2/2wvvBYS/da4X3g8NeutcK7weHvXSvFd4PDnvpXiu8Hxz2VPvBNyGu/eAQ0t1ZCnvdnaWw191ZCvsmba+7sxT2ujtLYa+7sxT2ujtLYa+7s3SzF94PDnvpXiu8Hxz20r1WeD847KV7rfB+cNhL91rh/eCwl+61XPvBIUS1HxxCVPvBIUS1HxxCLH3rFKLaDw4hqv3gEKLaDw4hqv3gEKLaD74Jce0HhxD42D9boAwlsv3gUCIbSYxxLbL94FAi2w8OJbL94FAi2w8OJbL94FAi2w8OJbL94JsS235wKJHtB4cS2X5wKJHtB4dS41Mi2w8OJbL94FAi2w8OJbL94FAi2w++KbHtB4cS2X5wKJHtB4cS2X5wKDU+JbL94FAi2w8OJbL94FAi2w8OJbL94L3KRLYfvJ3I9oO3E9l+8Hbi27+j2w/eTmT7wduJ78M4uv3g7US2H7ydyPaDt1MjdOKqT+uYD5ah6vmBULOvNlnqOJ+7XkP6g+fKi8/Zi8/Vf/1cPex4NCd++1P9+eU3m+3r2XFc/ANYn/ffzax/a1rx6pNUYCSDkSqM1GCkDiMNGGnCSA4jLRSpwWpEg9WIBqsRDVYjGqxGNFiNaLAa0WA1osFqRIPViA6rER1WIzqsRnRYjeiwGtFhNaLDakSH1YgOqxEdViMGrEYMWI0YsBoxYDViwGrEgNWIAasRA1YjBqxGDFiNmLAaMWE1YsJqxITViAmrERNWIyasRkxYjZiwGjFhNcJhNcJhNcJhNcJhNcJhNcJhNcJhNcJhNcJhNcJhNWLBasSC1YgFqxELViMWrEYsWI1YsBqxYDViwWrEgtWIRzNQKaiCQxkOVXGohkN1HGrgUBOHchwKVy0KrloUXLUouGpRcNWi4KpFwVWLgqsWBVctCq5aFFy1MFy1MFy1MFy1MFy1MFy1MFy1MFy1MFy1MFy1MFy1wI1hFtwcZsENYhbcJGbBjWIW3CxmwQ1jFtw0ZsGNYxbcPGbBDWQW3ERmwY1kFtxMZsENZRbcVGbBjWUW3FxmwQ1mFtxkZsGNZhbcbGbBDWcW3HRmwY1nFtx8ZsENaBbchGbBjWgW3IxmwQ1pFtyUZsGNaRbcnGbBDWoW3KRmwY1qFtysZsENaxbctGbBjWsW3LxmwQ1sFtzEZsGNbBbczGbBDW0W3NRmwY1tFtzcZsENbhbc5GbBjW4W3OxmwQ1vFtz0ZsGNbxbc/GbBDXAW3ARnwY1wFtwMZ8ENcRbcFGfBjXEW3BxnwQ1yFtwkZ8GNchbcLKfhZjkNN8tpuFlOw81y2tFwqI5DDRxq4lCOQ+GqBW6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznIab5TTcLKfhZjkNN8tpuFlOw81yGm6W03CznBU3y1lxs5wVN8tZcbOc9Wg4FC6ZEDfLWXGznBU3y1lxs5y1ACNMcdUCN8tZcbOcFTfLWXGznBU3y1lxs5wVN8tZcbOcFTfLWQ2YeIyrFo9mOW9l5ETVfjxB1el3s+rmT1692rpHh6/e6/lqa9/FGqtYZxUbrGKTVcxZxRap2KNp2J8XK6xixirGWvkra+WvrJW/slb+ylr5K2vlfzirvMqX2OhPUKPa368e/u211S5e2+r4+7Wtz3+89pR6ONWcJnX7ct6lRnkgVRiljFGqMko1RqnOKDU+IlXmKTWeSPno90rlY9jXq/v6pjU5tZxTa1Fq9YNTq3BqGVxrHvf/9e0/1wOtyqnVOLU6p9bg1JqcWs6pha/ys69Ta8xrrXFwahVOLePUqpxajVOrc2r9QJWv80vL/6F18Tejdv6Jydq3zz9uH4Z8exPzf+FN+P/Cm3j0dwJf55toNp68idurz4+xVv3Ix1iPtk9+XqywihmrWGUVa6xinVVssIpNVjFnFWOt/M5a+Z218jtr5XfWyu+slf/RvtTtR+YvsVae/VD52b8fPNqs+lmpySjljFKLUOrRBti/lPoXvz0tq/fDvax9//X62+9Dj7bFflrLOLUqp1bj1OqcWgOvZceXlv9D62K8xNZZTWr5enW8n//z4tnvHXmu9u0jj29vd/633q7/t97u+i+93XYc/623W8jfbj0/oG219e9v9+s92P/Ae6j/A++hsb+H2c734Mf1e+j076F+vYd1/R7Yf/z4k/eA/5ni9hHG/T3cusDlT3btcE6tRalVjh/QqqdWqQ+0CqeW/YCWnVpmD7Qqp1bj1ML3j9bO30jbXA+0BqfW/AEtP7V8PtDCV/lezq9Wb4++WusHtM6vVv/+ueN3LTs4tcoPaM1Taz7oiYav8v38m8oa5g+0KqdW+wGt8x9x1PFAC1/lxzx/wp6Pft6ywamFr/JjrC+tq++t9df1F2uelWXObz+n3b4/z+fmi8/5i8+t1567Xgv/g+fKi8/Zi89dVh4v5+qHPXiuvfhcf/G58eJz88Xn/MXn1mvPXS+U+vmLiy+7fq68+Jy9+Fx98bn24nP9xefGi89dfr+sc9NhleP6OX/xufXac9dran/wXHnxOXvxufric5ffL7ePt+7P1etzdL3L9AfPjRefmy8+5y8+t1577nrh5Q+eK0+ea9f/ftcrI3/wXH3xuevvl16/fsi9fq6/+Nx48bn54nP+4nPrteeux9X/4Lnr7xe//5xaju7/ePD/+zcvPikGoVQIpUEoHUIZEMqEUBxCWQjK9QjyxymQs++Qs++Qs++Qs++Qs++Qs++Qs++Qs++Qs78gZ39Bzv6CnP0FOfsLcvbX++eln1u8fX59TGjz68O85QBIOd7/Fuvn3xC/X//6T4pBKBVCaRBKh1D+bXv5enK++qRVxPe1NQilQygDQpkQygeq2ur3v5oc/QFlISj1gFAKhGIQygfO/nlxwjjGA0qDUDqEMiCUCaE4hLIQnbMdEArkp7MG+emsQX46a5Cfzhrkp7M2IJQJoTiEAjn7HXL2O+TsP/gT5KcpkLPfIWe/Q85+h5z9Djn7HXL2O+TsD8jZH5CzPyBnf0DO/oCc/QE5+wNy9gfk7A/I2R+Qsz8hZ39Czv6EnP0JOfsTcvYn5OxPyNmf6We/9r+uR6R7Oyek+7frS+3yKst+Z7iX37+0FL/ni0SA3deL6+njZD6LzOfBauMPChU2IWMTqmxCjU2oswkNNiG2Ol3YCnVhq9TGVqmNrVIbW6U2tkptbJXa2Cq1JVbqkzEBjPfr6bfVknq8/4VdZEL1YBMqbELGJlTZhBqbUGcTGmxCk02IrVJXtkrd2Cp1Y6vUja1SN7ZK3dgqdWOr1I2tUrfESn0yHMBY+Yx+ABgFwDAAowIYDcDoAMYAMADnfLz/vVuO476yXY5ilxSDUN7/dy/WvqrvuPwAYSzEe5kHhAL515/tA5TzvqdyfLsd6julQygDQpkQikMonzgvo3xR5hXFDwilQCgGoVQIpUEoHUIZEMqEUBxC+cDZL+fFZrf/uvwZZh0QSoFQDEKpEEqDUDqEMiCUCaF84OyXaSfl+8TbN8pCUMpxYDAV8bvFg3X6z2M6BjMwmAXBfGAi8I8wBYMxDAZwbub1cO08H5vzyYeu7bhfYtus//6lftaKdfwjcemFj3Ln9RSugvhSFb8+xRLmRdbcZM2rrHmTNe+y5kPWXLaDFtkWWmR7qMn2UJPtoSbbQ022h5psDzXZHmppPfQkzHTC2z3pvAS99XZJWNmEeqQTSjrB0glv17Zzcbh5vSS0dEJPJ4x0wrtnuh/3D6T64ZcETyesbEI70gklnfDud2u3+0u7XRNGOuHdf+lR71MXo9sVoR/phPSvUn/7TJ8fMvc+LwmeTljZhHGkE0o6wdIJNZ3Q0gk9nTDSCR8802NcEjyd8P6ZPivfvCTMt890XU8IJZ1g6YR3z/Q4J1fHsS4JLZ3Q0wkjnTDTCW+f6a/LuMtxSVjZBD/SCSWdYOmEmk5o6YSeThjphPlBwuWZdk8nvH+m75N0wy4J6+0zfX4c+ohQ0gmWTni7Tz/7XXS1dEJPJ4x0wkwneDoh/ZOTBwOlH0O0B9NqZdRzbnf0J39yKe24F7/SSrmCPJhW/HeU5idlPvsr0OduG2qPZp1k7E3avkrbN2n7Lm0/pO2ntL1L2y9le5PutSbda02615p0rzXpXmvSvdake61J91qT7rXG0mvvQpWlfZ5C4I74wevB2qOpNxn7Km3fpO27tP2Qtp/S9i5tv5Tt2yFtL91rm3SvbdK9tkn32ibda5t0r23SvbZJ99om3Ws7S689hVja5ynE0hFPIZYmdwqx9K1TiKUVnUIs3eUUYmkYpxBLDziFWMr6XWiwVeoBPvbPLmZujzZKflYJ/I397HKx9mhX4ke/StP4lCqf0kAr/f4y7PZoV+JnlZxPadEp+cGnBK9Lv7/vuT1aEPlZpcqn1PiUOp/S4FOafErOp7TolNbBp4Su3k/uBW+PVoF+VqnyKTU+pc6nNPiUJp+S8yktOqVHd/wnOv0+EGA7FUInI3TqdB/oPMol+FmnSejE92FcQW8G/pGTETpVQqdG6ERWn3oTTbO4iWtexX0T17yJ+yYummYR5po3cYe55k3cYa55E3eYN1lzzZu4w1wzzSLMZTuoaJpFmMv2UNE0izCX7aGiaRZhLttDRdMswly2hyanWQRhphNy0yyCsLIJyWkWQSjpBEsn5KZZBKGlE3o6YaQTctMsguDphJVNSE6zCEJJJ+SmWQRhpBNy72S8EZLTLIKQ/lVKTrMIgqcTVjYhOc0iCCWdYOmEmk5o6YSeThjphNw0iyB4OiE3zSL+nJWbZhGEkk6wdEJumkUQWjqhpxNGOmGmE3LTLIKwsgnJaRZBKOkESyfUdEJLJ/R0wkgn5KZZBMHTCblpFjEEkZtmEYSSTrB0Qm6aRRBaOqGnE0Y6YaYTPJ2Q/slJdprFqIA0ixtEOM0i7HVv2A573Ru2w173hu2wb9L2ujdsh73uDdthr3vDdtjr3rAd9rppFjd74TSLsJfutcJpFmEv3WuF0yzCXrrXCqdZhL10rxVOswh7qjSLmxBXmkUI6d6wHfa6N2yHve4N22HfpO11b9gOe90btsNe94btsNe9YTvsdW/YvtkLp1mEvXSvFU6zCHvpXiucZhH20r1WOM0i7KV7rXCaRdhL91quNIsQokqzCCGqNIsQokqzCCGWvnUKUaVZhBBVmkUIUaVZhBBVmkUIUaVZ3IS40ixCCHzsn133H0pkaRahRHaBXoxrkaVZhBJZmkUokaVZhBJZmkUokaVZhBJZmkUokaVZ3JTY0ixCiSzNIpTI0ixCiSzNIpQanxJZmkUokaVZhBJZmkUokaVZhBJZmsVNiS3NIpTI0ixCiSzNIpTI0ixCqfEpkaVZhBJZmkUokaVZhBJZmkUokaVZ7FUmsjSL7USWZrGdyNIsthPZbfHbiSzNYjuRpVlsJ74P4+jSLLYTWZrFdiJLs9hOjdCJrD7NA7AffIMI7weHve7OUtjr7iyFve7OUtg3aXvdnaWw191ZCnvdnaWw191ZCnvd/eCbvfB+cNhL91rh/eCwl+61wvvBYS/da4X3g8NeutcK7weHPdV+8E2Iaz84hHR3lsJed2cp7HV3lsK+Sdvr7iyFve7OUtjr7iyFve7OUtjr7izd7IX3g8NeutcK7weHvXSvFd4PDnvpXiu8Hxz20r1WeD847KV7Ldd+cAhR7QeHENV+cAhR7QeHEEvfOoWo9oNDiGo/OISo9oNDiGo/OISo9oNvQlz7wSEEPvbPFihDiWw/OJTIRhJjXItsPziUyPaDQ4lsPziUyPaDQ4lsPziUyPaDQ4lsP/imxLYfHEpk+8GhRLYfHEpk+8Gh1PiUyPaDQ4lsPziUyPaDQ4lsPziUyPaDb0ps+8GhRLYfHEpk+8GhRLYfHEqNT4lsPziUyPaDQ4lsPziUyPaDQ4lsP3ivMpHtB28nsv3g7US2H7yd+Pbv6PaDtxPZfvB24vswjm4/eDuR7QdvJ7L94O3UCJ3Y6pP/9W6OczvuOs2e2PhZwNfRvl5aX/nruP/lquJLVbwcsuZF1txkzauseZM177LmQ9ZctoMW2RZaZHuoyfZQk+2hJttDTbaHmmwPNdkeamk99CTMdMLbPanfJ3Vab5eElU2oRzqhpBMsnfB2bfP74WleLwktndDTCSOd8O6Z7sf8+6X98EuCpxNWNqEd6YSSTnj3u7Xb/aXdrgkjnfDuv/So91G30e2K0I90QvpXqb99ptv5vdTnJcHTCSubMI50QkknWDqhphNaOqGnE0Y64YNneoxLgqcT3j/TZ+Wbl4T59pk+q/cjQkknWDrh3TM9zn2IcaxLQksn9HTCSCfMdMLbZ3rdL38e5bgkrGyCH+mEkk6wdEJNJ7R0Qk8njHTC/CDh8ky7pxPeP9P3iZZhl4T19pk+Pw59RCjpBEsnvN2nn/0uulo6oacTRjphphM8nZD+ycmD0emPIdwBaRbuymkW7sppFu7KaRbuymkW7sppFu7KaRbuymkW7sppFu7KaRbuymkW7sppFu7KaRbuymkW7sppFu7KaRbuymkW7sppFu7KaRbuymkW7mRpFu5kaRbuymkW7sppFu7KaRbuymkW7sppFu7KaRbuymkW7sppFu7KaRbuymkW7sppFmEv3WuF0yzCXrrXCqdZuCunWYS9dK8VTrNwV06zcCdLswghqjSLEKJKswghqjSLEGLpW6cQVZqFO1mahTtZmoU7WZqFO1mahTtZmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7XZqFO12ahTtdmoU7X5rFdiJLs9hOZGkW24nstvjtRJZmsZ3I0iy2E9+HcXRpFtuJLM1iO5GlWWynRuhEVp9WF02zuIlrXsV9E9e8ifsmLppmEeaaN3GHueZN3GGueRN3mDdZc82buMNcM80izGU7qGiaRZjL9lDRNIswl+2homkWYS7bQ0XTLMJctocmp1kEYaYTctMsgrCyCclpFkEo6QRLJ+SmWQShpRN6OmGkE3LTLILg6YSVTUhOswhCSSfkplkEYaQTcu9kvBGS0yyCkP5VSk6zCIKnE1Y2ITnNIgglnWDphJpOaOmEnk4Y6YTcNIsgeDohN80i/pyVm2YRhJJOsHRCbppFEFo6oacTRjphphNy0yyCsLIJyWkWQSjpBEsn1HRCSyf0dMJIJ+SmWQTB0wm5aRYxBJGbZhGEkk6wdEJumkUQWjqhpxNGOmGmEzydkP7JSXKaRTlafppFQHTTLLa97A3b2172hu1tL3vD9rZv0vayN2xve9kbtre97A3b2172hu1tL5tmEfa6aRbbXrrX6qZZbHvpXqubZrHtpXutbprFtpfutbppFtueKc0ihKjSLLaQ7A3b2172hu1tL3vD9rZv0vayN2xve9kbtre97A3b2172hu1tL3vDdtjrpllse+leq5tmse2le61umsW2l+61umkW21661+qmWWx76V5LlWaxhZjSLLYQU5rFFmJKs9hCLH3rFGJKs9hCTGkWW4gpzWILMaVZbCGmNIsQokqz2ELgY//kuv+txJVmsZW4LtDb41pcaRZbiSvNYitxpVlsJa40i63ElWaxlbjSLLYSV5pFKJGlWWwlrjSLrcSVZrGVuNIstlLjU+JKs9hKXGkWW4krzWIrcaVZbCWuNItQIkuz2EpcaRZbiSvNYitxpVlspcanxJVmsZW40iy2EleaxVbiSrPYSlxpFr9WmbjSLH45caVZ/HLiSrP45cR1W/wvJ640i19OXGkWv5z4PoxjS7P45cSVZvHLiSvN4pdTI3Qiq0+lAPaDbxDh/eCw191ZCnvdnaWw191ZCvsmba+7sxT2ujtLYa+7sxT2ujtLYa+7H3yzF94PDnvpXiu8Hxz20r1WeD847KV7rfB+cNhL91rh/eCwp9oPvglx7QeHkO7OUtjr7iyFve7OUtg3aXvdnaWw191ZCnvdnaWw191ZCnvdnaWbvfB+cNhL91rh/eCwl+61wvvBYS/da4X3g8NeutcK7weHvXSv5doPDiGq/eAQotoPDiGq/eAQYulbpxDVfnAIUe0HhxDVfnAIUe0HhxDVfvBNiGs/OITAx/7ZAmUoke0HhxLZSGKMa5HtB4cS2X5wKJHtB4cS2X5wKJHtB4cS2X5wKJHtB9+U2PaDQ4lsPziUyPaDQ4lsPziUGp8S2X5wKJHtB4cS2X5wKJHtB4cS2X7wTYltPziUyPaDQ4lsPziUyPaDQ6nxKZHtB4cS2X5wKJHtB4cS2X5wKJHtB+9VJrL94O1Eth+8ncj2g7cT3/4d3X7wdiLbD95OfB/G0e0Hbyey/eDtRLYfvJ0aoRNZfbL6YD+4t3l/ro/5e8gHB8ZvPk7ms8h8Hqxa/6BQYRMyNqHKJtTYhDqb0GATYqvTha1QF7ZKbWyV2tgqtbFVamOr1MZWqY2tUltipT4ZE8B4v55+cPo0hBaZUD3YhAqbkLEJVTahxibU2YQGm9BkE2Kr1JWtUje2St3YKnVjq9SNrVI3tkrd2Cp1Y6vULbFSnwwHMFY+ox8ARgEwDMCoAEYDMDqAMQAMwDkf73/vPhvaD4pBKO//u//BH/LGQryXeUAokH/92T5A+f3kfFA6hDIglAmhOITyifPy+8nb+HP2AaEUCMUglAqhNAilQygDQpkQikMoHzj7T0ZJY3TkgFAKhGIQSoVQGoTSIZQBoUwI5QNn/8mQcFAWgvJojPzjmIr43aIcDYPpGMzAYBYE84GJwD/CFAzGMBjAuenXw7XzfGzOJx+6tuM+69vsyaivn7ViHe3/fft09oWPcvv1FK6C+FIVvz7FEuZF1txkzauseZM177LmQ9ZctoMW2RZaZHuoyfZQk+2hJttDTbaHmmwPNdkeamk99CTMdMLbPanf/6baerskrGxCPdIJJZ1g6YS3a5vfD0/zeklo6YSeThjphHfPdD/uH0j1wy8Jnk5Y2YR2pBNKOuHd79Zu95d2uyaMdMK7/9Kj3qcuRrcrQj/SCelfpf72mT4/ZO59XhI8nbCyCeNIJ5R0gqUTajqhpRN6OmGkEz54pse4JHg64f0zfVa+eUmYb5/ps3o/IpR0gqUT3j3T45xcHce6JLR0Qk8njHTCTCe8faZXvxPKcUlY2QQ/0gklnWDphJpOaOmEnk4Y6YT5QcLlmXZPJ7x/pu+TdMMuCevtM31+HPqIUNIJlk54u08/+110tXRCTyeMdMJMJ3g6If2TkwcDpR9D1AfTav/ycsrjXvxKK+UKUsDXK3/wtqH6aNZJxt6k7au0fZO279L2Q9p+Stu7tP1StjfpXmvSvdake61J91qT7rUm3WtNuteadK816V5rLL32LlRZ2ucpBO6IH7werD6aepOxr9L2Tdq+S9sPafspbe/S9kvZvh3S9tK9tkn32ibda5t0r23SvbZJ99om3WubdK9t0r22s/TaU4ilfZ5CLB3xFGJpcqcQS986hVha0SnE0l1OIZaGcQqx9IBTiKWs34UGW6Ue4GP/7GLm+mij5GeVyNKp66NdiR/9Kk3jU6p8SuhE+CeXYddHuxI/q+R8SotOyQ8+JXhd+v19z/XRgsjPKlU+pcan1PmUBp/S5FNyPqVFp7QOPiV09X5yL3h9tAr0s0qVT6nxKXU+pcGnNPmUnE9p0Sk9uuM/0en3gQDbqRA6GaFTp/tA51Euwc86TUInvg/jCnoz8I+cjNCpEjo1Qiey+tRMNM3iJq55FfdNXPMm7pu4aJpFmGvexB3mmjdxh7nmTdxh3mTNNW/iDnPNNIswl+2gomkWYS7bQ0XTLMJctoeKplmEuWwPFU2zCHPZHpqcZhGEmU7ITbMIwsomJKdZBKGkEyydkJtmEYSWTujphJFOyE2zCIKnE1Y2ITnNIgglnZCbZhGEkU7IvZPxRkhOswhC+lcpOc0iCJ5OWNmE5DSLIJR0gqUTajqhpRN6OmGkE3LTLILg6YTcNIv4c1ZumkUQSjrB0gm5aRZBaOmEnk4Y6YSZTshNswjCyiYkp1kEoaQTLJ1Q0wktndDTCSOdkJtmEQRPJ+SmWcQQRG6aRRBKOsHSCblpFkFo6YSeThjphJlO8HRC+icn2WkWvQDSLG4Q4TSLsNe9YTvsdW/YDnvdG7bDvknb696wHfa6N2yHve4N22Gve8N22OumWdzshdMswl661wqnWYS9dK8VTrMIe+leK5xmEfbSvVY4zSLsqdIsbkJcaRYhpHvDdtjr3rAd9ro3bId9k7bXvWE77HVv2A573Ru2w173hu2w171h+2YvnGYR9tK9VjjNIuyle61wmkXYS/da4TSLsJfutcJpFmEv3Wu50ixCiCrNIoSo0ixCiCrNIoRY+tYpRJVmEUJUaRYhRJVmEUJUaRYhRJVmcRPiSrMIIfCxf3bdfyiRpVmEEtkFejGuRZZmEUpkaRahRJZmEUpkaRahRJZmEUpkaRahRJZmcVNiS7MIJbI0i1AiS7MIJbI0i1BqfEpkaRahRJZmEUpkaRahRJZmEUpkaRY3JbY0i1AiS7MIJbI0i1AiS7MIpcanRJZmEUpkaRahRJZmEUpkaRahRJZmsVeZyNIsthNZmsV2Ikuz2E5kt8VvJ7I0i+1Elmaxnfg+jKNLs9hOZGkW24kszWI7NUIntvrkiP1gl94Pdun9YJfeD3bp/WCX3g926f1gl94Pdun9YJfeD3bp/WCX3g926f1gl94Pdun9YJfeD3bp/WCX3g926f1gl94Pdrb9YGfbD3bp/WCX3g926f1gl94Pdun9YJfeD3bp/WCX3g926f1gl94Pdun9YJfeD3bp/WCX3g926f1gl94Pdun9YJfeD3bp/WBn2w92tv1gZ9sPdrb9YGfbD3a2/WBn2w92tv1gZ9sPdrb9YGfbD3a+/WDn2w92vv1g59sPdr79YOfbD3a+/WDn2w92vv1g59sPdr79YOfbD3a+/WDn2w92vv1g59sPdr79YOfbD3a+/WDn2w92vv1g59sPdr79YOfbD3a+/WDn2w92vv1g59sPdr79YOfbD3bC/WAn3A92wv1gJ9wPdsL9YCfcD3bC/WAn3A92wv1gJ9wPdsL9YOfbDx7jr3dznNtx12n2xMbPAr6O9vXS+sJfx2/iriq+VMXLIWteZM1N1rzKmjdZ8y5rPmTNZTtokW2hRbaHmmwPNdkearI91GR7qMn2UJPtoZbWQ0/CTCe83ZP6fVKn9XZJWNmEeqQTSjrB0glv1za/H57m9ZLQ0gk9nTDSCe+e6X7Mv1/aD78keDphZRPakU4o6YR3v1u73V/a7Zow0gnv/kuPeh91G92uCP1IJ6R/lfrbZ7qd30t9XhI8nbCyCeNIJ5R0gqUTajqhpRN6OmGkEz54pse4JHg64f0zfVa+eUmYb5/ps3o/IpR0gqUT3j3T49yHGMe6JLR0Qk8njHTCTCe8fabX/fLnUY5Lwsom+JFOKOkESyfUdEJLJ/R0wkgnzA8SLs+0ezrh/TN9n2gZdklYb5/p8+PQR4SSTrB0wtt9+tnvoqulE3o6YaQTZjrB0wnpn5w8GJ3+GGIOQJrFHMppFnMop1nMoZxmMYdymsUcymkWcyinWcyhnGYxh3KaxRzKaRZzKKdZzKGcZjGHcprFHMppFnMop1nMoZxmMYdymsUcymkWcyinWcyhnGYxB1maxRxkaRZzKKdZzKGcZjGHcprFHMppFnMop1nMoZxmMYdymsUcymkWcyinWcyhnGYxh3KaRdhL91rhNIuwl+61wmkWcyinWYS9dK8VTrOYQznNYg6yNIsQokqzCCGqNIsQokqzCCGWvnUKUaVZzEGWZjEHWZrFHGRpFnOQpVnMQZZmMQddmsUcdGkWc9ClWcxBl2YxB12axRx0aRZz0KVZzEGXZjEHXZrFHHRpFnPQpVnMQZdmMQddmsUcdGkWc9ClWcxBl2YxB12axRx0aRZz0KVZzEGXZjEHXZrFHHRpFnPQpVnMQZdmMQddmsUcdGkWc9ClWcxBl2YxB12axRx0aRZz8KVZbCeyNIvtRJZmsZ3IbovfTmRpFtuJLM1iO/F9GEeXZrGdyNIsthNZmsV2aoROZPXJq2iaxU1c8yrum7jmTdw3cdE0izDXvIk7zDVv4g5zzZu4w7zJmmvexB3mmmkWYS7bQUXTLMJctoeKplmEuWwPFU2zCHPZHiqaZhHmsj00Oc0iCDOdkJtmEYSVTUhOswhCSSdYOiE3zSIILZ3Q0wkjnZCbZhEETyesbEJymkUQSjohN80iCCOdkHsn442QnGYRhPSvUnKaRRA8nbCyCclpFkEo6QRLJ9R0Qksn9HTCSCfkplkEwdMJuWkW8ees3DSLIJR0gqUTctMsgtDSCT2dMNIJM52Qm2YRhJVNSE6zCEJJJ1g6oaYTWjqhpxNGOiE3zSIInk7ITbOIIYjcNIsglHSCpRNy0yyC0NIJPZ0w0gkzneDphPRPTrLTLJYB0ixuEOE0i7DXvWE77HVv2A573Ru2w75J2+vesB32ujdsh73uDdthr3vDdtjrplnc7IXTLMJeutcKp1mEvXSvFU6zCHvpXiucZhH20r1WOM0i7KnSLG5CXGkWIaR7w3bY696wHfa6N2yHfZO2171hO+x1b9gOe90btsNe94btsNe9YftmL5xmEfbSvVY4zSLspXutcJpF2Ev3WuE0i7CX7rXCaRZhL91rudIsQogqzSKEqNIsQogqzSKEWPrWKUSVZhFCVGkWIUSVZhFCVGkWIUSVZnET4kqzCCHwsX923X8okaVZhBLZBXoxrkWWZhFKZGkWoUSWZhFKZGkWoUSWZhFKZGkWoUSWZnFTYkuzCCWyNItQIkuzCCWyNItQanxKZGkWoUSWZhFKZGkWoUSWZhFKZGkWNyW2NItQIkuzCCWyNItQIkuzCKXGp0SWZhFKZGkWoUSWZhFKZGkWoUSWZrFXmcjSLLYTWZrFdiJLs9hOZLfFbyeyNIvtRJZmsZ34PoyjS7PYTmRpFtuJLM1iOzVCJ7b6tBD7wUt6P3hJ7wcv6f3gJb0fvKT3g5f0fvCS3g9e0vvBS3o/eEnvBy/p/eAlvR+8pPeDl/R+8JLeD17S+8FLej94Se8HL+n94MW2H7zY9oOX9H7wkt4PXtL7wUt6P3hJ7wcv6f3gJb0fvKT3g5f0fvCS3g9e0vvBS3o/eEnvBy/p/eAlvR+8pPeDl/R+8JLeD17S+8GLbT94se0HL7b94MW2H7zY9oMX237wYtsPXmz7wYttP3ix7Qcvtv3gxbcfvPj2gxfffvDi2w9efPvBi28/ePHtBy++/eDFtx+8+PaDF99+8OLbD158+8GLbz948e0HL7794MW3H7z49oMX337w4tsPXnz7wYtvP3jx7Qcvvv3gxbcfvPj2gxfffvDi2w9efPvBi28/eBHuBy/C/eBFuB+8CPeDF+F+8CLcD16E+8GLcD94Ee4HL8L94EW4H7zo9oPH8kfz0Lc/SZ8Ys9nOR8s4LkDW5/13EOvfinO8+iQVGMlgpAojNRipw0gDRpowksNIC0VqsBrRYDWiwWpEg9WIBqsRDVYjGqxGNFiNaLAa0WA1osNqRIfViA6rER1WIzqsRnRYjeiwGtFhNaLDakSH1YgBqxEDViMGrEYMWI0YsBoxYDViwGrEgNWIAasRA1YjJqxGTFiNmLAaMWE1YsJqxITViAmrERNWIyasRkxYjXBYjXBYjXBYjXBYjXBYjXBYjXBYjXBYjXBYjXBYjViwGrFgNWLBasSC1YgFqxELViMWrEYsWI1YsBqxYDXi0axPCqrgUIZDVRyq4VAdhxo41MShHIfCVYuCqxYFVy0KrloUXLUouGpRcNWi4KpFwVWLgqsWBVctDFctDFctDFctDFctDFctDFctDFctDFctDFctDFctcGOYBTeHWXCDmAU3iVlwo5gFN4tZcMOYBTeNWXDjmAU3j1lwA5kFN5FZcCOZBTeTWXBDmQU3lVlwY5kFN5dZcIOZBTeZWXCjmQU3m1lww5kFN51ZcOOZBTefWXADmgU3oVlwI5oFN6NZcEOaBTelWXBjmgU3p1lwg5oFN6lZcKOaBTerWXDDmgU3rVlw45oFN69ZcAObBTexWXAjmwU3s1lwQ5sFN7VZcGObBTe3WXCDmwU3uVlwo5sFN7tZcMObBTe9WXDjmwU3v1lwA5wFN8FZcCOcBTfDWXBDnAU3xVlwY5wFN8dZcIOcBTfJWXCjnAU3y2m4WU7DzXIabpbTcLOcdjQcquNQA4eaOJTjULhqgZvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsp+FmOQ03y2m4WU7DzXIabpbTcLOchpvlNNwsZ8XNclbcLGfFzXJW3CxnPRoOhUsmxM1yVtwsZ8XNclbcLGctwAhTXLXAzXJW3Cxnxc1yVtwsZ8XNclbcLGfFzXJW3Cxnxc1yVgMmHuOqxaNZzlsZOVG1H09QdfrdrLr5k1evtu4R2av3er7a2nexxirWWcUGq9hkFXNWsUUq9mga9ufFCquYsYqxVv7KWvkra+WvrJW/slb+ylr5H84qr/IlNvoT1Kj296uHf3tttYvXtjr+fm3r8x+vPaUeTjWnSd2+nHepUR5IFUYpY5SqjFKNUaozSo2PSJV5So0nUj76vVL5GPb16r6+aU1OLefUWpRa/eDUKpxaBteax/1/ffvP9UCrcmo1Tq3OqTU4tSanlnNq4av87OvUGvNaaxycWoVTyzi1KqdW49TqnFo/UOXr/NLyf2hd/M2onX9isvbt84/bhyHf3sT8X3gT/r/wJh79ncDX+SaajSdv4vbq82OsVT/yMdaj7ZOfFyusYsYqVlnFGqtYZxUbrGKTVcxZxVgrv7NWfmet/M5a+Z218jtr5X+0L3X7kflLrJVnP1R+9u8HjzarflZqMko5o9QilHq0AfYvpf7Fb0/L6v1wL2vff73+9vvQo22xn9YyTq3KqdU4tTqn1sBr2fGl5f/QuhgvsXVWk1q+Xh3v5/+8ePZ7R56rffvI49vbnf+tt+v/rbe7/ktvtx3Hf+vtFvK3W88PaFtt/fvb/XoP9j/wHur/wHto7O9htvM9+HH9Hjr9e6hf72Fdvwf2Hz/+5D3gf6a4fYRxfw+3LnD5k107nFNrUWqV4we06qlV6gOtwqllP6Blp5bZA63KqdU4tfD9o7XzN9I21wOtwak1f0DLTy2fD7TwVb6X86vV26Ov1voBrfOr1b9/7vhdyw5OrfIDWvPUmg96ouGrfD//prKG+QOtyqnVfkDr/EccdTzQwlf5Mc+fsOejn7dscGrhq/wY60vr/35vzWP+df3FmmdlmfPbz2m378/zufnic/7ic+u1567Xwv/gufLic/bic5eVx8u5+mEPnmsvPtdffG68+Nx88Tl/8bn12nPXC6V+/uLiy66fKy8+Zy8+V198rr34XH/xufHic5ffL+vcdFjluH7OX3xuvfbc9ZraHzxXXnzOXnyuvvjc5ffL7eOt+3P1+hxd7zL9wXPjxefmi8/5i8+t1567Xnj5g+fKk+fa9b/f9crIHzxXX3zu+vul168fcq+f6y8+N158br74nL/43Hrtuetx9T947vr7xe8/p5aj+z8e/P/+zYtPikEoFUJpEEqHUAaEMiEUh1AWgnI9gvxxCuTsO+TsO+TsO+TsO+TsO+TsO+TsO+TsO+TsL8jZX5CzvyBnf0HO/oKc/fX+eennFm+fXx8T2vz6MG85AFKO97/F+vk3xO/Xv/6TYhBKhVAahNIhlH/bXr6enK8+aRXxfW0NQukQyoBQJoTygaq2+v2vJkd/QFkISj0glAKhGITygbN/XpwwjvGA0iCUDqEMCGVCKA6hLETnbAeEAvnprEF+OmuQn84a5KezBvnprA0IZUIoDqFAzn6HnP0OOfsdcvY75Ox3yNnvkLPfIWe/Q85+h5z9Djn7A3L2B+TsD8jZH5CzPyBnf0DO/oCc/QE5+wNy9gfk7E/I2Z+Qsz8hZ39Czv6EnP0JOfsTcvZn+tkv9a/rEenezgnp/u36Uru8yrLfGe7l9y8txe/5IhFg9/Xievo4mc8i83mw2viDQoVNyNiEKptQYxPqbEKDTYitThe2Ql3YKrWxVWpjq9TGVqmNrVIbW6U2tkptiZX6ZEwA4/16+m21pB7vf2EXmVA92IQKm5CxCVU2ocYm1NmEBpvQZBNiq9SVrVI3tkrd2Cp1Y6vUja1SN7ZK3dgqdWOr1C2xUp8MBzBWPqMfAEYBMAzAqABGAzA6gDEADMA5H+9/75bjuK9sl6PYJcUglPf/3Yu1r+o7Lj9AGAvxXuYBoUD+9Wf7AOW876kc326H+k7pEMqAUCaE4hDKJ87LKF+UeUXxA0IpEIpBKBVCaRBKh1AGhDIhFIdQPnD2y3mx2e2/Ln+GWQeEUiAUg1AqhNIglA6hDAhlQigfOPtl2kn5PvH2jbIQlHIcGExF/G7xYJ3+85iOwQwMZkEwH5gI/CNMwWAMgwGcm349XDvPx+Z88qFrO+6X2Dbrv3+pn7ViHf9IXHrho9x+PYWrIL5Uxa9PsYR5kTU3WfMqa95kzbus+ZA1l+2gRbaFFtkearI91GR7qMn2UJPtoSbbQ022h1paDz0JM53wdk86L0FvvV0SVjahHumEkk6wdMLbte1cHG5eLwktndDTCSOd8O6Z7sf9A6l++CXB0wkrm9COdEJJJ7z73drt/tJu14SRTnj3X3rU+9TF6HZF6Ec6If2r1N8+0+eHzL3PS4KnE1Y2YRzphJJOsHRCTSe0dEJPJ4x0wgfP9BiXBE8nvH+mz8o3Lwnz7TNd1xNCSSdYOuHdMz3OydVxrEtCSyf0dMJIJ8x0wttn+usy7nJcElY2wY90QkknWDqhphNaOqGnE0Y6YX6QcHmm3dMJ75/p+yTdsEvCevtMnx+HPiKUdIKlE97u089+F10tndDTCSOdMNMJnk5I/+TkwUDpxxD2YFqtjHrO7Y7+5E8upR334ldaKVeQB9OK/47S/KTMZ38F+txtQ/Zo1knG3qTtq7R9k7bv0vZD2n5K27u0/VK2N+lea9K91qR7rUn3WpPutSbda02615p0rzXpXmssvfYuVFna5ykE7ogfvB7MHk29ydhXafsmbd+l7Ye0/ZS2d2n7pWzfDml76V7bpHttk+61TbrXNule26R7bZPutU261zbpXttZeu0pxNI+TyGWjngKsTS5U4ilb51CLK3oFGLpLqcQS8M4hVh6wCnEUtbvQoOtUg/wsX92MbM92ij5WSXwN/azy8Xs0a7Ej36VpvEpVT6lgVb6/WXY9mhX4meVnE9p0Sn5wacEr0u/v+/ZHi2I/KxS5VNqfEqdT2nwKU0+JedTWnRK6+BTQlfvJ/eC26NVoJ9VqnxKjU+p8ykNPqXJp+R8SotO6dEd/4lOvw8E2E6F0MkInTrdBzqPcgl+1mkSOvF9GFfQm4F/5GSETpXQqRE6kdWnaqJpFjdxzau4b+KaN3HfxEXTLMJc8ybuMNe8iTvMNW/iDvMma655E3eYa6ZZhLlsBxVNswhz2R4qmmYR5rI9VDTNIsxle6homkWYy/bQ5DSLIMx0Qm6aRRBWNiE5zSIIJZ1g6YTcNIsgtHRCTyeMdEJumkUQPJ2wsgnJaRZBKOmE3DSLIIx0Qu6djDdCcppFENK/SslpFkHwdMLKJiSnWQShpBMsnVDTCS2d0NMJI52Qm2YRBE8n5KZZxJ+zctMsglDSCZZOyE2zCEJLJ/R0wkgnzHRCbppFEFY2ITnNIgglnWDphJpOaOmEnk4Y6YTcNIsgeDohN80ihiBy0yyCUNIJlk7ITbMIQksn9HTCSCfMdIKnE9I/OclOs2gFkGZxgwinWYS97g3bYa97w3bY696wHfZN2l73hu2w171hO+x1b9gOe90btsNeN83iZi+cZhH20r1WOM0i7KV7rXCaRdhL91rhNIuwl+61wmkWYU+VZnET4kqzCCHdG7bDXveG7bDXvWE77Ju0ve4N22Gve8N22OvesB32ujdsh73uDds3e+E0i7CX7rXCaRZhL91rhdMswl661wqnWYS9dK8VTrMIe+ley5VmEUJUaRYhRJVmEUJUaRYhxNK3TiGqNIsQokqzCCGqNIsQokqzCCGqNIubEFeaRQiBj/2z6/5DiSzNIpTILtCLcS2yNItQIkuzCCWyNItQIkuzCCWyNItQIkuzCCWyNIubEluaRSiRpVmEElmaRSiRpVmEUuNTIkuzCCWyNItQIkuzCCWyNItQIkuzuCmxpVmEElmaRSiRpVmEElmaRSg1PiWyNItQIkuzCCWyNItQIkuzCCWyNIu9ykSWZrGdyNIsthNZmsV2IrstfjuRpVlsJ7I0i+3E92EcXZrFdiJLs9hOZGkW26kROrHVJ0fsB7v0frBL7we79H6wS+8Hu/R+sEvvB7v0frBL7we79H6wS+8Hu/R+sEvvB7v0frBL7we79H6wS+8Hu/R+sEvvB7v0frCz7Qc7236wS+8Hu/R+sEvvB7v0frBL7we79H6wS+8Hu/R+sEvvB7v0frBL7we79H6wS+8Hu/R+sEvvB7v0frBL7we79H6wS+8HO9t+sLPtBzvbfrCz7Qc7236ws+0HO9t+sLPtBzvbfrCz7Qc7236w8+0HO99+sPPtBzvffrDz7Qc7336w8+0HO99+sPPtBzvffrDz7Qc7336w8+0HO99+sPPtBzvffrDz7Qc7336w8+0HO99+sPPtBzvffrDz7Qc7336w8+0HO99+sPPtBzvffrDz7Qc7336wE+4HO+F+sBPuBzvhfrAT7gc74X6wE+4HO+F+sBPuBzvhfrAT7gc7335wH3+9m+PcjrtOsyc2fhbwdbSvl9YX/jp+E3dV8aUqXg5Z8yJrbrLmVda8yZp3WfMhay7bQYtsCy2yPdRke6jJ9lCT7aEm20NNtoeabA+1tB56EmY64e2e1O+TOq23S8LKJtQjnVDSCZZOeLu2+f3wNK+XhJZO6OmEkU5490z3Y/790n74JcHTCSub0I50QkknvPvd2u3+0m7XhJFOePdfetT7qNvodkXoRzoh/avU3z7T7fxe6vOS4OmElU0YRzqhpBMsnVDTCS2d0NMJI53wwTM9xiXB0wnvn+mz8s1Lwnz7TJ/V+xGhpBMsnfDumR7nPsQ41iWhpRN6OmGkE2Y64e0zve6XP49yXBJWNsGPdEJJJ1g6oaYTWjqhpxNGOmF+kHB5pt3TCe+f6ftEy7BLwnr7TJ8fhz4ilHSCpRPe7tPPfhddLZ3Q0wkjnTDTCZ5OSP/k5MHo9McQYwDSLMZQTrMYQznNYgzlNIsxlNMsxlBOsxhDOc1iDOU0izGU0yzGUE6zGEM5zWIM5TSLMZTTLMZQTrMYQznNYgzlNIsxlNMsxlBOsxhDOc1iDOU0izHI0izGIEuzGEM5zWIM5TSLMZTTLMZQTrMYQznNYgzlNIsxlNMsxlBOsxhDOc1iDOU0izGU0yzCXrrXCqdZhL10rxVOsxhDOc0i7KV7rXCaxRjKaRZjkKVZhBBVmkUIUaVZhBBVmkUIsfStU4gqzWIMsjSLMcjSLMYgS7MYgyzNYgyyNIsx6NIsxqBLsxiDLs1iDLo0izHo0izGoEuzGIMuzWIMujSLMejSLMagS7MYgy7NYgy6NIsx6NIsxqBLsxiDLs1iDLo0izHo0izGoEuzGIMuzWIMujSLMejSLMagS7MYgy7NYgy6NIsx6NIsxqBLsxiDLs1iDLo0izHo0izGoEuzGIMvzWI7kaVZbCeyNIvtRHZb/HYiS7PYTmRpFtuJ78M4ujSL7USWZrGdyNIstlMjdCKrT7OKplncxDWv4r6Ja97EfRMXTbMIc82buMNc8ybuMNe8iTvMm6y55k3cYa6ZZhHmsh1UNM0izGV7qGiaRZjL9lDRNIswl+2homkWYS7bQ5PTLIIw0wm5aRZBWNmE5DSLIJR0gqUTctMsgtDSCT2dMNIJuWkWQfB0wsomJKdZBKGkE3LTLIIw0gm5dzLeCMlpFkFI/yolp1kEwdMJK5uQnGYRhJJOsHRCTSe0dEJPJ4x0Qm6aRRA8nZCbZhF/zspNswhCSSdYOiE3zSIILZ3Q0wkjnTDTCblpFkFY2YTkNIsglHSCpRNqOqGlE3o6YaQTctMsguDphNw0ixiCyE2zCEJJJ1g6ITfNIggtndDTCSOdMNMJnk5I/+QkO83CDZBmcYMIp1mEve4N22Gve8N22OvesB32Tdpe94btsNe9YTvsdW/YDnvdG7bDXjfN4mYvnGYR9tK9VjjNIuyle61wmkXYS/da4TSLsJfutcJpFmFPlWZxE+JKswgh3Ru2w173hu2w171hO+ybtL3uDdthr3vDdtjr3rAd9ro3bIe97g3bN3vhNIuwl+61wmkWYS/da4XTLMJeutcKp1mEvXSvFU6zCHvpXsuVZhFCVGkWIUSVZhFCVGkWIcTSt04hqjSLEKJKswghqjSLEKJKswghqjSLmxBXmkUIgY/9s+v+Q4kszSKUyC7Qi3EtsjSLUCJLswglsjSLUCJLswglsjSLUCJLswglsjSLmxJbmkUokaVZhBJZmkUokaVZhFLjUyJLswglsjSLUCJLswglsjSLUCJLs7gpsaVZhBJZmkUokaVZhBJZmkUoNT4lsjSLUCJLswglsjSLUCJLswglsjSLvcpElmaxncjSLLYTWZrFdiK7LX47kaVZbCeyNIvtxPdhHF2axXYiS7PYTmRpFtupETqx1aeF2A9e0vvBS3o/eEnvBy/p/eAlvR+8pPeDl/R+8JLeD17S+8FLej94Se8HL+n94CW9H7yk94OX9H7wkt4PXtL7wUt6P3hJ7wcvtv3gxbYfvKT3g5f0fvCS3g9e0vvBS3o/eEnvBy/p/eAlvR+8pPeDl/R+8JLeD17S+8FLej94Se8HL+n94CW9H7yk94OX9H7wkt4PXmz7wYttP3ix7Qcvtv3gxbYfvNj2gxfbfvBi2w9ebPvBi20/eLHtBy++/eDFtx+8+PaDF99+8OLbD158+8GLbz948e0HL7794MW3H7z49oMX337w4tsPXnz7wYtvP3jx7Qcvvv3gxbcfvPj2gxfffvDi2w9efPvBi28/ePHtBy++/eDFtx+8+PaDF99+8OLbD158+8GLcD94Ee4HL8L94EW4H7wI94MX4X7wItwPXoT7wYtwP3gR7gcvwv3gRbcf7Ed5sB/c27w/18f8PeRzA+Ph42Q+i8znwar1DwoVNiFjE6psQo1NqLMJDTYhtjpd2Ap1YavUxlapja1SG1ulNrZKbWyV2tgqtSVW6pMxAYz36+nnpk+30CITqgebUGETMjahyibU2IQ6m9BgE5psQmyVurJV6sZWqRtbpW5slbqxVerGVqkbW6VubJW6JVbqk+EAxspn9APAKACGARgVwGgARgcwBoABOOfj/e/dJ0P7m2IQyvv/7n/wh7yxEO9lHhAK5F9/tg9Qfjs5vykdQhkQyoRQHEL5xHn57eTt/nP2AaEUCMUglAqhNAilQygDQpkQikMoHzj7vx8l3aMjB4RSIBSDUCqE0iCUDqEMCGVCKB84+78fEt6UhaA8GiP/OKYifrcoR8NgOgYzMJgFwXxgIvCPMAWDMQwGcG7q9XDtPB+b88mHru24z/o2ezLq62etWEf7f98+nX3ho9x6PYWrIL5Uxa9PsYR5kTU3WfMqa95kzbus+ZA1l+2gRbaFFtkearI91GR7qMn2UJPtoSbbQ022h1paDz0JM53wdk/q97+ptt4uCSubUI90QkknWDrh7drm98PTvF4SWjqhpxNGOuHdM92P+wdS/fBLgqcTVjahHemEkk5497u12/2l3a4JI53w7r/0qPepi9HtitCPdEL6V6m/fabPD5l7n5cETyesbMI40gklnWDphJpOaOmEnk4Y6YQPnukxLgmeTnj/TJ+Vb14S5ttn+qzejwglnWDphHfP9DgnV8exLgktndDTCSOdMNMJb5/p1e+EclwSVjbBj3RCSSdYOqGmE1o6oacTRjphfpBweabd0wnvn+n7JN2wS8J6+0yfH4c+IpR0gqUT3u7Tz34XXS2d0NMJI50w0wmeTkj/5OTBQOnHEOXBtNq/vJzyuBe/0kq5ghTw9cofvG2oPJp1krE3afsqbd+k7bu0/ZC2n9L2Lm2/lO1NuteadK816V5r0r3WpHutSfdak+61Jt1rTbrXGkuvvQtVlvZ5CoE74gevByuPpt5k7Ku0fZO279L2Q9p+Stu7tP1Stm+HtL10r23SvbZJ99om3WubdK9t0r22SffaJt1rm3Sv7Sy99hRiaZ+nEEtHPIVYmtwpxNK3TiGWVnQKsXSXU4ilYZxCLD3gFGIp63ehwVapB/jYP7uYuTzaKPlZJa506j2uVei+StP4lCqfEjoR/sll2OXRrsTPKjmf0qJT8oNPCV6Xfn/fc3m0IPKzSpVPqfEpdT6lwac0+ZScT2nRKa2DTwldvZ/cC14erQL9rFLlU2p8Sp1PafApTT4l51NadEqP7vhPdPp9IMB2KoRORujU6T7QeZRL8LNOk9CJ78O4gt4M/CMnI3SqhE6N0ImsPtkhmmZxE9e8ivsmrnkT901cNM0izP//6s5ox40iCqJ/FE333Nt35mN4CIiHSCggCEg88O9MNbE3SLNasLdGVY+IWOcoZNzE6+rjeRM3zD1v4oa5503cMA9bc8+buGHuWbOAue0JalqzgLntGWpas4C57RlqWrOAue0ZalqzgLntGUquWYBQdAK3ZgHCziaQaxYgNDqh0wncmgUIQScknTDoBG7NAoSNTtjZBHLNAoRGJ3BrFiAMOoF7J+NBINcsQKD/LpFrFiBsdMLOJpBrFiA0OqHTCSudEHRC0gmDTuDWLEDY6ARuzQI/zuLWLEBodEKnE7g1CxCCTkg6YdAJRSdwaxYg7GwCuWYBQqMTOp2w0glBJySdMOgEbs0ChI1O4NYs8CUIbs0ChEYndDqBW7MAIeiEpBMGnVB0wkYn0D85Ydcs+n5BzeKAGNcsYO97wzbsfW/Yhr3vDduwD2t73xu2Ye97wzbsfW/Yhr3vDduw961ZHPbGNQvYW5+1xjUL2FuftcY1C9hbn7XGNQvYW5+1xjUL2EvVLA4hrZoFhHxv2Ia97w3bsPe9YRv2YW3ve8M27H1v2Ia97w3bsPe9YRv2vjdsH/bGNQvYW5+1xjUL2FuftcY1C9hbn7XGNQvYW5+1xjUL2FuftVo1CwhJ1SwgJFWzgJBUzQJCKufWXUiqZgEhqZoFhKRqFhCSqllASKpmcQhp1SwgdPFj/9Z1/1ASq1lASewCPXxdS6xmASWxmgWUxGoWUBKrWUBJrGYBJbGaBZTEahaHklrNAkpiNQsoidUsoCRWs4BS6CmJ1SygJFazgJJYzQJKYjULKInVLA4ltZoFlMRqFlASq1lASaxmAaXQUxKrWUBJrGYBJbGaBZTEahZQEqtZzCmTWM1iOonVLKaTWM1iOqndFr/r1Symk1jNYjrpfRgnV7OYTmI1i+kkVrOYTiHoJPb+tI4L9sEHxHgfDHvfzRLsfTdLsPfdLME+rO19N0uw990swd53swR7380S7H33wYe98T4Y9tZnrfE+GPbWZ63xPhj21met8T4Y9tZnrfE+GPZS++BDSGsfDCHfzRLsfTdLsPfdLME+rO19N0uw990swd53swR7380S7H03S4e98T4Y9tZnrfE+GPbWZ63xPhj21met8T4Y9tZnrfE+GPbWZ63WPhhCUvtgCEntgyEktQ+GkMq5dReS2gdDSGofDCGpfTCEpPbBEJLaBx9CWvtgCF382L81oISS2D4YSmJfScTXtcT2wVAS2wdDSWwfDCWxfTCUxPbBUBLbB0NJbB98KKntg6Ektg+Gktg+GEpi+2AohZ6S2D4YSmL7YCiJ7YOhJLYPhpLYPvhQUtsHQ0lsHwwlsX0wlMT2wVAKPSWxfTCUxPbBUBLbB0NJbB8MJbF98Jwyie2Dp5PYPng6ie2Dp5Pe/k5uHzydxPbB00nvwzi5ffB0EtsHTyexffB0CkEnsfeniA/PdpxjuelEf8Nmu7+B70u8/NL1gZ+OH+Kbq/juKt4WW/Nma95tzVdb87A1T1vzYWtue4I22yO02Z6h3fYM7bZnaLc9Q7vtGdptz9Bue4Z22hl6JxSd8PSZlLdv6kTGKWFnE9aFTmh0QqcTnn5v224PT2zrKSHohKQTBp3w7DOdS339pblsp4SNTtjZhFjohEYnPPunNfvtl2Y/Jww64dn/0mO9fdVtZD8j5EIn0H+X8ulnOu5/lrJOCRudsLMJY6ETGp3Q6YSVTgg6IemEQSe84zM9xilhoxOef6bv73x1Sqinn+n7u/drhEYndDrh2Wd63PcQY9lPCUEnJJ0w6ISiE55+pvfb5c+jLaeEnU3YFjqh0QmdTljphKATkk4YdEK9I+H0md42OuH5Z/r2jZbRTwn708/0/ePQ1wiNTuh0wtPn9Ft/F92DTkg6YdAJRSdsdAL9k5NXvjr9boiMC2oWGc41iwznmkWGc80iw7lmkeFcs8hwrllkONcsMpxrFhnONYsM55pFhnPNIsO5ZpHhXLPIcK5ZZDjXLDKcaxYZzjWLDOeaRYZzzSJDrGaRIVazyHCuWWQ41ywynGsWGc41iwznmkWGc80iw7lmkeFcs8hwrllkONcsMpxrFrC3PmuNaxawtz5rjWsWGc41C9hbn7XGNYsM55pFhljNAkJSNQsISdUsICRVs4CQyrl1F5KqWWSI1SwyxGoWGWI1iwyxmkWGWM0iQ65mkSFXs8iQq1lkyNUsMuRqFhlyNYsMuZpFhlzNIkOuZpEhV7PIkKtZZMjVLDLkahYZcjWLDLmaRYZczSJDrmaRIVezyJCrWWTI1Swy5GoWGXI1iwy5mkWGXM0iQ65mkSFXs8iQq1lkyNUsMuRqFhlyNYsMvZrFdBKrWUwnsZrFdBK7LX46idUsppNYzWI66X0YJ1ezmE5iNYvpJFazmE4h6CT2/jSaac3iEPe8ivsQ97yJ+xA3rVnA3PMmbph73sQNc8+buGEetuaeN3HD3LNmAXPbE9S0ZgFz2zPUtGYBc9sz1LRmAXPbM9S0ZgFz2zOUXLMAoegEbs0ChJ1NINcsQGh0QqcTuDULEIJOSDph0AncmgUIG52wswnkmgUIjU7g1ixAGHQC907Gg0CuWYBA/10i1yxA2OiEnU0g1yxAaHRCpxNWOiHohKQTBp3ArVmAsNEJ3JoFfpzFrVmA0OiETidwaxYgBJ2QdMKgE4pO4NYsQNjZBHLNAoRGJ3Q6YaUTgk5IOmHQCdyaBQgbncCtWeBLENyaBQiNTuh0ArdmAULQCUknDDqh6ISNTqB/csKuWdRyQc3igBjXLGDve8M27H1v2Ia97w3bsA9re98btmHve8M27H1v2Ia97w3bsPetWRz2xjUL2FuftcY1C9hbn7XGNQvYW5+1xjUL2FuftcY1C9hL1SwOIa2aBYR8b9iGve8N27D3vWEb9mFt73vDNux9b9iGve8N27D3vWEb9r43bB/2xjUL2FuftcY1C9hbn7XGNQvYW5+1xjUL2FuftcY1C9hbn7VaNQsISdUsICRVs4CQVM0CQirn1l1IqmYBIamaBYSkahYQkqpZQEiqZnEIadUsIHTxY//Wdf9QEqtZQEnsAj18XUusZgElsZoFlMRqFlASq1lASaxmASWxmgWUxGoWh5JazQJKYjULKInVLKAkVrOAUugpidUsoCRWs4CSWM0CSmI1CyiJ1SwOJbWaBZTEahZQEqtZQEmsZgGl0FMSq1lASaxmASWxmgWUxGoWUBKrWcwpk1jNYjqJ1Symk1jNYjqJ3RY/ncRqFtNJrGYxnfQ+jJOrWUwnsZrFdBKrWUynEHRSe3+qK/bBZb0PLut9cFnvg8t6H1zW++Cy3geX9T64rPfBZb0PLut9cFnvg8t6H1zW++Cy3geX9T64rPfBZb0PLut9cFnvg0ttH1xq++Cy3geX9T64rPfBZb0PLut9cFnvg8t6H1zW++Cy3geX9T64rPfBZb0PLut9cFnvg8t6H1zW++Cy3geX9T64rPfBpbYPLrV9cKntg0ttH1xq++BS2weX2j641PbBpbYPLrV9cKntg0tvH1x6++DS2weX3j649PbBpbcPLr19cOntg0tvH1x6++DS2weX3j649PbBpbcPLr19cOntg0tvH1x6++DS2weX3j649PbBpbcPLr19cOntg0tvH1x6++DS2weX3j649PbBpbcPLsF9cAnug0twH1yC++AS3AeX4D64BPfBJbgPLsF9cAnug0twH1xq++BYt+2VMdR6/0Ao+ssx2dZxf935DOk/vK49+Lr+4OvW//+6XPork+bI2xQ6v1lCt76/vK49+Lr+4OvWB18XD74uH3zdePB1p0dVtrq9Lrd/ve7s78dVZ59utm15oWyXUPYrKOdP5rtT2iWUfgllvYQSz1O2+3v/stc5JS+hjEsodQllu4SyX0FZl0so7/Ds7/efOB3Ec0q/hLJeQolLKHkJZVxCqUso27tS2vk7/7pfQYnlEsrzz35bXyhx/t8l+iWU9RJKXELJSyjjEkrRKXv/cPob1sftL8y99m/+Yji/lZ1jGx/y/Kega92+IRTxzanZ4+sLX7+o6f4/jnt+87r667vjn/74+Ounj9//9ONvxyvwL3///MOXTz9//vqPX/785Z9/c/zavwE="},{"name":"set_value_twice_with_nested_first","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"pub_set_value","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"new_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/12OvQ7DIAyEDwgpJJC5S5cWpI5duvb91acq/iE0sWQ42Z/tK3BAmNDiBg2qYMPcPkP5QVdN2JZmg+mlSk2aslUxOFYETvf2rBUyF9ybGo42FHgcgyY9X+WWL3BaDbUzM5vj4JuDuZT/jhOWoVjZCamBR2GCSISn0QlzOj3ksruIw8VydLEOF0mgKBJ5d5EHnoVJIpFeak1vEZ2qLoN9kLx+KX/B3JzetgEAAA==","debug_symbols":"5ZhLasMwEEDvorUp+s2M7KuUUpTEKQYjh9gpFJO712qjJBCTbAdm55Ee9nsbIzSrXbs5fX12aT+MqnmfVT9s49QNaZlmpd+M+VsdDzHlhXGKx0k1hoAq1aZdfqzhXKl917eqcY7O1SPtDBbaYbjSxuMKDWj0hQbE27vzZx5hT1cY9As4oA0XOCDpe/ijyq1OUKsX1AqCWlFQKwlqDYJaazmtVgtqFXSWsFZQ6/q5KWgo9sH7F60IBSbjnusQki8smRUdz0sHeOkgLx3ipRN46dSsdJzmpWN46VheOnz+ysvwHY9d3PRtvlbIe6e0LbcMyzj9HP53FvYX"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3RbiS3mYbhe5ljY1Fk/VXFyq0sFgsncRYGDDuInQUWRu595UTdkjMUWkN+8zVbfM/spHvEflyq/l9q1Pz105+/++Pf/+e/v//xLz/9/OkP//nrpx9++tO3v3z/049P//brp+U/cvnn//rzX7/98bf/4edfvv3bL5/+sC3HN5+++/HPT/9U0j+++fSX73/47tMf1vX4x39989uTzoYnrbn2pLLm5yeVpwd+/qS15UnR8qSt5Ul7y5OOlieVliedDU+KpeVJqeVJLVdEtFwR0XJFRMsVES1XRLRcEdFyRUTLFbG1XBFbyxWxtVwRW8sVsbVcEVvLFbG1XBFbyxWxtVwRW8sVsbdcEXvLFbG3XBF7yxWxt1wRe8sVsbdcEXvLFbG3XBF7yxVxtFwRR8sVcbRcEUfLFXG0XBFHyxVxtFwRR8sVcbRcEUfLFVFarojSckWUliuitFwRpeWKKC1XRGm5IkrLFVFarojSckWcLVfE2XJFnC1XxNlyRZwtV8TZckWcLVfE2XJFnC1XxNlyRaRlaXpWanpWbnrW2vSsaHrW1vSsvelZR9OzStOzmq6N1HRtpKZrIzVdG6np2khN10ZqujZS07WRmq6N1HRtpKZrIzddG7np2shN10ZuujZy07WRm66N3HRt5KZrIzddG7np2libro216dpo2tRMTbuaqWlbMzXta6amjc3UtLOZmrY2U9PeZmra3ExNu5upaXszNe1vpqYNztS0w5matjhT0x5natrkTE27nKlpmzM17XOmpo3O1LTTmZq2OlPTXmdq2uxM9YDfl/T8rOPYfvesbz57bKypPD841n25PvppsKs8+owznh99btt6fXSO5bKidbgVxXAr2oZb0T7cio7hVlSGW9E52orqG1V3XVEabkXD3bPP4e7Z53D37HO4e/Y53D37HO6efQ53zz5Hu2fnZbR7dl5Gu2fnZbR7dl5Gu2fnZbR7dl5Gu2fnZbR7dl5Gu2fnZbR7dl6Gu2cn83f/tp3PD96Ol7+hmp++yvN6YrD1mK/qrVz2abZSauspg63nHGs9eRlsPWmw9eTB1rMOtp7++08+X60n3VjP0w+9nh/8tGX+6k++3J/zNth69sHWcwy2njLYes6x1rMug60nmddzXO4/T1uctfXkwdazDraeGGw922Dr2QdbzzHYesz356fAen7w062mtp5zrPXEMth60mDryYOtZx1sPTHYer7q/fn5a+yGr3EYvkYxfI3z63+NbTF8jWT4GtnwNVbD1wjD1zB8n2+G7/PN8H2+Gb7PN8P3+W74Pt8N3+e74ft8N3yf74bv893wfb4Lfra2H9evcW43ZpjbP6XZj+FWVIZb0Tnaio5luBWl4VaUh1tR/50y8uVrRLz6GvUVHdefQB7nrdo5LneuvPx+c6PphcYsL3Sb5YXus7zQY5YXWmZ5oeckL7Qss7zQNMsLzbO80FkmI8Evej3IC51lMiqzTEZllsmozDIZlVkmo3OWyeicZTI6Z5mMTvdkdN3CLvtx47HbdRX70r87Jvh9ykd5pds0r3Sf5pUe07zSMs0rPSd5peuyTPNK0zSvNE/zSmeZkdYlpnmls8xI6zLLjLQus8xI6zLLjLQKfu88rr84GdsRN1aUYr/8tewUx+9d/rWitAy3otW8ou28/qrKHrd+bzWdy8svtmzld/+NW64Iwe/ZP9Kr3aZ6tftUr/aY6tWWqV7tOdOrzctUrzZN9WrzVK92qllK8Jkhj/Rqp5ql8lSzVJ5qlspTzVKCT/LYl0tDx37c2pXIy3b91ez06jTi5vXHg69/e/D17w++/uPB118efP3nY69f8Mko911/evD15wdf/4O//wo+2eW+63/w99948PffePD333jw91/Bp7Ac235Zf0k3+2XLlz86bfutv2Ob4/pBjTluforrvf6i7yr4mBkQBZ+jA6Lgg4JAFHwSEoiCj3oCUfBZViAKPqwLRMGnkYEo+Lg1EAWfJwfiTrEIECkWASLFIkCkWASIFEs/4kGxCBApFgEixSJApFgEiPGBEO/222rHR0qW+yl+pGa5n+JHipb7KX6karmf4kfKlrsplo/ULfdT/Ejhcj/Fj1Qu91P8SOlyP8VAUaBIuygUaReFIu2iUKRdFIq0i0DxHLpd1uW4PHpNr35j9Y0/++YnMp1DN4b81cYHerV3/U3nc+gZ7KEkh57DHkpy6FnsoSSHnsceSnLomeyBJGP5SHPZfSU/0sx3X8mh95YfSnLo/eWHkgwkRZI0jkqSxlFJ0jgqSRpHJUnjiCQFnxj/NSXTftmUX/Nq/myVSGO/G9/XZuz31/vajP2OeV+bsd8D72sz9rvaXW3y2Htx97UZe3ftvjZj75fd12bsHbD72gQ2b9owF79tw1z8tg1z8ds2zMVv2zAXv2mz2uebcv0bb3tKN2yekub62bg5Xnar9q3y4H2/7Gwd6XxZRj5rf/C2PT92e7WI3x77zLLCUmMJWGosGyw1lh2WGssBS42lwFJjOWGpsMQyJcuWjgvL6x8MVh+b0nr5wJuUXi0ilcvwFwnEfsQ5J2gx4pzzthgxQOxHnHOWFyPOOfmLEd2dsK+X5afj1S8jvvGxd/v1xZ77vt3YiFqP60LSyy/H1vfD9uvfZ1qPV4uuPnhfL4/d1/X1Q58JC4S9hCeEnYTbAmEvYYKwlzBD2Eu4QthLGBD2Em4Q9hLuEPYSUifdhNRJNyF1cptwv/y5e4nPCXfqpJuQOukmpE66CamTbsKAsJeQOukmpE66CamTbkLqpJuQOuklPKiTbkLqpJuQOukmpE66CQPCXkLqpJuQOukmpE66CamTbkLqpJewUCfdhNRJNyF10k1InXQTBoS9hNRJNyF10k1InXQTUifdhNRJL+FJnXQTUifdhNRJNyF10k0YEPYSUifdhNRJNyF10k1InXQTUiedhNtCnXQTUifdhNRJNyF10k0YEPYSUifdhNRJNyF10k1InXQTUie9hIk66SakTroJqZN/I3x2ITnqLoFL1YU4qLsw8dddGOPrLszmdRcG7qpLZoquuzAa112Yd+suzLt1l8Cl6sK8W3dh3q27MO/WXZh36y7Mu1WXlXm37sK8W3dh3q27MO/WXQKXqgvzbt1l0vnlWF9cYq24TDq/3HKJOd+PIl//4Mi/P2bgix78jDjnm5cYcc53OjHinG+LYsQ594zEiHNuMIkR55zmxIhzjn5axElPNBUjzrkpJkakWASIFIsAMUDsR6RYBIgUiwCRYhEgUiwCRIqlH3HSU07FiBSLAJFiESBSLALEALEfkWIRIFIsAkSKRYBIsdxEzLlc/hpJXpdcQaRY+hEnPfn0CxH39IJY+Xae9NTJL0PccrkgbvmsIAaI/YjMiQJE5kQBInOiAJE5UYDInNiPOOkZlGJEdrYFiOxsCxApFgFigNiPSLEIECkWASLDtgCRYbsfcdIjFcWIjDi3Ectx/fFAOW88eI3lsoo1aj/VmvT0u3uKMzy5xZm03OJsJLvFGYTd4kzNXvF90nMB7ynO5rdbnJ1ytzjN6RYPxM3iNKdbnOY0i096LtvXEy9pe35sSWfFm9nQ682eitb7vP41+7PsFW92VKzek5588/W803K1S0uKijit6RanNd3igbhZnNZ0i9OabnFmcbc407hbnJ9vmsUnPSPqnuI0p1uc5nSL05xq8T0uLzClyk8iJj2L657iNKdbnOZ0i9OcbnGa0y1Oc5rFg+Z0i9OcbnGa0y1Oc7rFA3GzOM3pFqc53eI0p1uc5nSL05xmcc4ItYvTnG5xmtMtTnO6xQNxrXhOV/Gctoo4zekWpznd4jSnW5zmdIvTnGZxTnm1i9OcbnGa0y1Oc7rFA3GzOM3pFqc53eI0p1uc5nSL05xmcc7ptYvTnG5xmtMtTnO6xQNxszjN6RanOd3iNKdbnOZ0i9OcZnEOCZaLx4t4lIp4IG4W551TLb6vV/EjV8R553SL885pFucAX7s4u7VucXZr3eLM427xQNwszm6tW5zdWrc4zekWpznd4jSnV/zgRGu7OM3pFqc53eI0p1s8EDeL05xucZqzR/wZkYwUIFKGAkRirx+RM+cViCSZAJHKEiASTgLEALEfkbwRIFIsAkSKRYBIsQgQKZZ+xEyxCBApFgEiI85txHO7PDg/raiCyIgjQOSN5R2IZbki1r6dObxegcgbiwCRrTABIlthAsQAsR+ROVGAyJwoQGQrTIDIVpgAkWLpR+To89uIx+WTGI6tAkitdAJSKp2AVEonYADYB0iddAJSJp2AVEknIEXSCUiN9AFyIHYvICXSCUiJdAIGgH2ADNKdgAzSnYAM0p2ADNKdgAzSNwHXl0/AXnM+PkfkpF8FIgO1AJGhWoDIFr8AMUDsR6RQBIiMOO9AjPOKuFX+5gIHSyoQeWO5jbguV8Q17xVE3lgEiLyxCBDZ/hIgsgUmQGQbTIDInNiPWJgTBYhshQkQ2QoTIFIsAsQAsR+RYnkH4vUPXtezhkixCBApFgEixSJApFj6ETmE8x2IsVwRY63sbHOupgKRYhEgUiwCxACxH5FiESBSLAJEikWASLEIECmWbsTCEY4KRIpFgEixCBApFgFigNiPSLEIECkWASLFIkCkWASIFEs/IocWKhApFgEixSJApFgEiAFiPyLFIkCkWASIFIsAkWIRIFIs/YgcWqhApFgEiBSLAJFiESAGiP2IFIsAkWIRIFIsAkSKRYBIsfQjchquApFiESBSLAJEikWAGCD2I1Is/Yg7w3b35yeWnWH7HYhHuiKey+eIByOOAJERR4DIiCNADBD7ERlxBIhsygoQmRMFiMyJAkQ2ZfsR+ThUBSLFIkCkWASIFMs7PnAtLxfEp22cCmKA2I9IsQgQKRYBIsUiQKRYBIgUSz8iH4eqQKRYBIgUiwCRYnkP4svZA5EriAFiPyLFIkCkWASIFIsAkWIRIFIs3ScDnXwcqgKRYhEgUiwCRIpFgBgg9iNSLAJEikWASLEIECkWASLF0o/Ix6EqECkWASLFIkCkWASIAWI/IsUiQKRYBIgUiwCRYhEgUiz9iHwcqgKRYhEgUiwCRIpFgBgg9iNSLAJEikWASLEIECkWASLF0o/Ix6EqECkWASLFIkCkWASIAWI/IsUiQKRYBIgUiwCRYhEgUiz9iMGwLUBk2BYgMmwLEAPEfkSGbQEiI85NxHxulwfnpxVVEBlx+hE3NmUFiMyJAkTmRAEic6IAMUDsR2ROFCCyKStAZFNWgEixCBApln7EnWJ5B+J5+YPXJZUKIsUiQKRYBIgUiwAxQOxHpFgEiBTLOxDLch1xzrWCSLEIECkWASLF0o94UCwCRIpFgEixCBApFgFigNiPSLEIECkWASLFIkCkWASIFEs/IodkKxApFgEixSJApFgEiAFiPyLFIkCkWASIFIsAkWIRIFIs/Ygckq1ApFgEiBSLAJFiESAGiP2IFIsAkWIRIFIsAkSKRYBIsXQjpoVTsiWKNItCkWhRKFItCsVAUaBItygUCReFIuWiUCRdFIq0i0CR87IlirSLQjFQvKlYjnxRLOeNB6cccXmBOUqNnOHSTs4kaidnbLWTM+PayRmI3eSc3ewnZ9S2k/MzBTs5P4CwkwfkYvJju5KXKjn1aSenPu3k1KednPq0k1OfbnLO4ZaT7+uV/Mg1curTTk592smpTzt5QO4mpz7t5NSnnZz6tJNTn3Zy6tNNHtSnnZz6tJNTn3Zy6tNOHpC7yalPOzn1aSenPu3k1KednPp0k2/Up52c+rSTU592curTTh6Qu8mpTzs59Wknpz7t5NSnnZz6dJPv1KednPq0k1OfdnLq004ekLvJqU87OfVpJ6c+7eTUp5v8YC7Xkp/l8tiz7DVwpnIzODO5GTwA94Izj5vBmcbN4MziZnAmcTM4PwXyghd+BmQGpzTN4JSmGZzSNIMH4F5wStMMTmmawSlNMzilKf6Zz3K1++1Mpho5rekmP6lNOzm9aSenOO3kNKedPCB3k9OddnLK005Oe9rJqU87OfWpJk/lSr6mz8mf/ptA7ianPu3k1KednPq0kwfkbnLq8ysOiXVy6tM8l6eF+rSTU592curTTZ6oTzs59Wknpz7t5NSnnTwgd5NTn3Zy6tNOTn3ayalPOzn16SbP1KednPq0k1OfdnLq004ekLvJqU87OfVpJ6c+7eTUp52c+nSTr9SnnZz6tJNTn3Zy6tNOHpC7yalPOzn1aSenPu3k1KednPp0kwf1aSenPu3k1KednPq0kwfkbnLq005OfdrJqU87OfVpJ6c+3eQb9Wknpz7t5AG5lLyk7fmxJZ01cKZyMfj19ZXtqIEzk5vBmci94DuTihmcOcUMzh65GZwdcjN4AO4FZw43gzOHm8GZw83g7IubwdkV94IflKYZnNI0g1OaYvDrIkqp7YcflKYZPAD3glOaZnBK0wxOaZrBKU0zOKXpBS+Uphmc0jSDU5pmcErTDB6Ae8EpTTM4pWkGpzTN4JSmGZzS9IKflKYZnNI0g1OaZnBK0wwegHvBKU0zOKVpBqc0zeCUphmc0rSC54XSNINTmmZwStMMTmmawQNwLzilaQanNM3glKYZnNI0g1OaXvBEaZrBKU0zOKVpBqc0zeCEjxmc8DGDEz5mcMLHDE74eMHznGPh00Mvr3A9jlSDmXN8ewfMnO/6a1niAlN+W+jnMHO+O78DZs530XfAzPludxtmnXM77h0wc26bvQNm0jnmNsykc8xtmACmDjPnPto7YJh834Bh8n0Dhsn3DRgm3zrMpEe4vwOGyfcNGCbfN2CYfN+ACWDqMEy+b8Aw+b4Bw+T7BgyT7xswTL51mEmPj16Pc3mBufHT3JT39bLmfFQVJx2TxYqz/lRcqzjrj9C1ioGiQHHS0V6sOGkHiBUnjQax4qSFIVacNEe0ipMeKK9WpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXQSKkx5RrlakXRSKtItCkXZRKAaKAkXaRaFIuygUaReFIu1yW3E9y2XNkWu/RT/p+dhixUkPvf5CxSNeFGvf0ZOe8/tlintcPnTl6R/XmmKgKFBkXlQoMi8qFJkX36FYXtb86hW+UmReVCgyLwoUJz26Vq3IXvc7FF86+ki1dpn0CM4vUyz75Q9Opew1Rd6jbyrmdOXIKUVNkfdohSLv0f2K66SH/qkVeY9WKPLzaIUi+4sKxUBRoMj+okKR/UWFIu2iUKRdFIq0i0Bx0mPk1Iq0i0KRdlEo0i4KxUBRoEi7KBRpF4Ui7aJQpF0UirSLQDHTLgpF2kWhSLsoFGkXhWKgKFCkXRSKtItCkXZ5h+IWV8VtqynSLgpF2kWgOOt5oWJF2kWhSLsoFGkXhWKgKFCkXRSKtItCkXZRKNIuCkXaRaA464mvYkXmxf7fSV1nPRlUrMi8qFBkXnzH70dfV5FK1Pa6Zz2gVKzIvKhQZF4UKHJOqkSRvW6FInvdCkXaRaEYKAoUaReFIu2iUKRdFIq0i0KRdhEock6qRJF2USjSLgpF2kWhGCgKFGkXhSLtolCkXRSKtItCkXYRKHJOqkSRdlEo0i4KRdpFoRgoChRpl/7TIFbOSZUo0i4KRdpFoUi7CBQ5J1WiSLsoFGkXhSLtolAMFAWKtItCkXZRKNIuCkXaRaFIuwgUObNXoki7KBQDxZuK2/V39dN2bDf+5Fguq1hjXWvkDJd2ciZROzljq52cGddOzkBsJg9O0/aTM2rbyfmZgp2cH0DYyQNyNzn1aSenPu3k1KebnDOOxeQlbc+PLemsgTMimsHZX9GCnyVfVlz74URwDKYZnFMKxeBpudqlpXZ0V3CkoZ88IHeTU512cqrTTk512smZye3kTOVuck6D9JOznWUnpz7t5NSnnTwgF5Pv1wenVPvRBMdd+smpTzs59Wknpz7t5NSnm5zzPP3k1KednPq0k1OfdvKA3E1OfdrJqU87OfVpJ6c+7eTUp5uc04H95NSnnZz6tJNTn3bygNxNTn2KyXO6PjinrUZOfdrJqU87OfVpJ6c+3eSc7+wnpz7t5NSnnZz6tJMH5G5y6tNOTn3ayalPOzn1aSenPt3knNDtJ6c+7eTUp52c+rSTB+RucurTTk592smpTzs59Wknpz7d5Jyx7icPyMXk8UIepUbOkGgn5+1TTb6vV/Ij18h5+3STc8yvn5zNWzs5m7d2cjZv7eQBuZucudxOzuatnZzNWzs59Wknpz7N5BvHZPvJqU87OfXZQ35RJCjfoVjOy5r3pXotBooCRbJPoUjJKRSJM4UivaVQJKEEiokqUigSOgpF2kWhSLsoFANFgSLtolCkXRSKtItCkXZRKNIuAsVMuygUaReFIu2iUKRdFIqBokCRdlEo0i4KRdpFoUi7KBRpF4HiSrsoFGkXhSLtolCkXW4r7pGvirHWFANFgSLtolCkXRSKtItCkXZRKNIuAsWgXRSKtItCkXZRKNIuCsVAUaBIuygUmbpvKuZ0/T3Ap3+s/R5gMHUrFJm6BYobU7dCkalbocjUrVBk6lYoBooCRaZuhSI/MVAo0i4KRdpFoUi7CBQ5NF6iSLsoFGkXhSLtolAMFAWKtItCkXZRKNIuCkXaRaFIuwgUOXJcosjU/W+KFxgG6TdgApg6DOPuGzBMsG/AMAiYT3TcOCrWT872qJ2cqc5OzrxoJw/I3eTMuHZypmc7OZvFdnJ2lu3k1Kea/Niu5KVGzknrfnLq005OfdrJqU87eUDuJqc+3eeWctK6n5z6tJNTn3Zy6tNMvnPSup+c+rSTU592curTTh6Qu8mpTzs59Wknpz7t5NSnnZz6dJNzor2fnPq0k1OfdnLq004ekLvJqU87OfVpJ6c+7eTUp52c+nSTZ+rTTk592smpTzs59WknD8jd5NSnnZz6tJNTn3Zy6tNOTn26yVfq005OfdrJqU87OfVpJ2cu15Kf5XJm6ln2GjhTuRmcmdwMzkTuBQ/mcTM407gZnFncDM4kbgYPwL3g/AzIDE5pmsEpTTM4pWkGpzS94BulaQanNM3glKYZnNIU/8xnudqlJUWNPCB3k1ObdnJ6005OcdrJaU47OdXpJt/pTjs55Wknpz3t5NSnnTwgF5OnciVfU42c+rSTU592curTTk592smpTzf5QX1+xSGxTk59uufyg/q0k1OfdvKA3E1OfdrJqU87OfVpJ6c+7eTUp5u8UJ92curTTk592smpTzt5QO4mpz7t5NSnnZz6tJNTn3Zy6tNNflKfdnLq005OfdrJqU87eUDuJqc+7eTUp52c+rSTU592curTTH4s1KednPq0k1OfdnLq004ekLvJqU87OfVpJ6c+7eTUp52c+nSTJ+rTTk592smpTzs59WknD8jd5NSnnZz6tJMzl2vJS9qeH1vSWQHPTOVi8OvrK9tRA2cmN4MzkZvBmVTM4MwpZnD2yM3g7JCbwZnDveArc7gZnDncDM4cbgZnX9wMHoB7wSlNMzilaQanNMXg10WUUtsPXylNMzil6QUPStMMTmmawSlNMzilaQYPwL3glKYZnNI0g1OaZnBK0wxOaXrBN0rTDE5pmsEpTTM4pWkGD8C94JSmGZzSNINTmmZwStMMTml6wXdK0wxOaZrBKU0zOKVpBg/AveCUphmc0jSDU5pmcErTDE5pesEPStMMTmmawSlNMzilaQYPwL3glKYZnNI0g1OaZnBK0wteCB8zOOFjBid8zOCEjxk8APeC94+FayqX17nut8C37Xx+8HakF8Cnr3JZUBltQedgCzqX0RaURltQNi/ovPzJ+7JXF7SOtqAYbUHbaAvaR1vQMdqC3Hfqki/f9qVUF3SOtaCyLKMtKI22oDzagtbRFhSjLWgbbUH7aAs6RlvQYHfqsox2p06j3anTaHfqNNqdOo12p06j3anTaHfqNNqdOo12p06j3anTaHfqPNqdOo92p86j3anzaHfqPNqdOo92p86j3anzaHfqPNqdOo92p15Hu1Ovo92p19Hu1Otod+p1tDv1Otqdeh3nTv30b//77d++//aPP3z389Mzfvs///7jn375/qcfn//1l//767/+n6fH/j8="},{"name":"value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"5ZXtasMgFIbvxd9heD7UnNzKKMO26QgEU5p0MELufaZzso/CfmQrLf0lrz6+vkeUM6ptvT4+PzVh1/WqehxV22380HQhqlEBn+b6vQ+z7Ad/GFSlC1WHbRynQu2atlYVkZuKHxxakISiZcg0IJyhyTEmmkotv9DCwokWYyjTyHpaFQrMrQa3lwvO4CDRjAQLg7slwalEne/Q2EwLn7zLf/SWJd6WbZlQazR980a9yNsQZm/zxfuqnizCXVSJV1rl3/5ieYCzhYJ1aRuI+XSGm1ZRvfhD49dtPTeNefEYNh89JMrhdf++Etk3"},{"name":"pub_get_value","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"base_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/1WNSw7DIAxEH5+gSJVY9bfppq2P0G3vr5wqngBRYskwvPHgLwnmjNeLXiJUil9B/WcoF9E7VMJAJlOpaH2MtCkN5rcfF6Pl5vSTkfTDVWxCS8hNUm60l+Bu3A9w6rA8tng9wlPIGIb1OPEj+VzUK5k3YIz2AAAA","debug_symbols":"hZPRasMwDEX/xc9hxLEsWfmVMYbbpiMQnNKkgxH674uXOhu1h94s6V64x7YWdeoOt4/3PpzHSbWvixrGo5/7MazVouoXrX+608WH2Jhmf51Vq4GgUl04xSM390qd+6FTrTF0rzI1oDEPNSCYXc22IEZEfogRHf4Vv1UxUFMOBPxfoM1mijZbU7LZBkQOrncOZoGDjE4cBJRzgMTxHGiz2TKH+bWhljjIpmhAaCUOTleETrucA0WOp0CbjcochLuNrcThdJM4XCP9K4dm53A653BSIKxL78ESfmZbq09/7f1h6OKSxeEtHNPOreX8ddkmq/Yb"},{"name":"pub_inc_value_internal","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"new_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/73Xy67TMBAGYKe3U0qT9J5bc5q0iWAHQoIdXfIaiNsCCQFCgMQr8lR4xp78KYFW3iRSetzxfJ2xk7NwpYZKTUdKX7myF0VUoCb6j0f3WclIDwb69gLlSaimSVKD2qapIY8ocXTUHw9rZdx0+JwmhvQLS4qNQ/qcjKmUGtNQ33cVNaBe6ntWS0tT7oqvGX2YHCr2oMJMpbxXVNAkT23yvB6YoJqDzU3OzAyZ/kBYqM+UEnxQH9S39DPCQgOmlBCABqCBpe8QFhoypYQQNAQNLf2OsNAFU0pYgC5AF5Z+RFjokiklLEGXoEtLvyAsdMWUElagK9CV+dsl/nWiqxUIC10zpYQ16Bp0belXhIVumFLCBnQDuuk2umlegStEV3uLsNAtU0rYgm5Bt5a+Rljojikl7EB3oLtuo7vm+TkS350E7uTGWvQ2/ERYaMSUEiLQCDSy9A3CQmOmlBCDxqCxpZ8QFpowpYQENAFNumtMmrfkCtHVPiAsNGVKCSloCpp2q6XNjjqShTvx3UnoTm4sX+/cN4SFZkwpIQPNQLNutaxZkyOJ3EnsTlbuJOhlLX4va1n20tiN56LftV8IC90zpYQ96B503622b7bBkWzcSdJLY4E7idxJ3Au5sWP6LXiPsNCcKSXkoDlo3q2WN5vtSBbuxHcnoTtJ3Enay1oidxL3QrLrpKT4Mxx9zgwVzjtywOETWq3EVmqkcN1zqfvLUgeDczOUGTpbHZBU4gh1nPDwaPNP+t+AMiqPEysK0c0dPzHfZLlkqlrSChQ2EwMTpEmpQL9y1DGvbrX1V8MvPLvac8UnxPZFU+OgOTyOsSIcHCf/PTjePRpYSN8m2IPWzhRmOw6295LXTY+n5L7sNTR1OK3kHShNuYmtOsKz5dl/PdvysrtWPyVeF0oqeCvvaNRq1OSU0uhj2TbvcmNaXRRNFyW6KC67OKKLEyqcmgdKC6uQbp/tSV6Vp17Ts7LZp9r+mBrwMP5N9x/r/4TYhhAAAA==","debug_symbols":"5dxvTxRXGIbx77KvSXPu+zl/+SpN06yKDQlZjGCThvjdO1RmW8PI9tJEZ51XBjiHnMcrCvz2DA+7N1evPvzx+/Xh7e3d7vLXh93N7ev9/fXtYXrrYZd+kf557927/eHxHXf3+/f3u8t0sbs6vJn+/Hixe3t9c7W7jGgfL56ty+H8tDRH+Lh6lIXFNXp/Wlxziv8u/u3i8Sj+pqOolfko6vnEURxtPorLwlHi/x/l04ZMNxS6odINjW7odMOAG5zoBtENphtoadPSpqVNS5uWNi1tWjpo6aClg5YOWjpo6aClg5YOWjpo6aClMy2daelMS2daOtPSmZbOtHSmpTMtnWnpQksXWrrQ0oWWLrR0oaULLV1o6UJLF1q60tKVlq60dKWlKy1daelKS1dautLSlZZutHSjpRst3WjpRks3WrrR0o2WbrR0o6U7Ld1p6U5Ld1q609Kdlu60dKelOy3daelBSw9aetDSg5YetPSgpQctPWjpQUsPWlop4R3CO4x3YD1JmE8S9pOEASVhQUmYUBJuLtxcuLlwcy5mnMy4mXE042rG2Qy7mTCcCcuZMJ0J25kwngnrmTCfCfuZMKAJC5owoQkbmjCiCSuaMKMJO5owpAlLmjClCVuaMKYJa5owpynzV0NwcyxqwqQmbGrCqCasasKsJuxqwrAmLGvCtCZsa8K4Jqxrwrwm7GvCwCYsbMLEJmxswsimyl/3xM2xswlDm7C0CVObsLUJY5uwtglzm7C3qfEXu3FzTG7C5iaMbsLqJsxuwu4mDG/C8iZMb+r8hgNujvVNmN+E/U0Y4IQFTpjghA1OGOGEFU6DX2vh91rwxRbscMYOZ+xwxg5n7HDGDmfscMYOZ+xwFr/MhJtjhzN2OGOHM3Y4Y4czdjhjhzO/v8YvsH3FDTbcnN9h45fY+C02fo2N32PjF9mwwxk7nLHDOfi1RdwcO5yxwxk7nLHDGTucscMZO5yxwxk7nDO/q4qbY4czdjhjhzN2OGOHM3Y4Y4czdjhjhzN2OGOHM3Y4Y4czdjhjhzN2OGOHM3Y4Y4czdjhXfisdN8cOZ+xwxg5n7HDGDmfscMYOZ+xwxg7nxh9FwM2xwxk7nLHDGTucscMZO5yxwxk7nLHDufPnT3Bz7HDGDmfscMYOZ+xwxg5n7HDGDmfscB78oSP+1BF+7Ag7XGCHC+xwgR0usMPFssPFZE5Pm2L6Meizfc+fo1Rq83OUknVcPb04v7C6RMxPi5ao47h68RHNMpH1vHiSmpcX95Lmc/SSnz/PGcsg+LMOOzY07DLD/qzDakvDekvDxvcfVuM4bEsvn396NbDOn3qUclw8qeI8QD73Acq5D1DPfYB27gP0cx9gnPkA/sJ3A60fBxhj4Zthf+ELa5m/g47pZ4tTg0//AufTRe2nBq+aP3eptZz4WpPbcXFJJxb36nnaXj//K30a1lsaNrY0bN7SsGVLw9YtDdu2NGzf0rBjQ8NG2tKwy99Bhf4dNo8Tw9Yy/wq3pnj5PK22+Uf11rR0Hq/sPLGy8+SVnaes7Dx1ZedpKztPX9l5xrrOs3yF7AeeZz3/P09v/Ll/f71/dXP1+FtIHz/24fB6/qWk05v3f7379JFp7d8="},{"name":"private_get_value","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"set_value_twice_with_nested_last","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"pub_inc_value","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"new_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/1WQwRKCMAxEtxQKAxS46cWDSkePXvTo/49fZbcNhGYmZWk2zWtXWKCrEeMCCe5ggosfw/xiU1FUMc0Es20FFtlVBbHBJkVjfYvLEJD7OvtmwfKEFQ3KYGeTpqZSs8LKbh82j0twKXou6mkflTTyz627b1DP6JIcKGP6K+snqo9RDpvnJJsPLPg8zslUPlarp/qdrlc6X9IdeHw29WIaA7lbqgNo9vgN9Gmkw5QPc6AYdwqvFGNJMSnFrBOixJIoeLFF7Uv2zFlifpmdGeKegxyG6k55/jH/WmNC5FQCAAA=","debug_symbols":"5ZnRaoMwFED/Jc8ycnNzc5P+yhjDtnYIxZbWDob036fT2JXZ+jYi983oiZzjg0bSqG2xvny8l9XucFar10btD5u8Lg9VO2qUfgH4OXs+5lV34lznp1qtjEedqaLadofkr5nalftCrRD5mv2hQTMPNICBkQbrJmhCtANN6MJIB5qCIWCEDczAnnT08GTxN/yWda0oqNUKaiVBrU5QKwtq9f/fCmFsZf1cH4J18daBaIQN2sE/LNvf6IX7w8L9zcL9ceH+duH+D9YAIU4zAfjOv5/24HPq/G3abDbC6IbOz2U7iI+UnKOZT4zlESY9A3tnorV39w+0b2VBrV5Qa5DTilpQKwhqNYJaUVCrFdRKglqn103B3Fodz7Q6ogFmwOc67Dj+lzPDhA6npePT0glJ6Vidlg6kpWPS0sG0dGxaOpSWTjpv5XbwmZ/KfL0vup2m7tql2sSNp3ZYfx37Ky37DQ=="},{"name":"set_value_with_two_nested_calls","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"current_value","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"a_map_with_private_values","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[],"kind":"struct","path":"Child::set_value_twice_with_nested_last_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_set_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"input","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_internal_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_internal_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"input","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_internal_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_internal_abi"},{"fields":[],"kind":"struct","path":"Child::set_value_with_two_nested_calls_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Child::private_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::private_set_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Child::private_get_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::private_get_value_abi"},{"fields":[],"kind":"struct","path":"Child::set_value_twice_with_nested_first_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"base_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_get_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_get_value_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"153":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE, lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PublicContext> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N, M>(self, note: &mut Note) where Note: NoteInterface<N, M> {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext> {\n    // docs:start:insert\n    pub fn insert<N, M>(self, note: &mut Note) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    // docs:start:remove\n    pub fn remove<N, M>(self, note: Note) where Note: NoteInterface<N, M> {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(self.context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, M, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n        get_notes(self.context, self.storage_slot, options)\n    }\n    // docs:end:get_notes\n}\n\nimpl<Note> PrivateSet<Note, UnconstrainedContext> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N, M>(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"330":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n"},"337":{"path":"/usr/src/noir-projects/noir-contracts/contracts/child_contract/src/main.nr","source":"// A contract used along with `Parent` contract to test nested calls.\ncontract Child {\n    use dep::aztec::prelude::{AztecAddress, FunctionSelector, PublicMutable, PrivateSet, PrivateContext, Deserialize, Map};\n\n    use dep::aztec::{\n        context::gas::GasOpts, protocol_types::{abis::call_context::CallContext},\n        note::{note_getter_options::NoteGetterOptions, note_header::NoteHeader},\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note\n    };\n    use dep::value_note::value_note::ValueNote;\n\n    #[aztec(storage)]\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_map_with_private_values: Map<AztecAddress, PrivateSet<ValueNote>>,\n    }\n\n    // Returns a sum of the input and the chain id and version of the contract in private circuit public input's return_values.\n    #[aztec(private)]\n    fn value(input: Field) -> Field {\n        input + context.chain_id() + context.version()\n    }\n    // Returns a sum of the input and the chain id and version of the contract in private circuit public input's return_values. \n    // Can only be called from this contract.\n    #[aztec(private)]\n    #[aztec(internal)]\n    fn value_internal(input: Field) -> Field {\n        input + context.chain_id() + context.version()\n    }\n\n    // Returns base_value + chain_id + version + block_number + timestamp\n    #[aztec(public)]\n    fn pub_get_value(base_value: Field) -> Field {\n        let return_value = base_value\n            + context.chain_id()\n            + context.version()\n            + context.block_number()\n            + context.timestamp() as Field;\n\n        return_value\n    }\n\n    // Sets `current_value` to `new_value`\n    #[aztec(public)]\n    fn pub_set_value(new_value: Field) -> Field {\n        storage.current_value.write(new_value);\n        context.emit_unencrypted_log(new_value);\n\n        new_value\n    }\n\n    #[aztec(private)]\n    fn private_set_value(new_value: Field, owner: AztecAddress) -> Field {\n        let header = context.get_header();\n        let owner_npk_m_hash = header.get_npk_m_hash(&mut context, owner);\n\n        let mut note = ValueNote::new(new_value, owner_npk_m_hash);\n        storage.a_map_with_private_values.at(owner).insert(&mut note).emit(encode_and_encrypt_note(&mut context, owner, owner));\n        new_value\n    }\n\n    #[aztec(private)]\n    fn private_get_value(amount: Field, owner: AztecAddress) -> Field {\n        let mut options = NoteGetterOptions::new();\n        options = options.select(ValueNote::properties().value, amount, Option::none()).set_limit(1);\n        let notes = storage.a_map_with_private_values.at(owner).get_notes(options);\n        notes.get_unchecked(0).value\n    }\n\n    // Increments `current_value` by `new_value`\n    #[aztec(public)]\n    fn pub_inc_value(new_value: Field) -> Field {\n        let old_value = storage.current_value.read();\n        storage.current_value.write(old_value + new_value);\n        context.emit_unencrypted_log(new_value);\n\n        new_value\n    }\n\n    // Increments `current_value` by `new_value`. Can only be called from this contract.\n    #[aztec(public)] \n    #[aztec(internal)]\n    fn pub_inc_value_internal(new_value: Field) -> Field {\n        let old_value = storage.current_value.read();\n        storage.current_value.write(old_value + new_value);\n        context.emit_unencrypted_log(new_value);\n\n        new_value\n    }\n\n    #[aztec(public)]\n    fn set_value_twice_with_nested_first() {\n        let _result = Child::at(context.this_address()).pub_set_value(10).call(&mut context);\n        storage.current_value.write(20);\n        context.emit_unencrypted_log(20);\n    }\n\n    #[aztec(public)]\n    fn set_value_twice_with_nested_last() {\n        storage.current_value.write(20);\n        context.emit_unencrypted_log(20);\n        let _result = Child::at(context.this_address()).pub_set_value(10).call(&mut context);\n    }\n\n    #[aztec(public)]\n    fn set_value_with_two_nested_calls() {\n        Child::at(context.this_address()).set_value_twice_with_nested_first().call(&mut context);\n        Child::at(context.this_address()).set_value_twice_with_nested_last().call(&mut context);\n        storage.current_value.write(20);\n        context.emit_unencrypted_log(20);\n    }\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}