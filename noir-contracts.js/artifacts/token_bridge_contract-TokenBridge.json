{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"TokenBridge","functions":[{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/82YyY7bRhCGW5oZzUSRuGgbZSRK1EJpLNmxZ4D4FOeYY065B9ngBNkQxzkkCBAg5wB5gLyRn8pdVV38KdOm0YJBDAGSrer/Y1VXL+jW2pwYc2FvYxLjLrKYwLTsq0H3J0ZLttC0dyMwDTVlVElUM3Myc8IlEp4u7aP9kVEXIT3O+Nnac5lK9j5fmwahZ2f0ZXOuVWsKhrF2puFdcIR8tekhGsLeW6PGfvAz+35fxBdO3MmaYjQdYB3RtKXI6C8wK9pllARdoF2gXYc+h1nRgFESBEADoIFDU5gVDRklQQg0BBo69HuYFY0YJUEENAIaOfRnmBWNGSVBDDQGGsu7jIT+SPede7Ft+hJmRXuMkqAHtAe059AfYVa0zygJ+kD7QPvlQPt5oBWI9fYnzIoOGCXBAOgA6MCh38Ks6JBREgyBDoEOHfoNzIqOGCXBCOgI6IjeC5pazzExIwYNZqNOP1KbTKeo/eKpwXXJri4PXY0FHklRayiBY4iuMMEnLS5OnH7qFpCkwUJay6Z0c8S/yi9tLjFJprIP4FgqmmKkSvVwRW+anU8LYb0S8OOGzisaY+ZcVrkzWd7cMncp+MfE5GkbIW3jw/WsjebaJDQ+PYyWxFd5tFeFLIlm7AIn9HeYFZ0wyi0DOgE6Kbdxki8LFYj19jXMik4ZnUhPKToFOi17m+bLgycS+iMdfyTyR4JqxGbuC5gVlQFJggRoAjQpe0vypa4Csd5+g1nRGaMkmAGdAZ2VvR2NDKoRG+AzmBWdM0qCOdA50HnZ2zwfSJ7ItBYvnWrEpuEHmBVNGSVBCjQFmpa9pXnSPZHIH5n6I6E/ktQS2BFe4mrEdulPMCu6YJQEC6ALoIuyt0XepZ5I4I9M/JHYH4lqaUunlsB61YgdBX/ArOiSURIsgS6BLsvelnkaKhDr7SuYFV0xSoIV0BXQVdnbKh9znkjgj0z8kdgf6dWCHJGxYS1JDv2RyB/p1pKxWS1tubNjbFGNUHXjP5xDnjBocPjQ08YqP76N5YvF49uaXa0PXWUCrxy3wkEng2iL88y1HN+unf6eO77t5Pi2IxPdHPG/8kubS8wuU9kGjqWiKUaqVA9beqf2S/8Uwnol4MfuEGqerPmvp+JFVS3+Q0zuwqk1z975G09xl9umA/mvLeSgkJmNpCNzsW+53f9TieNy14n4YdmWM0AtG8sZk7yeom8f0adeF93mMLpCn2xsJ3wuKVNPJL7HKb2WXlLM9cfGddTmdUjHH5n7IwN/JPJHAn8k9keGtSCzWpKc1IIc0S/hXQ0sqmWKdWtpy1u82JXmO5gVlcWbBDugO6C7srddPjw9kcAfSfyR2B9J72rz41oyVk+/DGpBolqaH97VwI7ol64/0vFHZu988Nv17CnMiu4ZJcEe6B7ovuxtn4+1CoR2h82/sde7YdBgg6c7un2+j9/IF4v7+Pvs6v6hqwcC76WoNbSZfADRQ+wZH7UgoEjcPv5W9vG3Lrgbjvgv+aXNJeY2U9mHcCwVTTFSpXp4SO/UfunZuuj1IGDeL1Nrb/hkM35B90uy996P5h4AAA==","debug_symbols":"5d3hih7HFYThe9nfIkyf6nO6W7cSQpBtOQjEylhyIAjfe1bx7jpBS8RbyjFs9MusND1846qy5Uez1sebH15/98vf/vrm9sd3729e/vnjzdt337/68Obd7d1XH2+uP43rXz/6/qdXt59+4P2HVz9/uHl5vbh5ffvD3V9/fXHz45u3r29e6uSvLz677mTeX3nWerx2RDxx7Rzr4eI59ny8+skbV2jdX1yR+veL//Li08ceX/Oxx6W4v3RcOf/QDx5f9ff7jN8/d37hc48x5sPVY13//XOv+fiQK8f+/HOr6XP/dvfZevdsvXu13n213n233v103j2u1ruP1rtH691btxqtW43WrUbrVqN1q9G61Wjdqlq3qtatqnWrat2qWreq1q2qdatq3apat6rWrc7Wrc7Wrc7Wrc7Wrc7Wrc7Wrc7Wrc7Wrc7Wrc7WrWbrVrN1q9m61WzdarZuNVu3mq1bzdatZutWs3Wr1brVat1qtW61WrdarVut1q1W61ardavVutVq3epq3epq3epq3epq3epq3epq3epq3epq3epq3epq3epu3epu3epu3epu3epu3epu3epu3epu3epu3epu3epp3epp3epp3epp3epp3epp3epp3epp3epp3epp3eq4rt7bj97bR+/te9+HuGbv7XvfiLh6X4m4et+JuHpfirh6Vzt6Vzt6Vzt6V9v8FlPza0zN7zF93YtMU/HwttmU4vHqp9+S0973F9e8nnq976sm/j9+1RD88+D+xKEnyMtM9ycGPhH4hPCJiU8kPlH4xMIncOaBMxfOXDhz4cyFMxfOXDhz4cyFMxfOXDjziTOfOPOJM58484kznzjziTOfOPOJM58488SZJ848ceaJM0+ceeLME2eeOPPEmSfOvHDmhTMvnHnhzAtnXjjzwpkXzrxw5oUzXzjzhTNfOPOFM18484UzXzjzhTNfOPOFM984840z3zjzjTPfOPONM984840z3zjzjTM/OPODMz8484MzPzjzgzM/OPODMz8480Mzj+vCJwY+EfiE8ImJTyQ+UfjEwic2PoEzHzjzgTMfOPOBMx8484EzHzjzgTPHDhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4QI7XGCHC+xwgR0usMMFdrjADhfY4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1O2OGEHU7Y4YQdTtjhhB1OTztcrfHwXXS1lP9x7qn/p/56+Da6MWI8Xj1mPXF13v1X0v3Vefevlsern7x1jqOHi2N84eKd18Pn2Dk//3a++TQI/r8+bHxLD6tv6WHnt/Sw+S09bP3xDzvO48N+6U8KGaN+v/Wqx4vvfj/u4QHWc3+A/dwf4DzzB3j693ye0wOM5/4A8dwf4Mu/Gpj5+S+G55jmuTTPlXlumee2ee545+Iyzw3zXJjnzL6E2Zcw+xJmX8LsS5h9CbMvMvsisy8y+yKzLzL7IrMvMvsisy8y+yKzL9PsyzT7Ms2+TLMv0+zLNPsyzb5Msy/T7Ms0+5JmX9LsS5p9SbMvafYlzb6k2Zc0+5JmX9LsS5l9KbMvZfalzL6U2Zcy+1JmX8rsS5l9KbMvy+zLMvuyzL4ssy/L7Msy+7LMviyzL8vsyzL7ss2+bLMv2+zLNvuyzb5ssy/b7Ms2+7LNvmyzL8fsyzH7csy+HLMvx+zLMftyzL4csy/H7Mvx+pLXZZ4b5rkwz8k8N81zaZ4r89wyz23znNmXYfZlmH0ZZl9M303Td9P03TR9N03fTdN30/TdNH03Td9N03fT9N00fTdN303Td9P03TR9N03fTdN30/TdNH03Td9N03fT9N00fTdN303Td9P03TR9N03fTdN30/TdNH03Td9N03fT9N00fTdN303Td9P03TR9N03fTdN30/TdNH03Td9N03fT9N00fTdN303Td9P03TR9N03fTdN30/TdNH03Td9N03fT9N00fTdN303Td9P03TR9N03fTdN30/TdNH03Td9N03fT9N00fTdN303Td9P03TR9N03fTdN30/TdNH03Td9N03fT9N00fTdN303Td9P03TJ9t0zfLdN3y/TdMn23TN8t03fL9N0yfbdM3y3Td8v03TJ9t0zfLdN3y/TdMn23TN8t03fL9N0yfbdM3y3Td8v03TJ9t0zfLdN3y/TdMn23TN8t03fL9N0yfbdM3y3Td8v03TJ9t0zfLcN37776+6uf37z67u3r93dnPv3kL7fff3jz7vb+yw//+Om3n7m79p8="},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83YS2/TQBAH8HXSpi2JX3k1duzESWxy4EIPcOTIEXFGQoiXKgQCIcoBPiKfip3ZHf/jGiwtqiIsOXZn55cZb2xroVR9pc71rlSu7NbTERWogT54tD9RcmYGlRcoT0IVDbKqbJrqb/XHvUq+qveIBtiFFDvhz9MHfE5neh+UyiN6ckrfTKXNUEntKQIXlbR3pjhI2wV9mBxi5yVG9Bc+ozZM8plNHlY9E1RDsKHJuTCnTL8gLHTElBJGoCPQkaU3CAv1mVKCD+qD+pYWCAsNmFJCABqABpZ+QFhoyJQSQtAQNLT0M8JCI6aUEIFGoJE5tkngTkZ3XkVf02uEhcZMKSEGjUFjSz8hLHTMlBLGoGPQcbvRcd1oB9HVfiIsdMKUEiagE9CJpe8RFjplSglT0Cno1NJ3CAudMaWEGegMdEbHDT1aN3gwI4YKT6M8fpStKnlE9TeeKGxzLjVvlro0eGZOZYRuwUskJXjA0wGfpjZ/aV8gmceJGYVo546/mr/kcslklaQtUNgM9EyQBqVCQkd6Oq8P2rrV8GNP7kHbyql5l/XxiqPTh4132fyv77JZ8132FBXnNnnBnVLtBdgCv9jC0u8IC03qi0wOJhc0wa/ZJGE30dXeIiw0ZcpzCJqCpu1qaf1qcCSBOxm6k9Cd+N1Ez9w1wkKXTFNzfwtdgi7b1Zb1K8CRjLqJbvAVwkLN00IJGWgGmrWrZXU1RzLsJrrBjwgLzZlSQg6ag+btank9g44kdCe+O0ncSfS/XsvwKI3F3UTfOD8QFrpiSgkr0BXoql1tVU9DB9HV3iAsdM2UEtaga9B1u9q6vk0die9OEncSuZP4KOQfZmx655Os74JvCAstmFJCAVqAFu1qRf02dSTRUaoE7iQ5yrXERyF5N6HFqfcSa8Mrhn9YTheN5XTRXE5vuNSmWWprcGFOZYQWn1sklVhjVmY5Xdn8+3YNuzfL6T2FaOeOX5i/5HLJ7CtJ26GwGeiZIA1KhZKOOsN7ftDWrYbr5fRVycvnw42X1fwfFGz6B5ddz94As7dtrqw3+56FHqaett3BzJjp2EmzfN30b+yK+7Jb39ThtIpnoKp72PIvo+wv09vR6eIX7b8B3hwxh3MRAAA=","debug_symbols":"5Z3daltHGEXfRdemnNl7fvMqpRQncYoh2CF2CsXk3Ss3ktJikbAIO+D6ysiebzjjxbpZGqSH3dur15/++P365t3t3e7Vrw+797dvLu+vb2/2rx522y9l++e3dx8ubx5/cXd/+fF+92q72F3dvN3//Hyxe3f9/mr3yqt9vniybrV2WLnGOK0t0pm1tYzj4lpmPa0+u3GXx2FxV/O/F/928fjY5Uceu2zWYWnZWv2pD64f+n+v8vW523eeu5RSj6vL2L793KOeDjlamU+f26Hn/rJ7je7eorv36O4juvuM7r6Su2uL7l6iuyu6e9RVRV1V1FVFXVXUVUVdVdRVR1111FVHXXXUVUddddRVR1111FVHXXXU1Rp1tUZdrVFXa9TVGnW1Rl2tUVdr1NUadbVGXW1RV1vU1RZ1tUVdbVFXW9TVFnW1RV1tUVdb1NUedbVHXe1RV3vU1R51tUdd7VFXe9TVHnW1R10dUVdH1NURdXVEXR1RV0fU1RF1dURdHVFXR9TVGXV1Rl2dUVdn1NUZdXVGXZ1RV2fU1Rl1dUZdXVFXV9TVFXV1RV1dUVdX1NUVdXVFXV1RV1fU1bJt2e1Ldntlt8/eh9hqdvvsjYgteyViy96J2LKXIrastSVrbclaW7LWhm8xha8xhe8xkYtMh4mBJyaeWHSCXAw6TBQ8ITxhPFHxRMMTmLkwc2HmwsyNmRszN2ZuzNyYuTFzY+bGzI2ZGzOvmHnFzCtmXjHziplXzLxi5hUzr5h5xcwbZt4w84aZN8y8YeYNM2+YecPMG2beMPOOmXfMvGPmHTPvmHnHzDtm3jHzjpl3zHxg5gMzH5j5wMwHZj4w84GZD8x8YOYDM5+Y+cTMJ2Y+MfOJmU/MfGLmEzOfmPnEzBdmvjDzhZkvzHxh5gszX5j5wswXZr4oc20bnih4QnjCeKLiiYYnOp4YeGLiCcy8YOYFMy+YecHMC2ZeMHPc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wwh1OuMMJdzjhDifc4YQ7nHCHE+5wxh3OuMMZdzjjDmfc4Yw7nHGHM+5wxh3OuMMZdzjjDmfc4Yw7nHGHM+5wxh3OuMMZdzjjDmfc4Yw7nHGHM+5wxh3OuMMZdzjjDmfc4Yw7nHGHM+5wxh3OuMMZdzjjDmfc4Yw7nHGHM+5wxh3OuMMZdzjjDmfc4Yw7nHGHM+5wxh3O5ztcW3Mehvq2zf/Mnfts03H8ANJSVE6rS+1nVre9YYfVzX2dVp/duu3fGD8u3r8f9O3Fs23H55itPv0gVJ8Pgv/Xw+olHdYv6bD1JR22vaTD9p9/2LJOh/3eJzaX0r9uPfpp8b7lHA8wnvsB5nM/wHrmBzj/ns9zOkB57gfQ8z3A/tWflx+vL1+/v3r8uoHHP366eXP89oH9y/u/Pnz5y37t3w=="},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3vjhzHkcTfhZ+FQ2Xlvyq9yuFwkG35IECgDIs+4CDo3W9obfcMwRZ7aXXFRJr8JFLs7YiaZf5iZhi588ubv3z/p3/8z3//8PavP/385tv//OXNjz/9+bt3P/z09va7X960/xD95//9+W/fvX3/P35+993f3735tn3z5vu3f7n999dv3vz1hx+/f/OtTv/1v755/wX2uV/gn/sF8blfkJ/7BeNzv2B+5hf09rlfIK//gm8+um66v1w5M/drpfeDa01yu9hk2H714Y2ja75cHN318eLfbPc/Ylua9pdLpblBjesferyn3H37iW8Rse1qyfZp32n7IdNlfOzbFvn+7e6+9O6x9O659O5j6d3nyrtrW3p3WXr3vvTuuvTuS2dVl86qLp1VXTqrunRWdems2tJZtaWzaktn1ZbOqi2dVVs6q7Z0Vm3prNrSWbWls+pLZ9WXzqovnVVfOqu+dFZ96az60ln1pbPqS2fVl85qLJ3VWDqrsXRWY+msxtJZjaWzGktnNZbOaiyd1Vg6q7l0VnPprObSWc2ls5pLZzWXzmoundVcOqu5dFZz6ayOpbM6ls7qWDqrY+msjqWzOpbO6lg6q2PprI6lszqWzupcOqtz6azOpbM6l87qXDqrc+mszqWzOpfO6lw6q3PprEpra28va2/f195e197e1t7e194+1t4+195+rL392qmVtVMra6dW1k6trJ1aWTu1snZqZe3UytqplbVTK2untq+d2r52avvaqe1rp3ZtoUnWNppkbaVJjjtNfcytNtenn4l0yU3l9st+vzrapjIgKhOhctx1+kyV3mK7utuHKgffxHH/Jsq9aNj1qAqoc7uzmH5w8Yt9qW2/17avte1bbfte237Utp+17Y/a9mdp+1Y7da126lrt1LXaqWu1U9dqp67VTl2rnbpWO3Wtdup67dT12qnrtVPXa6eu105dr526Xjt1vXbqeu3U9dqpG7VTN2qnbtRO3aidulE7daN26kbt1I3aqRu1Uzdqp27WTt1cnLovKh2ickmGRe4qY0K/FVbbvte2H7XtZ237o7b9Wdr+aLXtS237vbb92qk7aqfuqJ26o3bqjtqpO2qn7qidurN26s7aqTtrp+6snbqzdurO2qk7a6furJ26s3bqztKp21vp1O2tdOr2Vjp1eyudur2VTt3eSqdub6VTt7fSqdtb6dTtrXbq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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+1dB3gUVdfe7CYh9F6UFpCmguxNQrJRVFAUKyhiAQukIkqTJlgQexe7WLFjV+z62bBi77333nvD/1yyQ06Gm7I77wlz/J3neZ8Mh5m759xzz3v7nYxI1fVITiTyVnbVfQYhlvwbJeT6ZN5ffp/pkGU73m3hkLVyyNo4ZO0csk6EYT5ZD8dzPR2yXIesl0PWNynjV0by77Dk3/x4YUFBRVFehck3JfG84tLEkHjBkNLChEmYIYkh5XmJ/PyKREGiqLi0uChebAryK0zlkOL8ynjV9XFGdVrxgJfVrWkyDz1d+xFWJu/7s/sB7N7qEMb7gYRPMqpkfrs+CanODbXrU68gJa+or1zFg12mL7CMfoYro4bHl003N1Lt3yjzbwYrn959E8Ln9I8s+pvDnudXBjgfO+LSijvUDZq28W54XnyRzIQv/cRs/+Mdn+zLjDVJLiaYiWkWxrxkYTRfZOAK9pcZMs5FBzPS5q8caZXGy8qHmNLC8iJTUTIkUVZWnG9MXklhSWFpXqKyonSISQxJUJplJXkJ+rm8kjJTES8prLCB2DRSHXT8QgfiV+CK0ru+zhBU+OsMfLrfAAuDlN3fsBwGpevUFUEAVldUwHrpIn30Lbjge8Rv0+0VqapN7dUYtakU4aL1/ByoZxbT87ukot8n//6Q/Ptjkic6JJ/7if7xM+EXwq+E3wi/E/4g/En4i/C3bU0S/smocl4GIUqIETIJWYRsQpNopGaN/6OjxvcHQNBCC8xA8z3YGY1VYyELEdc3JyqosE0cnW7TaLhrLGt3U0Z/oHQbtbD9IFTYmkUFFW4mUNiah7ywWbubKy9sPwoVthZRQYVbCBS2liEvbNbulgKFTUJXy8DNo/g2fqsofoQ1xsrp52yE7wd2/2Py3l6to9XPI22zvm0lkGdtcHlm/P0KdLn5DkhGXvu7LSndjtCe0IHQkdCJ0JnQhbAOYV1CV0I3QndCD0JPQi6hF6E3YT1Cn2hV85o3wdtG15w1aeeQtXfIOjhkHR2yTg5ZZ4esi0O2jkO2rkPW1SHr5pB1d8h6OGQ9HbJch6yXQ9bbIVvPIesTXbOSzBQsk0FjsS2gjqmorLraAeurvbJk+vJ+XwS0ubw9Lv+KO+DSMh2BvthbhS8qTCdY/pWZzrC0EqYL0Bf7qPBF3KyDyr+KuFkXlVZZ3HQF+mKCBl8k4qYbKv+o7ukOSquC0uoB9MVEBb4oI5t7gvIvQWnlgtIik00voC9Kwu+LCmtzb0z+ldm01sOklbBp9QH6orSRfBEPdhlge88A2yuG17dBfVGmxBfAes0AedmUAH1RLuQL9OIWYPwaYPkzUvkX9eVfGPq3Xlp9geNWNg30WJUdB2wjMF7XL4r1NdpuO5/dVsDuaVnhttuWx34Cdk9vJG4Mqmd/YDwCfW2mh7zc2HjpK1BuZobc7rZC8TJLSbwMAMYL0NcGmX/eHJrXjrD/tjyxemdCtHrebP1o9TPIcmbXVrUTKGdzheMrqH7W5vUF7D5QSb9pfWBbcwNgrALLjdHii5+Bc2QbRmViOExx4eLNDRhvbsh4c6AQb9r1qO0F+OOgkPOmtXmggN0HK4nVgcD4GgTkTWC5MVp88QuQNzeKysRwmOLCxZuDGG9uxHhzsBBv2jX8HQT4Y0HIedPaPFjA7sOUxOpgYHzFgbwJLDdGiy9+BfKmicrEcJjiwsWbccabhvFmnhBv2n1PHQX444iQ86a1OU/A7iOVxGoeML7ygbwJLDdGiy9+A/JmQVQmhsMUFy7ezGe8WcB4c4gQb9q9op0E+OOYkPOmtXmIgN3HKonVIcD4KgTyJrDcGC2++B3Im0VRmRgOU1y4eLOQ8WYR482EEG/a/fWdBfjjhJDzprU5IWD3iUpiNQGMr2IgbwLLjdHiiz+AvLlxVCaGwxQXLt4sZry5MePNTYR4055J0kWAP04JOW9amzcRsHuRkljdBBhfQ4G8CSw3Rosv/gTy5qZRmRgOU1y4eHMo481NGW9uJsSb9hyndQT44/SQ86a1eTMBu89QEqubAeNrcyBvAsuN0eKLv4C8OSwqE8NhigsXb27OeHMY483hQrxpz75bV4A/zg45b1qbhwvYfY6SWB0OjK8tgLwJLDdGiy/+BvLmllGZGA5TXLh4cwvGm1sy3hwhxJv2vNCuAvxxXsh509o8QsDu85XE6ghgfG0F5E1guTFafLESyJtbR2ViOExx4eLNrRhvbs14c6QQb9ozlrsJ8MdFIedNa/NIAbuXKInVkcD42gbIm8ByY7T44h8gb24blYnhMMWFize3Yby5LePN7YR40/54dwH+uDTkvGlt3k7A7suUxOp2wPjaHsibwHJjtPgiAvTFDlGZGA5TXLh4c3vGmzsw3txRiDfttzx6CPDHlSHnTWvzjgJ2L1USqzsC42sUkDeB5cZo8UUG0BejozIxHKa4cPHmKMaboxlv7iTEm/b7Rz0F+OOakPOmtXknAbuvVRKrOwHja2cgbwLLjdHiiyjQF2OiMjEcprhw8ebOjDfHMN7cRYg37TfjcgX444aQ86a1eRcBu29UEqu7AONrLJA3geXGaPFFDOiLXaMyMRymuHDx5ljGm7sy3txNiDftdzZ7CfDHzSHnTWvzbgJ236IkVncDxtfuQN4ElhujxReZQF/sEZWJ4TDFhYs3d2e8uQfjzXFCvGm/TdxbgD9uDzlvWpvHCdh9h5JYHQeMr/FA3gSWG6PFF1lAX+wZlYnhMMWFizfHM97ck/HmXkK8ab/nvp4Af9wdct60Nu8lYPf/tHx7BxhfewN5E1hujBZfZAN9sU9UJobDFBcu3tyb8eY+jDcnCPFmk2jN776i8um+kPOmtXmCgN33a/lOFjC+JgJ5E1hujBZfNAH6oiQqE8NhigsXb05kvFnCeLM0GqlxRcG+ax3B5VEpLo7iPrPh9UY/XFrx3GQ6ZaR0OaGCUEmYRNiXMJmwH2F/whTCVMI0wnTCDMIBhJmEWYTZhDmEuYQDCfMI8wkHEQ4mHEI4lLCAcBhhIeFwwhHRqkyy+eR9D93qkxOpKSt3yCocskqHbJJDtq9DNtkh288h298hm+KQTXXIpjlk0x2yGQ7ZAQ7ZTIdslkM22yGb45DNdcgOdMjmOWTzHbKDHLKDHbJDHLJDHbIFDtlhDtlCh+xwh+yIpIxf6HqGx2xQrioD1DPe97bLgXXWg41U5wex2fqiApJ/VX6tDJ5WXjL/zCSgLx4Ksy8KVutp9g1mc5zZbCYHSSuvRv6Z/YC+eDicvoj79DT7p2lzYeUaNpsp6aWVcOSfmQr0xSNh80XCqaeZlrrNRbXYbKanmlZRrflnZgB98Wh4fJFXh57mgFRsLqrTZjOz4WmV1ZN/ZhbQF4+FwRdF9eppZjfM5ngDbDZzGpJWvEH5Z+YCfbFi7fpiSAP1NAfWZ3NBg2028+pMq6Ayhfwz84G+eHxt+aIoJT3NQbXbnEjRZnNwLWkVV6acf+YQoC+eaHxfxNPQ0xzqsjmels1mwZppmTTzzxwG9MWTjemL8rT1NAtr2pwfwGZzOEsrrzJQ/pkjgL54SslYO3B8wAD7t+Zh4Fj700p8AewHGWA73jwG9MUzSnwBbO8ZYHvFPAH0xbNKfAGs1wyQl83TQF88J+SLGNgXwPg1wPJnkPkXjdS80HOF/XFprZ4rPJKUPopwNOEYwrGE4wjHE04gnEg4iXAy4RTCIsKphNMIpxPOIJxJOItwNuEcwmLCuYTzCOcTLiBcSLiIsIRwMeESwqXRyBpzhVYf/5zOUQ7Z0Q7ZMQ7ZsQ7ZcQ7Z8Q7ZCQ7ZiQ7ZSQ7ZyQ7ZKQ7ZIofsVIfsNIfsdIfsDIfsTIfsLIfsbIfsHIdssUN2rkN2nkN2vkN2gUN2oUN2kUO2xCG72CG7xCG7NCo/V8hjNijXHwnoZ3hzhUcB+yzvKZkrPBqSf1V+PSZ4WqvnCo8F+uJ9JXOFxwWzucZc4fFB0vLNFZ4A9MUHSuYKT0zTZtdc4UnppeWcKzwZ6IsPlcwVnpK6zbXOFS5KNa065gpPBfriIyVzhaelYnM9c4WnNzyteucKzwD64mMlc4VnNszmBs0VntWQtBo4V3g20BefKJkrPKc+m1OYK1wcxc0Vngv0xadK5grPi+LmCs+P4uYKLwD64jMlc4UXRnFzhRdFcXOFS4C++FzJXOHFUdxc4SVR3FzhpUBffKFkHB44PmCA/VvzAXAc/kslvgD2gwywHW8+BvriKyW+ALb3DLC9Yj4D+uJrJb4A1msGyMvmS6AvvlEyVwiMXwMsf0Yq//zzhEH9fFkUpWdFpaSel8P0LBHNzytgepo8ST2vhOlZZqxulmNHMF0vY3Nol7P7K9j9lez+CHbP9+otZPd8rx/fC8j3CvK9hHyvId+LyPcq8r2MfK8j3wvJ90ryvZR8ryXfi8n3avK9nHyvJ98LyveK8r2kfK8p34vK96ryvax8ryvfC8v3yvK9tHyv7aXsns9/8vlRPn/K51f5/Cufn+Xzt3x+l8//8vlhPn/M55f5/DOfn+bz13x+m89/8/lxPn/O59f5/Dufn+fz93x+n8//8/UBfP0AX1/A1x/w9Qne+oWl9PcqwtWEawjXEq4jXE+4gXAj4SbCMsLNhFsItxJuI9xOuINwJ+Euwt2E/xHuIdxLuI9wP+EBwnLCg4SHCA8THiE8SuAXmmceg/FMPM/q5j+DwMI7g8D+lr3vTFhB91lJuc9Ep53xYJf5MqNx6vt4sMuswPkjns30fDyZyU8k/z6Z/PtU8u/T0SpbBiSff4b+/SzhOcLzhBcILxJeIrxMeIXwKuE1wuuENwhvEt4ivE14h/Au4T3C+4QPCB8SPiJ8TPiE8CnhM8LnhC8IXxK+InxN+IbwLeE7wveEHwg/En4i/ByN1Fz8YZXPjdS8/A3ZwJt/cI4xT0Rxev0CLDA2IJuyQi1Z0JF6c31/jQoq/GsUn+5vwMIgZfdvjKJB6a4qbNFI47A/klUl9XxCKCh+Z+UW3oT4DciMnNU9pbOYTLqgIB3AC/YfyX/8aW2ScMDvAsz0OzhqpOyOCtodVMe/hPMwHuwytmD+FcX75m8wk3kEYNNdmEwXnRd/CuXFSqG8WCmYF09I5UXIz8CUiod/1q7d9a5Dkyr7kWwd8xTAcmmAvjbI/LMNKTsO7GpxR1LMz/rKE09Tos5C5QlvVP5TVys5HuwyfwlVAlzpFHU29f2O1fkfAVLIFCKFVCeSU2m8BSbCWDgJBukLXi7tzcJIzStV/9SX50j/ZDD/mPx8io3yIlNZXpk/pKg4r9QU5hcWVhZUFhUmCsorhxSUlBdVmIKS/LziiqJ4pUlUVBQNyS8rKqwsLi8rrOSkbcrz8wvKi0vLzJC8wpLSeKI8vyReWVCUnxcvKc8vKi/PTxQWluTnlxcmKhPFiby8ksr8RHxIUVFxvDAvvzhPyj8ZSf80Zu8aOQzDK7FosjUQiykhcCn9ojEBso7JFMDMmFzvxeZFTCAvsoTyIkswL1YIteyzs2XjATHyIhEPTdau3fX25KTKfo6SnhywXBqgr03Ofz05/2WiYD71rmwtDQFeCXClJXpy2QKk0OL/YU+uSSycBNNCqKfQRFlPLgfYk8sB9uSk/JPDenK1VQphHoKT1FOqgmmqsYJpKlzBNBWoYFo1UgWDnOcN0VxRjQomqF6tG6kHEFTPZsAKGlj+TGuhCqBZAyrooHnaPIarCGsMj4aogm4l5J/m/6Kh1hbJYG0Zcyxkige7TG0LepAr1IKmBVwUZSQc7+UhmlSl8jBwAyEWbn/YgGkl0DBqLTQU3VpwKLqlUF60EcqLNsLD8hJ50S7kw/JS8dA+5MPyUmW/g5JheWC5NEBfmw7/Dcv7r1V1FipPeGO3reSoSSuhSqCt4KiJ1bmtACl0UTIsz30WuOKLhZNgugj1Kts1wrA80j/tgcPyHYC9fin/tF8LvX6p7Usdkq2BjloIXEq/DgJk3Umo4uok2HuxedFRIC86C+VF55jsVhmJlv26Ie/JScVD15D35KTKfjclPTlguTRAX5tu//Xk/JfpINST66KxJ9dFuCfXRYAUcv8f9uTWiYWTYHKFegrrKOvJrQvsyXUD9uSk/LPuWlhg1SImE/daKpiuGiuYrsIVTFeBCqa3kgVW0KEooRZsUL3WU7LAqhuwggaWP7OeUAXQrREWWHUHLrDqkB3OCrq3kH+6O/yD7vWuAK5ZeQqYVg9gXdaY5//1EGo49IwJKtwzhk83F1ixSdmdG6vOYFC6jXr+Hw+4eMBLUk/kqk0eFL3qak0HHqIAtgY4q3tK/xuWzfZOBtB6rmWzCAf0EmCmXsITcii7o4J2B9WxT8gnNW3B7CPQrewr1MXuKziRt55QXvQTyot+wstTRfIi5JOaUvHQP+STmlJlf4CSSU1guTRAX5sB/01q+q9VdRYqT3ijsr/kmHMfoUqgv+CYs9W5vwApDFQyqdkH2BAcEAsnwQwUGpMb0AiTmkj/rA+c1BwAHDOV8s/6a2F5KnIYhldiGyRbAxtqIXAp/TaQIGuhimugYO/F5sWGAnkxSCgvBgnmxVNCPbmNQt6Tk4qHwSHvyUmV/biSnhywXBqgr038v56c/zIbCPXkNtLYk9tIuCe3kQApFPw/7MkNjoWTYAqEegqDlfXk4sCeXBzYk5PyT3wtLE/tHZOJey0VjNFYwRjhCsYIVDCFSpanIgmsv1ALNqheRUqWp+YBK2hg+TNFQhVAXiMsT80HLk8dkB3OCrpQyD/5/6Kh1oJksA5xLWSKB7tMbQt6kCvUgqYFXBQlct6cl4doUpXKw8ANhJD7wwZMoUDDqEiokVgkOBQ9RCgvEkJ5kRAelpfIi41DPiwvFQ+bhHxYXqrsD1UyLA8slwboazP0v2F5/7WqzkLlCW/sFkuOmhQKVQLFgqMmVudiAVIYpmRYvhDYENw4Fk6CGSbUq9y4EYblkf7ZBDgsPxTY65fyzyZrodcvtX1paLI1sKkWApfSb6gAWW8mVHFtJth7sXmxqUBebC6UF5vHZLfKSLTstwh5T04qHrYMeU9OquyPUNKTA5ZLA/S1GfFfT85/maFCPblhGntyw4R7csMESGGb/4c9ueGxcBLMNkI9heHKenJbAHtyI4A9OSn/bLEWFlgVxGTiXksFs6XGCmZL4QpmS4EKZjslC6ygQ1FCLdigem2vZIHVCGAFDSx/ZnuhCmBEIyyw2gq4wGpodjgr6O2E/LMVq6Ab6/y6p6MyFd/WMUGFt47h0x0JJGYpu0fGqjMYlG6jHpb4lFBh2yYmqPA2AoVt25AXNmv3tgKFzaUrYkVfYQx/fBqypbZdyOeELLFsK9Aq3z4W7rJjvwbdSqDsIE/53iHkeWjL9vYx/Pg8MGbM9kB/7Bhyf9jysqNALI8SXqEcVD87fzlKwu7scHP3E0J2jxbqxaO5FugfMxo899ZYDWvkBzO5vqNjggqPFmhY7xTyhrW1eyflvbgnhQrbzjFBhXcWKGxjQl7YrN1jGqkXFw92rQrcMQK12C4h73nZXtcuAnaPBc8NWXLJZPFpiWxl8v5Jdv80u38qeW+vXWPV7yLttD3XsQL5txuwteu1eCIRdx7Eg13mcSAhD0imszvZvwdhHGE8YU/CXoS9CfsQJhAmEkoIpYQyQjmhglBJmETYlzCZsB9hf8IUwlTCNMJ0wgzCAYSZhFmE2YQ5hLmEAwnzCPMJBxEOJhxCOJSwINlj52PnuyfLAJft4ZCNc8jGO2R7OmR7OWR7O2T7OGQTHLKJDlmJQ1bqkJU5ZOUOWYVDVumQTXLI9nXIJjtk+zlk+ztkUxyyqQ7ZNIdsukM2wyE7wCGb6ZDNcshmO2RzHLK5DtmBDtk8h2y+Q3aQQ3awQ3aIQ3aoQ7YgVs0x3pXqQpxUOCco1+4eC55WRWXVtUcMp9eYkK8pSNpcPg6Xf8XjcWmZPYG+2EWFLyrMXrD8KzN7w9JKmH2AvhirwhdxMwGVfxVxMxGVVlnclAB9sasGXyTiphSVf1T3lIHSqqC0yoG+2E2BL8rI5gpQ/iUorUpQWmSymQT0xe7h90WFtXlfTP6V2bQmY9JK2LT2A/pij/D7wiZt9ofkX8WqtKZA0ipbldZUoC/Ghd4XiVU2T4Pk3yo1zXREWhVVac0A+mJ82H1RVmXzAYj8S1SlNRORVpXJZhbQF3uG3BflSZtnA2wuTaY1B5BWUTKtuUBf7BVuX+R5Ox4PDG6z8dKaFzitRKWX1nygL/YOtS8SpZ7NBwXPv9U7WQ8OnFbR6rQOAfpin1D7Yshqmw8NbLNZndaCGHC+FrjHZUJINrTWcxnguJkBjvuYXYG+mKjEF8DxAQPs35o9gL4oUeILYD/IANvxZk+gL0qV+ALY3jPA9orZB+iLMiW+ANZrBsjLpgToi3IlJ9QA49cAy5+Ryr+oL//CMK/spXUYsB1q00CvAbLrq3aL4ddBLYxhfY22+5lo9dofpN3zQr7q35bHhQJ2z1eyd/9wYDwCfW3mh7zc2Hg5TKDcHBJyu3cXipdDlcTLEcB4AfraIPPP+tauU/baEfbflie89chHxKrXIx8Zq34GWc6ejVavO0X6b2HIT9G0Nh8pYPfhSvpNRwLbmkcBYxVYbowWX9gYRPni6JhMDIcpLly8eRTjzaMZbx4jxJvPRavX5vN0A8dSyHnT2nyMgN1HK4nVY4DxdSyQN4HlxmjxxXNA3jwuJhPDYYoLF28ey3jzOMabxwvx5vPR6v1LPN3A/gs5b1qbjxew+3glsXo8ML5OAPImsNwYLb54HsibJ8ZkYjhMceHizRMYb57IePMkId58IVq9x5OnGzSfTgo5b1qbTxKw+2QlsXoSML5OBvImsNwYLb54Acibp8RkYjhMceHizZMZb57CeHOREG++GK3eB8/TDZpPp4acN63NiwTsPk1JrC4CxtepQN4ElhujxRcvAnnztJhMDIcpLly8eSrjzdMYb54uxJsvRavPCuHpBs2nM0POm9bm0wXsPktJrJ4OjK8zgLwJLDdGiy9eAvLmmTGZGA5TXLh48wzGm2cy3jxLiDdfjlafp8TTDZpPi0POm9bmswTsPldJrJ4FjK+zgbwJLDdGiy9eBvLmOTGZGA5TXLh482zGm+cw3lwsxJuvRKvPnOPpBs2nC0LOm9bmxQJ2X6gkVhcD4+tcIG8Cy43R4otXgLx5XkwmhsMUFy7ePJfx5nmMN88X4s1Xo9XncvJ0g+bTxSHnTWvz+QJ2X6IkVs9HxheQN4HlxmjxxatA3rwwJhPDYYoLF29ewHjzQsabFwnx5mvR6rOLebpB8+nykPOmtfkiAbuvUBKrFwHjawmQN4HlxmjxxWtA3rw4JhPDYYoLF28uYbx5MePNS4R48/Vo9fnuPN2g+XRVyHnT2nyJgN1XK4nVS4DxdSmQN4HlxmjxxetA3rwsJhPDYYoLF29eynjzMsablwvx5hvR6m9g8HSD5tN1IedNa/PlAnZfryRWLwfG1xVA3gSWG6PFF28AefPKmEwMhykuXLx5BePNKxlvLhXizTej1d8J4ukGzaebQs6b1ualAnYvUxKrS5HtEiBvAsuN0eKLN4G8eXVMJobDFBcu3ryK8ebVjDevEeLNt6LV31Lj6QbNp1tDzpvW5msE7L5NSaxeA4yva4G8CSw3Rosv3gLy5nUxmRgOU1y4ePNaxpvXMd68Xog3345Wf2+Spxs0n+4MOW9am68XsPsuJbF6PTC+bgDyJrDcGC2+eBvImzfGZGI4THHh4s0bGG/eyHjzJiHefCda/U1enm7QfLon5Lxpbb5JwO57lcTqTcD4WgbkTWC5MVp88Q6QN2+OycRwmOLCxZvLGG/ezHjzFiHefDda/d1ynm7QfHog5Lxpbb5FwO7lSmL1FmR/DsibwHJjtPjiXSBv3haTieEwxYWLN29lvHkb483bhXjzPfrxyQL88XDIedPafLuA3Y8oidXbgfF1B5A3geXGaPHFe0DevDMmE8NhigsXb97BePNOxpt3CfHm+/Tj+wnwx4qQ86a1+S4Bux9XEqt3AePrbiBvAsuN0eKL94G8+b+YTAyHKS5cvHk3483/Md68R4g3P6Af31+AP54KOW9am+8RsPtpJbF6DzC+7gXyJrDcGC2++ADIm/fFZGI4THHh4s17GW/ex3jzfiHe/JB+fIoAfzwXct60Nt8vYPfzSmL1fuQ4GJA3geXGaPHFh0DeXB6TieEwxYWLNx9gvLmc8eaDQrz5Ef34VAH+eCnkvGltflDA7peVxOqDwPh6CMibwHJjtPjiIyBvPhyTieEwxYWLNx9ivPkw481HhHjzY/rxaQL88VrIedPa/IiA3a8ridVHgPH1KJA3geXGaPHFx0DefCwmE8NhigsXbz7KePMxxpsrhHjzE/rx6QL88VbIedPavELA7reVxOoKYHw9DuRNYLkxWnzxCZA3n4jJxHCY4sLFm48z3nyC8eaTQrz5Kf34DAH+eC/kvGltflLA7veVxOqTyPkDIG8Cy43R4otPgbz5dEwmhsMUFy7efIrx5tOMN58R4s3P6McPEOCPj0LOm9bmZwTs/lhJrD4DjK9ngbwJLDdGiy8+A/LmczGZGA5TXLh481nGm88x3nxeiDc/px+fKcAfn4WcN63NzwvY/bmSWH0eGF8vAHkTWG6MFl98DuTNF2MyMRymuHDx5guMN19kvPmSEG9+QT8+S4A/vgo5b1qbXxKw+2slsfoSML5eBvImsNwYLb74Asibr8RkYjhMceHizZcZb77CePNVId78kn58tgB/fBdy3rQ2vypg9/davmmDnHcF8iaw3BgtvvgSyJuvx2RiOExx4eLN1xhvvs548w0h3vyKfnyOAH/8FHLetDa/IWD3z1rOGAfG15tA3gSWG6PFF18BefOtmEwMhykuXLz5JuPNtxhvvi3Em1/Tj88V4I/fQs6b1ua3Bez+XcuZj8D4egfIm8ByY7T44msgb74bk4nhMMWFizffYbz5LuPN94R48xv68QMF+OOvkPOmtfk9Abv/1nIGDzC+3gfyJrDcGC2++AbImx/EZGI4THHh4s33GW9+wHjzQyHe/JZ+fJ4Af0SahJs3rc0fCtid0URHrH6IXK8C5E1guTFafPEtkDc/jsnEcJjiwsWbHzHe/Jjx5idCvPkd/fh8Af7IDDlvWps/EbA7S0msfgKMr0+BvAksN0aLL74D8uZnMZkYDlNcuHjzU8abnzHe/FyIN7+nHz9IgD9yQs6b1ubPBexuqiRWPwfG1xdA3gSWG6PFF98DefPLmEwMhykuXLz5BePNLxlvfiXEmz/Qjx8swB8tQs6b1uavBOxuqSRWvwLG19dA3gSWG6PFFz8AefObmEwMhykuXLz5NePNbxhvfivEmz/Sjx8iwB9tQs6b1uZvBexuq2VMDbnOD8ibwHJjtPjiRyBvfh+TieEwxYWLN79jvPk9480fhHjzJ/rxQwX4o0PIedPa/IOA3R21tHGA8fUjkDeB5cZo8cVPQN78KSYTw2GKCxdv/sh48yfGmz8L8ebP9OMLBPijS8h509r8s4Dd6yiJ1Z+B8fULkDeB5cao8QWQN3+NycRwmOLCxZu/MN78lfHmb7FIjSsK9l3bCC6PfovJcmY82GWepMwbJbHmPYYtG7Gk7Tbdi5P3TVl+2L8DIlVlpAPhj1h1uYiwZ5B5h7QxN5nOn5TmX4S/bXkn/GMNJ3LKIEQJMUImIYuQTWhCyCE0JTQjNCe0ILQktCK0JrQhtCW0I7QndCB0JHQidCZ0IaxDWDezKpN4flt9ciI1ZX85ZH87ZCsdsn8cMmufX5bhkEUdsphDlumQZTlk2Q5ZE4csxyFr6pA1c8iaO2QtHLKWDlkrh6y1Q9bGIWvrkLVzyNo7ZB0cso4OWSeHrLND1sUhW8chWzcp4xe6Xv4dWJf+CUirotJecfMXUK9ujdRGCmKz9cXfkPyr8uvK4GnlJfPP/AP0Rfcw+6JgtZ7GJhggrTiz2WQESSuvRv6ZaCbOFz3C6Yu4T08TS9Pmwso1bDaZ6aWVcOSfyQL6omfYfJFw6mmyU7e5qBabTZNU0yqqNf9MDtAXueHxRV4depqmqdhcVKfNplnD0yqrJ/9Mc6AveoXBF0X16mlaNMzmeANsNi0bkla8QflnWgF90Xvt+mJIA/U0reuzuaDBNps2daZVUJlC/pm2QF+st7Z8UZSSnqZd7TYnUrTZtK8lreLKlPPPdAD6ok/j+yKehp6mo8vmeFo2m05rpmXSzD/TGeiLvo3pi/K09TRdatqcH8Bmsw5LK68yUP6ZdYG+6KdkbgI4PmCA/VvTAzg30V+JL4D9IANsx5teQF8MUOILYHvPANsrpg/QF+sr8QWwXjNAXjb9gb7YQMgXMbAvgPFrgOXPIPNPeq6wGy6t1XOFXSnouhG6E3oQehJyCb0IvQnrEfoQ+hL6EfoTBhDWJ2xA2JAwkDCIsBFhMCFOMIQ8Qj6hgDCEUEgoIiQIxYSNHXOFXR1zOt0csu4OWQ+HrKdDluuQ9XLIejtk6zlkfRyyvg5ZP4esv0M2wCFb3yHbwCHb0CEb6JANcsg2csgGO2Rxh8w4ZHkOWb5DVuCQDXHICh2yIocs4ZAVO2QbZ8rPFfKYDcr1XQH9DG+usBuwz7KxkrnC7pD8q/Jrj+BprZ4r7An0xSZK5gpzgXOFvYBzhb2BvhiqZK5wPeBcYR/gXGFfoC82VTJX2A84V9gfOFc4AOiLzZTMFa4PnCvcADhXuCHQF5srmSscCJwrHAScK9wI6IthSuYKBwPnCuPAuUID9MVwJXOFecC5wnzgXGEB0BdbKJkrHAKcKywEzhUWAX2xpZK5wgRwrrAYOFe4MdAXI5SMwwPHBwywf2uGAsfht1LiC2A/yADb8WZzoC+2VuILYHvPANsrZgugL0Yq8QWwXjNAXjZbAX2xjZK5QmD8GmD5M9somivMwKW1eq5wEwq6oYRNCZsRNrdtGcJwwhaELQkjCFsRtiaMJGxD2JawHWF7wg6EHQmjCKMJOxF2Jowh7EIYS9iVsBthd8IehHGE8Y65wk0cczpDHbJNHbLNHLLNHbJhDtlwh2wLh2xLh2yEQ7aVQ7a1QzbSIdvGIdvWIdvOIdveIdvBIdvRIRvlkI12yHZyyHZ2yMY4ZLs4ZGMdsl0dst0cst0dsj0csnEO2fhM+blCHrOB54GAc4VDgX2WPZTMFW4KnCvcDDhXuDnQF+OUzBUOA84VDgfOFW4B9MV4JXOFWwLnCkcA5wq3AvpiTyVzhVsD5wpHAucKtwH6Yi8lc4XbAucKtwPOFW4P9MXeSuYKdwDOFe4InCscBfTFPkrmCkcD5wp3As4V7gz0xQQlc4VjgHOFuwDnCscCfTFRyVzhrsC5wt2Ac4W7A31RomSucA/gXOE44FzheKAvSpWMwwPHBwywf2vGA8fhy5T4AtgPMsB2vNkb6ItyJb4AtvcMsL1iJgJ9UaHEF8B6zQB52ZQBfVGpZK4QGL8GWP5MpaK5wu64tFbPFe5JQbcXYW/CPoQJhImEEkIpoYxQTqggVBImEfYlTCbsR9ifMIUwlTCNMJ0wg3AAYSZhFmE2YQ5hLuFAwjzCfMJBjrnCPR1zOns5ZHs7ZPs4ZBMcsokOWYlDVuqQlTlk5Q5ZhUNW6ZBNcsj2dcgmO2T7OWT7O2RTHLKpDtk0h2y6QzbDITvAIZvpkM1yyGY7ZHMcsrkO2YEO2TyHbL5DdlCm/Fwhj9nA493AucK9gH2WuUrmCvcGzhXuA5wrnAD0xYFK5gonAucKS4BzhaVAX8xTMldYBpwrLAfOFVYAfTFfyVxhJXCucBJwrnBfoC8OUjJXOBk4V7gfcK5wf6AvDlYyVzgFOFc4FThXOA3oi0OUzBVOB84VzgDOFR4A9MWhSuYKZwLnCmcB5wpnA32xQMlc4RzgXOFc4FzhgUBfHKZkrnAecK5wPnCu8CCgLxYqGYcHjg8YYP/WzAOOwx+uxBfAfpABtuPNwUBfHKHEF8D2ngG2V8wCoC+OVOILYL1mgLxsDgf64iglc4XA+DXA8meOEpwr7LlmHpp4gGtp1KdrgNSuiq5hd9qpXR115GGaqV0TdfojrdSujdbi2zRSuy5aazlJObXro3WUuRRTuyFaZ/lNKbUbo/XEQgqp3RStN64anNqyaANitIGp3dyQtBqY2i0NS6tBqd3a0LQakNptDU+r3tRuTyWtelK7I7W06kztzlTTqiO1u1JPq9bU7k4nrVpS+196aTlTuyfdtByp3Zt+Wmukdl+QtHyp3R8srRqpPRA0LZba8uBprU7tQURaydQewqS1KrWHUWlRao/g0lq9Jupg6lwcQjiUsIBwGGEh4XDCEYQjCUcRjiYcQziWcBzheMIJhBMJJxFOJpxCWEQ4lXAa4XTCGYQzCWcRziacQ1hMOJdwnmNN1MGOtSuHOGSHOmQLHLLDHLKFDtnhDtkRDtmRDtlRDtnRDtkxDtmxDtlxDtnxDtkJDtmJDtlJDtnJDtkpDtkih+xUh+w0h+x0h+wMh+xMh+wsh+xsh+wch2yxQ3auQ3ZeZoPWRP3r+yZB+9pnNva4x7+4DxXUF2etnTGof2VfL6gvzl6b44H/sj5pUF+cs/bHZv81feegvlgclnHyf0EfP6gvzg3XnIXqsYigvjgvjPNHSsdMgvri/PDO5akb2wnqiwvCPq+qaAwqqC8uVDLH/QjQ5oOBe5EOAa6JukjJXqRDgXuRFgD3Ih0G9MUSJXuRFgL3Ih0O3It0BNAXFyvZi3QkcC/SUcC9SEcDfXGJkr1IxwD3Ih0L3It0HNAXlyrZi3Q8cC/SCcC9SCcCfXGZkr1IJwH3Ip0M3It0CtAXlyvZi7QIuBfpVOBepNOAvrhCyV6k04F7kc4A7kU6E+iLK5XsRToLuBfpbOBepHOAvliqZC/SYuBepHOBe5HOA/riKiVjIMB5eQOcVzZnA9f5X63EF8D5RwOcPzPnAn1xjRJfAOdZDHCewFwA9MW1SnwBHE82wPFQswToi+uU+AI4bmaA4z7mUqAvrlfiC+D4gAH2b80VQF/coMQXwH6QAbbjzVVAX9yoxBfA9p4BtlfMtUBf3KTEF8B6zQB52dwA9MUyJfuIgfFrgOXPIPMvGql5ZYDz8I8YTtfcZDrnU9BdQLiQcBFhCeFiwiWESwmXES4nXEG4krCUcBXhasI1hGsJ1xGuJ9xAuJFwE2EZ4WbCLYRbCbcRbifcQbiTcBfh7szIGvtrznfsg7jAIbvQIbvIIVvikF3skF3ikF3qkF3mkF3ukF3hkF3pkC11yK5yyK52yK5xyK51yK5zyK53yG5wyG50yG5yyJY5ZDc7ZLc4ZLc6ZLc5ZLc7ZHc4ZHc6ZHc5ZHdnyp85zGM28Jo/4DqfC4Djjc8pWedzIXCdz0XAdT5LgL54Xsk6n4uB63wuAa7zuRToixeUrPO5DLjO53LgOp8rgL54Uck6nyuB63yWAtf5XAX0xUtK1vlcDVzncw1wnc+1QF+8rGSdz3XAdT7XA9f53AD0xStK1vncCFzncxNwnc8yoC9eVbLO52bgOp9bgOt8bgX64jUl63xuA67zuR24zucOoC9eV7LO507gOp+7gOt87gb64g0l4/DA8QED7N+aF4Dj8G8q8QWwH2SA7XjzMtAXbynxBbC9Z4DtFfMa0BdvK/EFsF4zQF42bwJ98Y6SuUJg/Bpg+TPI/MtIluEHkunZf6/L5ijWYfdd2H1ndt+J3Xdk9x3YfXt2347dt2X3bdh9a3bfit23ZPct2H1zdt+M3Tdl9znsvgm7z2b3Wew+k8/VsPsou89g9xF2/0+s+n4lu/+b3f/F7v9k9xuzdIrZfYLdF7H7QnY/hN0XsPt8dp/H7g27j7P7wex+I3Y/iN0PZPcbsvsN2P367H4Au+/P7vux+77svg+7X4/d92b3vdh9Lrvvye57sPvu7L4bu+/K7sez+3Hsfg92vzu7343d78rux7L7Xdj9GHa/M7vfid2PZvej2P2O7H4Hdr89u9+O3W/L7rdh9yPZ/dbsfit2P4Ldb8nut2D3w9n9MHa/ObvfjN1vyu6HsvtN2P1B7J5/o5V/w5V/45V/A5Z/I5Z/Q5Z/Y5Z/g5Z/o5Z/w5Z/45Z/A5d/I5d/Q5d/Y5d/g5d/o5d/w5d/45d/A5h/I5h/Q5h/Y5h/g5h/o3giu+ffOObfQObfSObfUObfWD6P3fPzIPl5kfw8SX7eJD+Pkp9Xyc+z5Odd8vMw+XmZ/DxNft4mP4+Tn9fJz/Pk533y80D5eaH8PFF+3ig/j5SfV8rPM+XnnfLzUBeye36eKj9vlZ/Hys9r5ee53s3u+XoBvp6Arzfg6xH4egW+noGvd+DrIfh6Cb6egq+34Osx+HoNvp6Dr/fg60H4ehG+noSvN+HrUfh6Fb6eha934eth+HoZvp6Gr7fh63H4eh2+nsdb7/M/+nsP4V7CfYT7CQ8QlhMeJDxEeJjwCOFRwmOEFYTHCU8QniQ8RXia8AzhWcJzhOcJLxBeJLxEeJnwCuFVwmuE1wlvELIiVfDasvzKSP4dlvwbD3aZjIhMOxz93Qrrkxp6Bkjtnsw1bE47tXszHfmXZmr3ZTp9kVZq92fW4tc0Unsgs9YyknJqyzPrKG8ppvZgZp1lN6XUHsqsJw5SSO3hzHpjqsGpPZLZgPhsYGqPNiStBqb2WMPSalBqKxqaVgNSe7zhadWb2hOppFVPak+mlladqT2Valp1pPZ06mnVmtoz6aRVS2rPppeWM7Xn0k3Lkdrz6ae1RmovBEnLl9qLwdKqkdpLQdNiqb0cPK3Vqb2CSCuZ2quYtFal9hoqLTv2mynTHkO3Gwfg0opnMB3bJu/fpHx4i/A24R3Cu4T3CO8TPiB8SPiI8DHhE8KnhM8InxO+IHxJiEhvgngT6Kw2yXS+ojS/JnxD+JbwHeF7wg+EHwk/EX4m/EL4lfAb4XfCH4Q/M6tstnZ6C8ttehk+2dcO2TcO2bcO2XcO2fcO2Q8O2Y8O2U8O2c8O2S8O2a8O2W8O2e8O2R8O2Z+Z1WXEuzIFy0zQSZSvAGlVLcKvrPwaqNc3Chbh01X+DS7/ir/FpWW+A/riWxW+qDDfw/KvzPwASythfgT64jsVvoibn1D5VxE3P6PSKoubX4C++F6DLxJx8ysq/6ju+Q2UVgWl9TvQFz8o8EWZ3UAHyr8EpfUnsNPwDXBhxo9KFskA6zUD5GXzPdAXPylZJAOMXwMsfwadfxlr8kmgxbx2UuOrTGe6gcrNX/J2B1oQfY+Q3X83ht0BFr/fK2T3ysaxO+0NBPcJ2f1PY9md5iaM+4XstrPUjWR3WhtuHhCyO6MR7U5n09JyIbujjWt3yhu/HhSyO9bYdqe4ye8hIbszG93u1DZKPixkd9basDuFzaaPCNmdvXbsbvDG4keF7G6ytuxu4Obsx4Tszll7djdog/sKIbubrk27G3CYweNCdjdbu3bXeyDEE0J2N1/bdtdzqMaTQna3WPt213mAylNCdrcMg911HELztJDdrcJhd60H+TwjZHfrsNhdy6FNzwrZ3SY8djsPvnpOyO62IbLbdXjY80J2twuX3WscFPeCkN3tw2a377C9F4Xs7hA+u2scWPiSkN0dw2g3O5zyZSG7O4XT7tUHfL4iZHfn0NpddUjqq0J2dwmx3Xb9zWtCdq8TUrtXH+gkZPe6wnbHg13mLSG7u4Lt9i7HWo5//ea+oL7o1ni+iAexWsMmxKC+6N7YvoinZ7WGzZJBfdFj7fginqrVGjZ1BvVFz7Xpi3jDrdaw+TSoL3LXvi/iDbFawybZoL7oFRZfxOu2WsNm3qC+6B0uX8Rrs1rDpuOgvlgvjL6Ir2m1hs3RQX3RJ7y+iHOrNWziDuqLvmH3RdWF3GxugGvOzd/APRT9lPgCuIbbANdFG77WOKgv+ivxBXCdsQGu3TUxoC8GKPEFcC2sAa4vNdlAX6yvxBfA9ZoGuAbSNAX6YgMlvgCuKTTAdXqmBdAXGyrxBXDdmwGuJTOtgb4YqMQXwLVZBrjeybQD+mKQEl8A1w8Z4Joc0xHoi42U+AK4xsUA142YLkBfDFbiC+A6DANc22C6An0RV+IL4Ly8Ac4rmx5AXxglvgDOPxrg/JnpBfRFnhJfAOdZDHCewPQB+iJfiS+A48kGOB5q+gN9UaDEF8BxMwMc9zEbAH0xRIkvgOMDBti/NYOAvihU4gtgP8gA2/EmDvRFkRJfANt7BtheMflAXySU+AJYrxkgL5tCoC+KG8kXgc9FA853A7nAAMuyKVYSF28B11v8BVwvgFx7ME9JXCDb8cj28TygXvOV+GJ9oblM5Fxc0LQOUuKLgUJzNsg5h6BpHazEF4PDOTZt5gP1OkSJL/4GtqOAXGCAZdkgfWH3dTaNVH+Pxv7btkVXJu//Tt7ba2Vm9TPcZ/Fgl7Ef0vlaYI/pESHfU2xtXilg95Fa1pUC29n/AOMeWG6MFl+8DfSF/UKsRAyHKS5cvPkP402bBx5vZmRVP4P0mf342DcC/HFMyHlzlc1Z+HSP1bIGHBhf0SycXsByY7T44h0gb8ayZGI4THHh4s1oVjVvxhhvZgrxpv1g47cCvHlCyHnT2pwpwJsnatmvAYyvLCBvAsuN0eKLd4G8mZ0lE8NhigsXb2Yx3sxmvNlEiDffy6z+xipPN2g+nRJy3rQ2NxHgzUVa9lYB4ysHyJvAcmO0+OI9IG82zZKJ4TDFhYs3cxhvNmW82UyIN+2Hwb8X4M3TQ86b1uZmArx5hpZ9kMD4ag7kTWC5MVp88T6QN1tkycRwmOLCxZvNGW+2YLzZUog3PyCf/SDAm2eHnDetzS0FePMcLXuWgfHVCsibwHJjtPjiAyBvts6SieEwxYWLN1sx3mzNeLONEG9+SD77UYA3zws5b1qb2wjw5vlazhcAxldbIG8Cy43R4osPgbzZLksmhsMUFy7ebMt4sx3jzfZCvPkR+ewnAd68KOS8aW1uL8CbS7ScBQKMrw5A3gSWG6PFFx8BebNjlkwMhykuXLzZgfFmR8abnYR482Py2c8CvHlpyHnT2txJgDcv03JuDzC+OgN5E1hujBZffAzkzS5ZMjEcprhw8WZnxptdGG+uI8Sbn5DPfhHgzStDzpvW5nUEeHOpljO2gPG1LpA3geXGaPHFJ0De7JolE8NhigsXb67LeLMr481uQrz5KfnsVwHevCbkvGlt7ibAm9dqOQ8PGF/dgbwJLDdGiy8+BfJmjyyZGA5TXLh4szvjzR6MN3sK8eZn5LPfBHjzhpDzprW5pwBv3qjl7EpgfOUCeRNYbowWX3yG/PZblkwMhykuXLyZy3izF+PN3kK8+Tn57HcB3rw55Lxpbe4twJu3aDlnFhhf6wF5E1hujBZffI78Hl2WTAyHKS5cvLke480+jDf7CvHmF+SzPwR48/aQ86a1ua8Ab96h5UxoYHz1A/ImsNwYLb74Asib/bNkYjhMceHizX6MN/sz3hwgxJtfks/+FODNu0POm9bmAQK8+T8lsToAGF/rA3kTWG6MFl98CeTNDbJkYjhMceHizfUZb27AeHPDrEiNK+rzXeC9csBysGGWjvKK/F6y1HeHgvr1PiXc0QOYf1LfHQrqi/uV+KIXMP+kvjsU1BcPKPFFH2D+Ib87dB/QF8u1nB8NbB8CucAAy7JZLtC+iSXTs/8eyNo3AyLV928mz4G0zZxB9bR14sEu81kGrkxsBCwTGcm8sn9turnJe5uHbVge9mf51o/df5wR/vuBhMFZbrsGZ+myxW9XPKuq/GazMuu6hkUg5SUvw/E76HGV/hE8N6N17BfBcpZ3GR8PwYkoDuzkGmCny9rdJFJVkCPCBSwjgi9g/AqadmmirKygwhRL5kFcqMOM1nMjJXpmRsJdprwrg9nfNHmfR3mcTyggDCEUEooICUIxYWMbnBbUUHPWMujMzM8KdWYa74bnxSZJ5h6alcwQr1ll/+MdnwIxwQxLk9XzkqxuNgHWEEOFHImuFZE2b+pIqzReVj7ElBaWF5mKkiFE78X5xuSVFJYUluYlKitKh5jEkASlWVaSl6CfyyspMxXxksIKW5aaRqoDjF/ooNs0C88y9tosS1DhzbLw6W4OLAxSdm/O2omgdEXmCocmdUUFrJcu0kfDwAXfI36bbq9I49achQprzuHJsryFv+Ycnqw5uWyL5CAFv9C1aSGwNh0OLKhbKKlNkTZvqbQ23VKoNh2RJajwCIHadKuQ16bW7q2U1KZbJHVF16ZIH20tVJtuvRZq06Jw16belcfzYmSyLG/jr03tf/ztUwBdcxYBClJFZdU1Elgot1FScyJt3palZRL5eXlF+fa5RHncFJSX5SXy8spLC+Jl8ZKyvIriAlNcWZBXkF9WXlZKaZaYynhlSVlxZaJKr8asObcVqjm3yxJUeDuBmnP7kNec1u7tldSc2yR1Rae7g1Btt0Oylm/M2i6hsLbbMVn+Rvlrux2TtR2Xjcpak8HQNWACWAPuCCSAUUpqQKTNo5XWgKOFasCdsgQV3kmgBtw55DWgtXtnJTXgqKSu6HTHCNWAY9ZCDViscPR0l2T5G+uvAXdxjJ6ObYTR02Lg6OkuQAIYq6QGRNq8q9LR012FasDdsgQV3k2gBtw95DWgtXt3JTXg2KSu6NFTpI/2EKpN90iOnvILTVwZQF/lCZE1uvwPBfg+vyg/v9RUJOryTZjWjGupSJFLXTdWUh4ba6A7aH4Cl0uaUUpsBi47NkP+H9pcoIR3NgLyzrgsbP3stQfGOTqC6PbWeIDu3lJ4b7lya6arxcp67u2MuWsPTSZ7Znwtz8SzsPt12hH2zKqZ5+h4Q5bj9SP//zhmAyU2R4E2b6jE5hjQ5oFKbEa2kwY1ks3xYJfZCJh/n2boaLcPjujQM65ET6NEzzwleuYr0bNAiZ5DlOhZqETPIiV6JpToWaxEz42V6LmJEj2HKtFzUyV6bqZEz82V6DlMiZ7Dlei5hRI9t1Si5wglem6lRM+tleg5Uome2yjRc1slem6nRM/tlei5gxI9d1Si5ygleo5WoudOSvTcWYmeY5TouYsSPccq0XNXJXrupkTP3ZXouYcSPccp0XO8Ej33VKLnXkr03FuJnvso0XOCEj0nKtGzRImepUr0LFOiZ7kSPSuU6FmpRM9JSvTcV4mek5XouZ8SPfdXoucUJXpOVaLnNCV6Tlei5wwleh6gRM+ZSvScpUTP2Ur0nKNEz7lK9DxQiZ7zlOg5X4meBynR82Aleh6iRM9Dlei5QImehynRc6ESPQ9XoucRSvQ8UomeRynR82gleh6jRM9jleh5nBI9j1ei5wlK9DxRiZ4nKdHzZCV6nqJEz0VK9DxViZ6nKdHzdCV6nqFEzzOV6HmWEj3PVqLnOUr0XKxEz3OV6HmeEj3PV6LnBUr0vFCJnhcp0XOJEj0vVqLnJUr0vFSJnpcp0fNyJXpeoUTPK5XouVSJnlcp0fNqJXpeo0TPa5XoeZ0SPa9XoucNSvS8UYmeNynRc5kSPW9WouctSvS8VYmetynR83Ylet6hRM87leh5lxI971ai5/+U6HmPEj3vVaLnfUr0vF+Jng8o0XO5Ej0fVKLnQ0r0fFiJno8o0fNRJXo+pkTPFUr0fFyJnk8o0fNJJXo+pUTPp5Xo+YwSPZ9VoudzSvR8XomeLyjR80Uler6kRM+Xlej5ihI9X1Wi52tK9HxdiZ5vKNHzTSV6vqVEz7eV6PmOEj3fVaLne0r0fF+Jnh8o0fNDIT2jYD0/YmkF/XbvoCwdNn8MtPmzDB3l8ZOIDj0/VaLnZ0r0/FyJnl8o0fNLJXp+pUTPr5Xo+Y0SPb9Voud3SvT8XomePyjR80clev6kRM+flej5ixI9f1Wi529K9PxdiZ5/KNHzTyV6/qVEz7+V6LlSiZ7/KNEzomTcJkOJnlElesaU6JmpRM8sJXpmK9GziRI9c5To2VSJns2U6NlciZ4tlOjZUomerZTo2VqJnm2U6NlWiZ7tlOjZXomeHZTo2VGJnp2U6NlZiZ5dlOi5jhI911WiZ1clenZTomd3JXr2UKJnTyV65irRs5cSPXsr0XM9JXr2UaJnXyV69lOiZ38leg5Qouf6SvTcQImeGyrRc6ASPQcp0XMjJXoOVqJnXImeRomeeUr0zFeiZ4ESPYco0bNQiZ5FSvRMKNGzWImeGyvRcxMleg5VouemSvTcTImemyvRc5gSPYcr0XMLJXpuqUTPEUr03EqJnlsr0XOkEj23UaLntkr03E6Jntsr0XMHJXruqETPUUr0HC2kZxSs505Mz6Bn0OyZpcM3OyspQ2OU6LmLEj3HKtFzVyV67qZEz92V6LmHEj3HKdFzvBI991Si515K9NxbiZ77KNFzghI9JyrRs0SJnqVK9CxTome5Ej0rlOhZ2Uh97KD94r5AmycpGVfYFziuME7JuMJkJXGznxI991ei5xQlek5Vouc0JXpOV6LnDCV6HqBEz5lK9JylRM/ZSvSco0TPuUr0PFCJnvOU6DlfiZ4HKdHzYCV6HqJEz0OV6LlAiZ6HKdFzoRI9D1ei5xFK9DxSiZ5HKdHzaCV6HqNEz2OV6HmcEj2PV6LnCUr0PFGJnicp0fNkJXqeokTPRUr0PFWJnqcp0fN0JXqeoUTPM5XoeZYSPc9Wouc5SvRcrETPc5XoeZ4SPc9XoucFSvS8UImeFynRc4kSPS9WouclSvS8VImelynR83Ilel6hRM8rlei5VImeVynR82olel6jRM9rleh5nRI9r1ei5w1K9LxRiZ43KdFzmRI9b1ai5y1K9LxViZ63KdHzdiV63qFEzzuV6HmXEj3vVqLn/5ToeY8SPe9Voud9SvS8X4meDyjRc7kSPR9UoudDSvR8WEjPqE/PoPugs4A2P6LE5mygzY8qsbkJ0ObHlNicA7R5hRKbmwJtflyJzc2ANj+hxObmQJufVGJzC6DNTymxuSXQ5qeV2NwKaPMzSmxuDbT5WSU2twHa/JwSm9sCbX5eic3tgDa/oMTm9kCbX1RicwegzS8psbkj0OaXldjcCWjzK0ps7gy0+VUlNncB2vyaEpvXAdr8uhKb1wXa/IYSm7sCbX5Tic3dgDa/pcTm7kCb31Zicw+gze8osbkn0OZ3ldicC7T5PSU29wLa/L4Sm3sDbf5Aic3rAW3+UInNfYA2fwS02c6NZybTWp/Zn5HMg1jy/+1csp1btXONdu7NzkXZuRk7V2HH7u1Yth3btWOdduzPjoXZsSE7VmLHDmxf2vYtbV/L9j1sW9y2TW1bzbZdbF1u6zbL9bkEywU2NmxZsXlnz0TvR+hPGMD0vCejWvcNCBsSBhIGETYiDLZ5RDCEPOtHQgFhCKGQUERIEIoJGxM2IQwlbErYjLB50m/DCVsQtiSMIGxF2JowkrANYVvCdoTtCTsQdiSMIowm7ETYmTCGsAthLGFXwm6E3Ql7EMYRxhP2JOxF2JuwD2ECYSKhhFBKKCOUEyoIlYRJhH0Jkwn7EfYnTCFMJUwjTCfMIBxAmEmYRZhNmEOYSziQMI8wn3AQ4WDCIYRDCQsIhxEWEg4nHEE4knAU4WjCMYRjCccRjiecQDiRcBLhZMIphEWEUwmnEU4nnEE4k3AW4WzCOYTFhHMJ5xHOJ1xAuJBwEWEJ4WLCJYRLCZcRLidcQbiSsJRwFeFqwjWEawnXEa4n3EC4kXATYRnhZsIthFsJtxFuJ9xBuJNwF+Fuwv8I9xDuJdxHuJ/wAGE54UHCQ4SHCY8QHiU8RlhBeJzwBOFJwlOEpwnPEJ4lPEd4nvAC4UXCS4SXCa8QXiW8Rnid8AbhTcJbhLcJ7xDeJbxHeJ/wAeFDwkeEjwmfED4lfEb4nPAF4UvCV4SvCd8QviV8R/ie8APhR8JPhJ8JvxB+JfxG+J3wB+FPwl+EvwkrCf8QLBlkEKKEGCGTkEXIJjQh5BCaEpoRmhNaEFoSWhFaE9oQ2hLaEdoTOhA6EjoROhO6ENYhrEvoSuhG6E7oQehJyCX0IvQmrEfoQ+hL6EfoTxhAWJ+wAWFDwkDCIMJGhMEES3KGkEfIJxQQhhAKCUWEBKGYsDHBfqfefgPefl/dfrt81XfBCfZ71vZb0fY7zPYbx/b7wfbbvPa7t/absvZ7rfZbqPY7o/Ybnvb7mPbbk/a7jvabifYbgvb7fPbbd/a7cvabbfZ7aPZbY/Y7XvYbWfb7U/bbTva7SfabRPZ7P/ZbOhMJ9hsw9vsq9tsl9rsg9psb9nsW9vsO9tsJ9lsC9px+ewa+PV/ent1uz0W3Z47b87ztWdn2HGp7xrM9P9meTWzP/bVn6trzau1ZsPacVXuGqT0f1J69ac+1tGdGLiTYsw7tOYL2jD57/p09W86e22bPRLPnjdmzvOw5WfYMKnu+kz07yZ5LZM/8sefp2LNq7Dkw9owVe36JPRvEnrthz7Sw50XYsxjsOQf2DAG7P9/ufbf7yu2e7YsJdq+x3cdr98ja/ad2b6fdN2n3JNr9fnYvnd2nZveA2f1Vdu+S3Rdk99zY/Sx2r4jdh2H3ONj9A3Ztvl33bteU2/Xadi20XWds1/DaOsWuPbXrOu2aSbse0a71s+vo7Bo1u/7Lroey64Psehm7fsSup7DrC+x8u51/tvOxdn7SztfZ+Ss7n2PnN+x4vx3/tuPBdnzUjhfa8TM7nmTHV+x4g+1/2/6o7Z/Z/optv9v2rG3f2faOrf8tz3hXO3bfLfm3ZPbsiqkzZufOnp5bUl6ee+Dk2fvmTp9bMbNyynRL+ZFc9o5X74+aM2XK5MrJFTNzy6dXzMqdNn127tSS2WX75s4tmTKnInfyNJvMtIpZtg5ZRaLe1Tv5d6eZ0+dOnjYpd9rqhCZPK5syZ9bk6dNyK0smT6koX/VzGdVvdk3+LSuZMmWVrrNmVcycPWFqybwJpZNnT5g1+SBb0a2K6hRfKUj9lcLUXylO/ZVNUn9lROqvbJ36Kzuk/sqo1F8Zk/orY1N/Ze/UX5mQ+iulqb9SnvorU1N/ZXrqr8xJ/ZUDU3/l8NRfOTL1V05K/ZVTUn/ltNRfOSP1Vy5I/ZWLUn/l8tRfuTL1V65J/ZXrUn/lttRfuSP1V+5O/ZV7Un/lkdRfeSz1V55O/ZVnU3/lTfZKv+TfneaUTplcllteMrskd9YUanDYlse0/l7Dg7U33gr09tuB3v4+Wv12X+/tZFtnRlUqXhNpzebOj9GUc+qVzOpXOiT/7ki6lEyqWNUqo5bYrNkls1c9+w57tqGNv+5Zqb1jM69H8rkdql9dNYhjr+EzZ5bMJ63KK+blTp8zO3d6ZW7p9DnTymfxF8ek++K4dF+cmO6Ll0TSz58r0v3Ra9N98fEA2r4R4N130lX4o5RfTEZv33RfHJjui/npvrhxui+OSPfFo9iLDXZl8t3j0v3RU9J98bo0tO2TfHcUe7fXmu/OmlM6e2ZJ2ezaE9iFJdA++Xdbt77eK7ulaqj34l6p/9aEdH/rgEjqmdov+e6mDdfTe2VYqnp6L+4YQM+dU9dzbLp6lqehZzz57k7s3ZQKqZfArg031Htlj1QN9V7cJ/XfKkn3t2ZFUs/UotQLaVG6hbQoQCEtSr2QFqVbSIsCFNJhQQvpsNQL6bB0C+mw1AvpsHQL6bAAhXRk0EwdmXqmjkw3U0emnqkj083UkQEydXTqkT863cgfHSDyR6ce+aPTjfzRASJ/XNBCOi71Qjou3UI6LvVCOi7dQjouQCGdmHohnZhuIZ0YoJBOTL2QTky3kE4MUEgnBy2kk1MvpJPTLaSTUy+kk9MtpJMDFNIZQTN1RuqZOiPdTJ2ReqbOSDdTZwTI1EOS76bdJfUSSKFL6r2ScpfUezGFLqn3SspdUu/FdLqkC1Kn0wXp0umCAHS6IHU6XZAunS4IQKfHBY3841KP/OPSjfzjUo/849KN/OMCRP6i1AvponQL6aIAhXRR6oV0UbqFdFGAQro4aCFdnHohXZxuIV2ceiFdnG4hXRygkC4JmqlLUs/UJelm6pLUM3VJupm6JECmLk098pemG/lLA0T+0tQjf2m6kb80QOQvC1pIl6VeSJelW0iXpV5Il6VbSJcFKKR3pl5I70y3kN4ZoJDemXohvTPdQnpngEK6PGghXZ56IV2ebiFdnnohXZ5uIV0eoJCuCJqpK1LP1BXpZuqK1DN1RbqZuiLdTG2WfCgrmUAOSyA3Ato2lDAl2Sxxtr6l+t/eD+dU/3Zz/mxSbmWxpCgjKWvCcmnVO77fWfVOUhZjssykLJPJspKyLPazOfD8iBd6W6Kg6cZNQU7SDmy6cWPTbYFPd9UcX8tIdZ7nst9pynzQKnmfAbSJ/3ZGEt7vePJMdt+FPes95+VHdvK+BXvfi61WdbyX43uvFXumGXuvhe8979+er7PYe3YrnRcDns5C5S3RPFIdKxGmb8Snr3dxn2bD9Ykbm2fdk2lNqpi9eofCjhVTSytmztp38ozdq5bpZTBlPQO6+AzIiNQ0ZiV7hpMYv485ZLns/Rz2DNLwDJahXtrZPp1ymF7A387jpBxheRdx5AHPG6tPM7w++TUqjgbo04zpgw+SKvIUsDPOyX5lBEvKfsKJ+vKqVWRNEhKqJFaV7WY+fbx/e7/3n86No7PVx89xzdlzsZDo6Ml4hSMRg6saksm0VjemI9X9aPu7TfC/m5/B8t9rOHl6eL+XyZ55nj07PHnfkv0/bxjn+GRSvJgRWbPD4f27KdOxCdPD+ytVhzbx6dPEkRfwDkG8isslGmg8XrJqyeNM9ow3JtMmsublij3eUbJXS5ZXwvXqqhho3gDbvGd2qce25j7beDvFs82zqbmsbVIdrnxXh8vTvwXLM++Z8fXkWcta8ozHb3N27+WZgG15vKMITHdVnrX25Rmva7w8854pqSfPWteSZ7zz6OWV92yUPdfS924T9oy9Vibvved4/SPZB+Dc6dka8dka8ekq4zNTkGofoBXTpzVcn6p49n4D2Va36bYRyD+bbluhfGiHT3dVn8UbXfVi1PudNsy3HVhZQNnEf9sbM/B+x5Nnsvv57FnvOS8/vDLr6d6KPcMHktr53vP+3ZblwQHsPT9HNGf5wttXEj7PiNTkwlz277ZMR0/WmumYyXTz7FrIZBKDqLxf5m9b83aF98xi9qy3q6ol+/8mzJ4cn0xqIKyutnU205H3j7y/Av2VVfo09enTtI784f0R/4ColfEy4v1tw+zyZF754n1oL1aaMpm/rcfHtFoxmVcO+O97beA2TOblcVsm8+zkv59KORGot+ssJ7y94SonAvoUuPTJ9OnDB9Kzfc9472ayZy5N/nW1x2Tq+6p+l/d7/r5Ja6aj98yVdejo4k9Xv6uVLw0h21b5qK3PtkyHbd4z1/n04pdMnVPVfpFox/G6NzNSk8e47d4zy1g+3ZK85/HN65kHHf/vXXW1XduyvOwgYLNNtyM+3VVttk7M/lz2O9ymziwPUDbx3/babN7vePJMdr+cPes95+WH50NPdxuLXluvcx3v5fjea8We4e3Jjr73vH97vrZ5dwe798qRTN+gZnvXb0sms6U9u/f0kRoT9rctPD34WHttdQZv03nPPJH86+Is3p7m7QXv3cZoT/snkvnkr6ejvz5o7rCZt6c1jwc3lj7+/ONjonW1Rbxn3kz+ra0uxC/eqGqL+PszvNx6OnrPvFuHjjwtT09XW8Q/J5MTqTluNQxiW9XYXCufbZlMD88275mP67BNavxQyHbDxxK9tkgTh+3eM1+wfPoqee+dx2wvPp/0p+P/vauutgjn+n/L+BG3KQzjR3+wZ+sbP7LlwCvrHep4r4XvPT7u1Ia915Bxp+/YvVeOZLjNPbbE5zE8W7xn+Ly6V5/xsQHXPLbUeEht89hNmI7++abaxsS8+eZbff8H1TuRVym9kHNdZidyIeeqMZmkLJupAm83JOJFMmsN8hJS7Weh+inuqpu93+Fzw179hOZUPl7O60o+Z+fdr8Oe9c/P+etUPqfZuo73mvreaxVZc9wyI7LmHKr3b95m897jizsHJWUy7d+88jAu7vTWX06qmF11HuOIktklY2dWVNSxrnOQT/eMyJrrOr1n/lvXWX1JlSte93m84F83wPtM3gGcqa5J4ePXjbQmxci0c6ryzN+H4/MXXp55zwyqJ89q68NxznL14QTacHky9U9VnvnrH/9aFF4HFNSTZ61qyTOepn9diFS/V2Z8uyrP/PMW/rUofN5ik3ryrLZ5C16X+sepopE16+rcpNw/R+ytdfGnYZ8XmgMQWhtRlfdef8rLe17v24vPLWzls5lfPC1Pzyxf3vG+ofesUL89r7lPH0/HiE/HiM9emTmNvASfG26IPh2YPu3h+lTVG95voNcH4eduqvoinYTyoTM+3VV9Ea/t6MWW9zsdmW95PwBlE/9tr+3p/Y4nz2T349mz3nNefnhl1tO9FXuGj+/455r8c1s2D8awNPzjOM1ZvnBukPB5RqT2Oa5OTEdP1p7p6F8bYO0qYfoK1JGrxtNTmf8+mD1bkbxvyf6/HbOnpU8mOW5WW7+Tt2d4XeHpIzD+alz959aO/PHuY44842Nlng18bM9r2/L5MP8cpZV5ceSKBd5/jzr08/TiecnHpby//vY2XzPEy7c39tCByfzzxt46Iq3lSUCfIS59/H7IiFTnv3/ujvcPvGeOTv6tbe4Ivy+kqk3olQF/e5zPL3rPHF+HjjwtT09Xe9y/Lk/ItlU8WtseJm6b98yiOmyTGQOpaufgba855+PN3bV22O49cybLp7OT9zy+eX10heP/vauuNi5fAymw3scItR/ivL3jlaNODpt4GwxlE/9tr23n/Y4nz2T3l7Nnvee8/PB86Olufefxfpc63mvpe68Ve4a3CTv53vP+7fna5t157N4rR5JzYB1qsYXP3XnP8PFlqXU1/jaIp0dblo+11Rm87ec9c33yb23riPg8rb14O4XX2VJrf2tbkx1lOrrWaftt5u3u2UzvCFrvRDy/rjnIVOYauT3+uUY+z5LBkstC2xPPi8vEV1W6EnUXb6t6V131imebLSsdWR7bl7J9z0u1T4XmTus8wIa3n8JwgM267NmGHGDjxb33rPWba199Q9ILcrANbxetrT0QQu1LqTm2uFQc8TUyEebHiC//vIuvjbexH2MvNfM9z+MEqbPQPEDcNVfS2mc3b6ugY5+vy+JjUp6cz9MMZs/yce/cSLUfeN/ci0Pv2WhkzXUJOQ1MrxV7hvNVbeM9fM6uD/stqfn15j49vH/z+XWJ9ZupnpvU0qEPsEzF+Zo4/lsSMZnuulJ+Ho6wjjXOduFlclPR381ztin8evB6fSv27HCWN661/K6ze/zPeeOJrnhv7LVarnn67Zi9U5luAucIVPrbWLmRmj6I+PT19wld50OMTv6t73wI/3gfX2cvXadk+nTh88/eM2PrsaO2dQRNHGnt3sC0IpGa7Us+btnal0ZdOkTZM3w/H3/HNee+t+83/Hq2q+X3mjrSmtjAtCKRmvUqt9k/f8/Lq/0tHrN8Xyhfbz4seR8PdtXYG+nFcXufztz+Scm/Nq+msPc417r05/UUX2cj0cfi9U0rh77yHOSeW/HzS10c5NoLMtOXp/xq7niX13uTmL0RtL2+8Z0Mh27+8R3/WE6GY9141LduvK3juRxmd24E2xfLFkpXYlw21XW/nm2u8Z0s3/Mya+Ol1l3WPAvTv4aQ7yMQaI8b/tsen/rbZHzNJx/f8fOFa60i369nL+s31zkPDUmvVWTNuq6uvhVf/9sY4zu1nevHY19iPXCq51A1deiDXA/WKrLmWmupmEz1HAO+NyvHoWMYxrOaO/QB+se49nxJjV3z/iDnuEGieW5WcSrff54bqdlHtRefQ0uwZ03ynu8D5+v8eTx76Xn3vI2Q7Xu3vjOAvOe9vrF/noxznd8mvqZBup7I9OnC237eM5sl/9a3N8BvR7YjreENTCsSqVlv8HEm/1qtaGTNeYCVvmd5zLaq4z2err38cxqcD/m4Eh/z8P4KnDVWY4+cl3bMpyv3Z7bvGT6+4D0zKvm3vnNOPf/WNZ5RV3nynhlTz++1ruX3sh1p7drAtCKRmuWJz3v59+bx/QENKU91vcd/y14tfO/wuovr5J/74v1aWP1h4nGuE9ef6+fa1yPVb/XHv7/c1lW2Oad5z1Qk/9bWb62rPjuE2RtB27sW1yV4dnp//eO5mez/57LneFnE90+N0PoDE5dsq6dyhq1nm6vf66XDx9z+LXu3eZ0Yhr3b3dmzDdm77Z+ftH7z1wM5DUwvyJ7uMKzvkvntqhhtJpSuRBzxPQMR5seIL/+8i5ch/7oGLx3ZcxirYl/gfLdVse/f3+I/P4XvA0HHPp/b4nMKfD7Gu89jz/rnS/x+4HOa3rO8jcT5rSHp8fWbnK9qO+uYt4P7s9+SWtdQ29oqvq5Bam4/lXUNwnM48drmiyRiMtU197xe43WKoI5xPr7Py+Qw0d81zjaFXw9er49kz45I3te2rsG1D3A+e8cV43yeeBjExppryD3+4nzh2eg9swPTdzrTTcDvlf52VW6kpv8jPn29/pjLR94zOyf/NnQNgL/v3xj1iH9en8/3e8/sVo8dbWuxI8eR1rgGphWJ1GxT8jLqX4NQlw58DJLvKeLvcJu9ZybUo2f7Wn6vmSOt0gamFYnUrEu5zZ6ufG0Cjxkes67zAdDlp7Yz+Vo57J+c/Gvzahp7j8eXS39eN/F5MIl+Fa9jWjv0bQQOcp5d6+eXujiI5733jLffpLYxIf+7/rpu9RhMBNsO8OqkGPvd+Uwv//xAbWvxejJdvSsXpWvCFPBxq5gj/xoyblWjDmZjWfxsBfjaikTVOTj4PTnGSK2tkBkTizvn1HLYvz0f8L0XKJv4b3tc6d8nwufzOF/7z+7yz8FZvvLaCs3qeM+/b5iPc2ez92rb58H3WHvvWY72zpvk9Y3APFDKa24a46w9bz3JpIrZO5ix03fIa9BXlNv6tM+I1LRkJXuGsw0fMefyTIdspeMvZyC+OoXv1vRkUV/anNGasr/c696VG4GxV53MG+U/nFP92y5GFhlFSFSxFX5FXNWJb3jWrrkz0bXqnfc6JOyyLMJ38sYcszcx3+xNM/bOjJKy/YfPnDRnasW02bN40HAK866VEfdxldHImk0L/lxu8t/+tDgFuYKFH1niHckoFBg1jhn2bzVdpbuXiTk1bVp9PLBPvvqIYJb5Vr76mGAmD9Lk4XkYY7LVU91MtrrKYc2lbuxnBZpLhUKBV/xfc6nhNqXaXOrKng1jc8mrJO1f74ht3jwRmK4pTnVpIV/qIDF1bPPOO4atYtoBcyrmVFQdT7z1nGllsydPn7ZlyZQpGY6MbepT3tVa8rdg7FVfa8levD3J323ikK1kmeL6N9ePkxxfK8fXyHkyf+VR25q6bJ8sEllzDQWXcTszHPfRSM1xsYjDDr+sueN32jpkrvzzFz4+r4pcv2vT4OMJft0yI+7WTgZeF8PtjUXWzIO2jvz5P4sj3NpwSAYA","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3RbuzKmZ7he9nHRsAq/iSLvpUgCDwznsCAYQ/GngCBMfcebVuktLyrV/diffvratV7tidpScXHFPt/2Uusv/30b7//l//6P//7D3/69z//5aff/s+//fTHP//r7/76hz//6e3/+ttP0//I5e//r3/5j9/96ef/h7/89Xf/+deffrtM229++v2f/u3tv/blv3/z07//4Y+//+m389t//6/f/PxF+4UvmnPti0o+vmif5soXzVe+aK19UUrL+v5VKa2p8mXbtS8r175sv/RlMV37snTty/K1L5uvfVlc+7Ll2pddO0vi2lkS186SuHaWLNfOkuXaWbJcO0uWa2fJcu0sWa6dJcu1s2S5dpYs186S5dpZsl47S9ZrZ8l67SxZr50l67WzZL12lqzXzpL12lmyXjtL1mtnyXbtLNmunSXbtbNku3aWbNfOku3aWbJdO0u2a2fJdu0s2a6dJeXaWVKunSXl2llSrp0l5dpZUq6dJeXaWVKunSXl2llSrp0l+7WzZL92luzXzpL92lmyXztL9mtnyX7tLNmvnSX7tbNkv3aWpGm6+HXp4tfli183X/y6uPh1y8WvWy9+3Xbx68rFr7t4vqSL50u6eL6ki+dLuni+pIvnS7p4vqSL50u6eL6ki+dLuni+5IvnS754vuSL50u+eL7ki+dLvni+5IvnS754vuSL50u+eL7MF8+X+eL5Ml88X+aL58t88XyZL54vF2/Qpot3aNPFW7Tp4j3adPEmbbp4lzZdvE2bLt6nTRdv1KaLd2rTxVu16eK92nTxZm26eLc2Xbxdmy7er00Xb9imi3ds08VbtuniPdt08aZtunjXNl28bZsu3rdNF2/cpvqthT3Px5dN+/7Nl/3mFy+OOZX3V8e8Tuer32biyqv32OP91fuyfHxUl2M6lrT1t6TS35L27pZUv5Xz3CWl/paU+1vS3N+Sor8lLf0tqb+r997f1Xvv7+q9d3f1zlN3V+88dXf1zlN3V+88dXf1zlN3V+88dXf1zlN3V+88dXf1zlN3V+889Xf1Tv1dvVN/V+/U39U79Xf1Tu6LwLLs7y9eto+bFHlbjgWVzhaU3af2UvKxoFJqC8q9LWjubUHR24KW3ha09ragrbcFCa5Def+0oHRnQW8fHxzfet0+vnM6F7R3tqB56m1BqbcF5d4WNPe2oOhtQYt7QXM+F1S+WdAvX5vXlN5fnNd5/bhqzTfWkc91pI/vHVvlxdtyrHnb49M3PlhWWGosGyw1lgJLjWWHpcIS09dhmeftXEcsn1nejzUNdKz5Cx3rFuc6ylQ51vkrHev8cax75VhjoGO1j4Nnlr59SFeZT2PtbUFbbwsqvS1o72xBy9TbglJvC3K/deXzW7+NCLUFzb0tKHpb0NLbgtbeFrT1tqDS24J+3Sv1P37IOjl+SHL8kOz4IbPjh4TjhyyOH7I6fsjm+CHF8UMcv/Gb4zd+c/zGb47f+M3xG785fuM3x2/85viN3xy/8ZvjN35z/MYXx298cfzGF8dvfFH8A5L1427kvtwZBO//u6gS/S1p6W9Ja39L2vpbUulvSXt3S5L8RZl4SYIrbOTzk4P49EPqS9rOf4u47XfvYU3LsYy8fxOzv3xtOf/RQ0p3Xpq2OAzTtn7+uK5+ePvxR6exfPre5w10xV/AfXXCcodw7phwKzdupF76fYthjnQZ5kjXYY50G+ZIyzBHug9ypLPiT0Jf5Eh7nuq0R9rz8KU90lFmpHmKYY50lBlpnkaZkeZplBlpnkaZkeZpmBkpDTMjpWFmpDTMjJTsM9L5uU/59LdWN/4cczr+2e46Nd+4nVOMc6jLOIe6jnOo2ziHWsY51H2YQ83TOIeaxjnUPM6hjjMtKR6X8iqHOs60lMeZlvI401IeZ1pSPPAmzj/0imWLO0tKsZ7fO7ZvYf6xJMUjb9RLmt1LWvaPP8eNe49ZSvt0vnpfyjf/M185KRQPjHmlw13GOtx1rMPdxjrcMtbh7kMdbkxjHW4a63DzWIc71lSleKTLKx3uWFNVjDVVxVhTVYw1VSmehLJO51Of1u3ejYo8LedTI1JJ7QcQr34Ay6sfwPrqB7C9+gGUVz+A/cUPQPEUmuceQHr1A8ivfgCv/k6seOrPcw/g1d+J11d/J15f/Z14ffV3YsWDfLZz5+Qo6W7QLPt05s/dPxvPMZ/Po427m5J8ub//nxWPQOJ/nl/vf56V/3n6ffTDrHjs1kv+zyP9wwfFc8VQVDw4DUXFk+FQVDz6DkXFs/1QVDy8EEXF8xZRLKPWllZx1CjSKtIuCkXaRaFIuwgUd9pFoUi7KBRpF4Ui7aJQDBQFirSLQpF2USh+qXZ52l/w7l8qXp7H+KXq5VmMMX2pfHke45fql+cxfqmAeR7jlyqY5zEGjArGL9Uwz2P8UhHzPEYqRsJIxUgYqRgFY6JiJIxUjISRipEw9l0x87QdR/v2gnLve997Zl0oHs/+Sofb9xz2g4f7zKc/ROp7Fnspyr7nsVeizH3PZC9F2fdc9lKUfc9mL0X5peaz51IGlCrKvu82vxRl33ecX4qS2pFRUjsySmpHRTlTOzJKakdGSe3IKDt/B0/rcZ9+/vtzVb77vcXPm4q58/fk5+J0/i77VJzo/H3zuTidvxM+F6fz97bn4nR+b+65OAHObZzO7589F6fzO2LPxWFC/g4OE/J3cJiQb+MsTMjfwWFC/g4OE/J3cOxzzrp83L4q9/4cO9J+Pj88x8ftq7X24nU9vvOWPhb992f4/vIbL8czfj8/XPfn1767rLhUXTZcqi4Fl6rLjkvNZZ1wqbokXKouGZeqyzymy5KOvQSWz58YVl+b0vyxS8GnRaRyTIGK3Y5QXAedpcWKg07eYsVB53Sx4qBTvVhx0AbQKm72Ytim49WpRL6juK/n0e7ruty5MTVv50LSx5/TztWXrue/d5q3T4uuvnidj9eu8/z5pe+GCcNmw4xhs+GMYbNhYNhsuGDYbLhi2Gy4YdhsWDBsNtwxbDUsdEq7IZ3SbkinPGC4Ht93LVExpFPaDQPDZkM6pd2QTmk3pFPaDemUdkM6pdlwp1PaDemUdkM6pd2QTmk3DAybDemUdkM6pd2QTmk3pFPaDemUVsNlolPaDemUdkM6pd2QTmk3DAybDemUdkM6pd2QTmk3pFPaDemUZsNEp7Qb0inthnRKuyGd0m4YGDYb0inthnRKuyGd0m5Ip7Qb0inNhplOaTekU9oN6ZR2Qzql3TAwbDakU9oN6ZR2Qzql3ZBOaTekU5oNZzql3ZBOaTekU9oN6ZR2w8Cw2ZBO+WfDdxji4wYMRXEDhky4AcPsX4cJBvobMEzpN2AYvW/AME/fgAlg6jBMvjdgmHxvwDD53oBh8r0Bw+Rbh1mYfG/AMPnegGHyvQHD5HsDJoCpwzD53oBh8r0Bw+R7A4bJtw6zjjrHbPMHTMwVmFHnmLswg74rRT6/ceRvty34oRe/Kw76FiZWHPT9Tqw46JujWHHQe0haxVH3ShUrDjrViRUHHQHFioPe9xIrBooCRdpFoUi7KBRpF4Ui7aJQpF0EiqPunypWpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXQSKo+6pKlakXe4r5lyOf2GS5ylXFGkXhSLt8ojimj4Ua7/RzIsPKC65HIpL3iuKzIsKReZFhSLzYrviOurelmJF5kWFIvOiQpF5UaEYKAoUudetUKRdFIq0i0KRdlEo0i4CxVH3ahQrMnUrFJm6FYpMOg8olu38xKDsd148x3mAc1Q+6lpH3VjvmeTMUHZyBi43+ai7/D2TnIHYTs70bCdn1LaTB+Rucm6d28mpTzs59Wknpz7t5NSnm3zU/d5+PfKSlvfXllS5dTvq5nBPAx91M6NfD3w//yX+XtYKOHdXzOBcUsTgaZrSiZeiQk512smpTjs51Wknpzrt5FSnm3zUbZaeSc5UbifnM087Obez7OQBuZuc+rSTU59y8jWOA0yp8tHEqJt7PZOc+rSTU59u8pX6tJNTn3Zy6tNOTn3ayQNyNzn1aSenPu3k1KednPq0k1OfbnJ2/PSTU592curTTk592skDcjc59Wknpz7t5NSnmjynkzynpUJOfdrJqU83OXu2+smpTzs59Wknpz7t5AG5m5z6tJNTn3Zy6tNOTn3ayalPNzm77vrJqU87OfVpJ6c+7eQBuZuc+rSTU592curTTk592smpTzP5xh7efnLq005OfdrJGRLl5PFBHqVCzpDoJk+8fcrJ1xMvb7lCztunnZy3Tzs5N2/t5AG5m5ybt3Zy5nI7OXO5nZybt3Zybt66ydkm209OfdrJqU87OfVpJw/I3eTUp52c+rSTU592curTTk59NpH/Q3EmKBWKNKJCkexTKFJyCsVAUaBIbykUSSiFIlWkUCR0FIq0i0AxaBeFIu2iUKRdFIq0i0IxUBQoMuk8oLgvx4vz24oqikw6AsWFd5dHFMt0KtZ+oxfeXRSKvLsoFLkzplDkzphCkTtjCkXmRYUi86JAkb3dJYrcGVMo0i4KRdrlvuJ2PLphWyqCgWCjIM3SKkivtArSKq2CdEqrII3SKMju382CtEmrIF3SKkiTtAoGgo2CNEmrIBN1qyATdasgE3WjIDsaNwsyUbcKMlHfF5w/HqM957xVFJmqFYqBokCR6VqhyF1/hSKdolCkVQSK7G35kGLsp+JS+TcNbFcpUeTd5QHFeToV57xWFHl3USjy7qJQ5G5Yu2JhnzuJInfFFIrMiwpF5kWFYqAoUOTOmEKRdlEo0i4KRdrlEcXzG8/zXlOkXQSKbDIqUaRdFIq0i0KRdnlAMc41zzHPFcVAUaBIuygUaReFIu2iUKRdFIq0i0CRLSolirSLQpF2USjSLgrFQFGgSLsoFGkXhSLtolCkXRSKtItAkd0QJYq0i0KRdlEo0i4KxUBRoEi7KBRpF4Ui7aJQpF0UirSLQJHdECWKtItCkXZRKNIuCsVAUaBIuygUaReFIu2iUKRdFIq0i0BxoV0UirSLQpF2USjSLgrFQFGgSLsoFGkXhSLtolCkXQSKPAv0EcU7z18shQJ8RHFLp+I+/VKRJ6pKFJm6FYqBokCRqVuhyNStUGTqVigyLyoUmRfbFXee7itR5BMDhSLtolCkXRSKgeIDT2vL06H4dlOnoki7KBRpF4Ui7aJQpF0UirSLQJGn+0oUaReFIu2iUKRdFIqB4iOKH/sYfF7zqUi7KBRpF4Ui7aJQpF0UirSLQJGn+z6k+P29hnae7itRpF0UirSLQjFQFCjSLgpF2kWhSLsoFGkXhSLtIlDk6b4SRdpFoUi7KBRpF4VioChQpF0UirSLQpF2USjSLgpF2kWgyNN9JYq0i0KRdlEo0i4KxUBRoEi7KBRpF4Ui7aJQpF0UirSLQJGn+0oUaReFIu2iUKRdFIqBokCRdlEo0i4KRdpFoUi7KBRpF4HiSrsoFJm6FYpM3QrFQFGgyNStUGTqVigy6dxXzG9x8v7i/LaiXypuTDoKRe7SKhSZFxWKzIsKxUBRoMi8qFBkXlQocpdWochdWoUi7SJQLLSLQpF2eURxP77xPKVSUaRdFIq0i0IxUBQo0i4KRdpFoUi7PKJYpnPS2eeKIu2iUKRdBIo77aJQpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXdoV08Q23BpG6kXCSL5IGOkXCWPAqGCkYCSMJIyEkYaRMBIxEkYqRsHIhtwaRipGwkjFSBipGAljwKhgpGIkjFSMhJGKkTBSMRJGKkbByNbcGkYqRsJIxUgYqRgJY8CoYKRiJIxUjISRipEwUjESRipGwcgm3RpGKkbCSMVIGJkbH2AsWz4Yy37nxSlHHAeYo9TMGTL95kykfnPGV785s67dnB2gn2DOFO03Z+T2m/Mpg988MLeb06Fy8205zUvVnA71m9OhfnM61G9Oh9rN2c37CeZ0qNx8PfHylmvmdKjfnA71mwfmdnM61G9Oh/rN6VC/OR3qN6dD7ebszP4EczrUb06H+s3pUL95YG43p0P95nSo35wO9ZvToX5zOtRuvtGhfnM61G9Oh/rN6VC/eWBuN6dD/eZ0qN+cDvWb06F+czrUbl7oUL85Heo3p0P95nSo3zwwt5vToX5zOtRvTof6zelQvzkdajffmc/F5ns5XruXtSbOdO4WD8TN4kzmbnHmcrc4U7lbnJncLc5E7hVPE58LucX5VMgtTnO6xWlOt3ggbhanOd3iNKdbnOZ0i9OcbnGaU/0p0DSlEy9FxTxRnX5zutNvTnn6zWlPv3lgbjenP/3mFKjfnAb1m1OhfnM61G6e6VC5eSon3pxq5nSo35wO9ZvToX7zwNxuTof6zenQX3NWrJvTof75nA71m9OhdvOZDvWb06F+czrUb06H+s0Dc7s5Heo3p0P95nSo35wO9ZvToXbzoEP95nSo35wO9ZvToX7zwNxuTof6zelQvzkd6jenQ/3mdKjdfKFD/eZ0qN+cDvWb06F+88Dcbk6H+s3pUL85Heo3p0P95nSo3XylQ/3mdKjfnA71m9OhfvPA3G5Oh/rN6VC/OR3qN6dD/eZ0qN18o0P95nSo35wO9Zszn4vNS1reX1vSXhNnOleLz8c3LstWE2c2d4szmZvFC/OKW5xpxS3OPXO3eCBuFmced4szj7vFmcfd4szjbnHuk5vFd+6Su8VpTrc4zekWpznV4uciSqndH98DcbM4zekWpznd4jSnW5zmdIvTnF7xPNGcbnGa0y1Oc7rFaU63eCBuFqc53eI0p1uc5nSL05xucZrTLJ5oTrc4zekWpznd4jSnWzwQN4vTnG5xmtMtTnO6xWlOtzjNaRbPNKdbnOZ0i9OcbnGa0y0eiJvFaU63OM3pFqc53eI0p1uc5jSLzzSnW5zmdIvTnG5xmtMtHoibxSkgtzgF5BangNziFJBZPCggt/ig0+HbS4/nhM/blmoygcwNmUHf++cyxSFTUq7JDPoe/YDMoO+l92WWQd/zHpAZ9O7cAzKD3kV7QGbUeea+TCBzQ2bQf7HwgMyg99UekGEGviXDDHxLhhn4hsyo+84/IMMMfEuGGfiWDDPwLZlA5oYMM/AtGWbgWzLMwLdkmIFvyTAD35AZdc/rB2RGnYG3ffqQubfx8dvYd6w5b1XGUQdmMeOwn5hrGQNGBeOoc7uYcdQhX8w4ahGIGUfNBzHjqK2hZSyjhomYkYqRMFIxEkYqRsIYMCoYqRgJIxUjYaRiJIxUjISRilEwjrpZupqRipEwUjESRipGwhgwKhipGAkjFSNhpGIkjFSMhJGKeYBx3sux5siVP72fR91+W81IxTzCuMUHY64xBoz3Gdc4Htfy9p9zjZG5UcLI3ChhZG6UMDI3PsJYjlWk7dMRfmJkblQwjrqFrpqRuVHCyN3vRxg/mnpLtYoZdXfPH2Ms68eay1pj5J36PmNO0/FUwJxS1Bh5p1YwjrrxoJqRd2oJI+/UEkY+p5YwBowKRuZGCSP3GyWM3G+UMFIxEkYqRsE46lZ2akYqRsJIxUgYqRgJY8CoYKRiJIxUjISRipEwUjESRipGwTjqdnRqRipGwkjFSBipGAljwKhgpGIkjFSMhJGKkTBSMY8wLnEyLkuNkYpRMA67waiYkYqRMFIxEkYqRsIYMCoYqRgJIxUjYaRiJIxUjISRilEwDrtFrJiRipEwBoyCv2AddtdRMSNzo4SRufGRv6c+V/G25trd72E3PxUzMjcqGIfdVlXMyNwoYeTut4SRu98SxoBRwUjFSBipGAkjFSNhpGIkjFSMgpE9WDWMVIyEkYqRMFIxEsaAUcFIxUgYqRgJIxUjYaRiJIxUjIKRPVg1jFSMhJGKkTBSMRLGgFHBSMVIGKkYxdYS7MGqYaRiJIxUjIAx2INVw0jFSBipGAkjFSNhDBgVjFSMhJGKkTBSMRJGKkbCSMUoGNkRWMNIxUgYqRgJI3PjA4zL+df9admWO985zgOcY55r5gyZfnMmUr8546vfnFnXbs4G3E8wZ4r2mzNy+835lMFvHpjbzelQvzkd6jenQ/3mdKjdnA2U1eYlLe+vLWmviTMpusW51yIW30s+Vlz9tILtNe3iXFXE4mk6NwNLU20zsGCjxCeY059+c/rTb05/+s3pT785s7ndnG0jn2DO56B+c+5t+c3pUL95YG43p0Pl5uv54pRqn1WwieYTzOlQvzkd6jenQ+3mbPz5BHM61G9Oh/rN6VC/eWBuN6dD/eZ0qN+cDvWb06F+czrUbs5Gwk8wp0P95nSo35wO9ZsH5nZzOtRvToeqzXM6X5zTUjOnQ/3mdKjfnA61m7MV9BPM6VC/OR3qN6dD/eaBud2cDvWb06F+czrUb06H+s3pULs5m3k/wZwO9ZvToX5zOtRvHpjbzelQvzkd6jenQ/3mdKjfnA51my9sx/4EczrUb86sKDePD/MoNXNmRb8576Fy8/XEy1uumLMZ8BPMeQ/1m3Mv12/OvVy/eWBuN2c+95szn/vNuZfrN+dert+cDrWbs/f2E8zpUL85Heo3p0ObzA/GgPEBxrIfa16n6tlILUoYCUAJI00nYSTTJIyUl4JxJqYkjPSRhJHkkTBSMRLGgFHBSMVIGKkYCSMVI2GkYiSMVIyCMagYCSMVI2GkYiSMVIyEMWBUMFIxEkYqRsJIxUgYqRgJIxWjYFyoGAkjFSNhpGIkjFSMhDFgvM+4Rj4ZY64xUjESRipGwkjFSBipGAkjFaNgXKkYCSMVI2GkYiSMVIyEMWBUMFIxEkYqRsLI+H2fMafzbwbf/nOpMTJ+Kxg3xm8JI+O3hJHxW8LI+C1hDBgVjIzfEkbGbwkjHyJIGKkYCSMVo2Bk/3oNIxUjYaRiJIxUjIQxYFQwUjESRipGwkjFSBipGAkjFaNgZPdzDSMVI2Fk/P5nxkMmkLkhw5B8S4a595YMo2xdZmUXWvtOkSu70D7BnPulfnOmO795YG43ZyL1mzPr+s2Zov3m3D32m3Or2W7OTu568205zUvVnA71m9OhfnM61G8emNvN6VC/OR3q3hF1ZSf3J5jToX5zOtRuzk7uTzCnQ/3mdKjfnA71mwfmdnM61G9Oh/rN6VC/OR3qN6dD7eYzHeo3p0P95nSo35wO9ZsH5nZzOtRvTof6zelQvzkd6jenQ+3mQYf6zelQvzkd6jenQ/3mgbndnA71m9OhfnM61G9Oh/rN6VC7+UKH+s3pUL85Heo3p0P95oG53Zz5XGy+l2Mj1r2sNXGmc7c4s7lZfGUyd4szl7vFmcrd4szkbvFA3CzO50JucT4VcovTnG5xmtMtTnOaxTea0y1Oc7rFaU63OM3pFg/ExZ8CTVM68VLUzKlOvznd6TenPP3mtKffnPq0mxf6029OgfrNaVC/ORXqNw/M7eZ0qNw8lRNvTjVzOtRvTof6zelQvzkdajff6VC/OR36a86KdXM61D6f73So3zwwt5vToX5zOtRvTof6zelQvzkd6jbfJjrUb06H+s3pUL85Heo3D8zt5nSo35wO9ZvToX5zOtRvTofazRMd6jenQ/3mdKjfnA71mwfmdnM61G9Oh/rN6VC/OR3qN6dD7eaZDvWb06F+czrUb06H+s0Dc7s5Heo3p0P95nSo35wO9ZvToXbzmQ71m9OhfnM61G9Oh/rNA3O7OR3qN6dD/eZ0qN08mM/F5iUt768taa+JM52rxedjxWXZauLM5m5xJnO3OPOKW5xpxS3OPXO3OHfMzeIL87hbnHncLc487hZnHneLB+Jmce6Su8VpTrc4zekWpznV4uciSqndH19oTrP4SnO6xWlOtzjN6RanOd3igbhZnOZ0i9OcbnGa0y1Oc7rFaU6z+EZzusVpTrc4zekWpznd4oG4WZzmdIvTnG5xmtMtTnO6xWlOs3ihOd3iNKdbnOZ0i9OcbvFA3CxOc7rFaU63OM3pFqc53eI0p1l8pznd4jSnW5zmdIvTnG7xQNwsTnO6xWlOtzjN6RanOd3iNKdXvEwUkFucAnKLU0Bu8UDcLE4BucUF0+GcynGg83pPfFn29xcvW/oQfDuOY0V7bytKU3crSt2tKHe3otm9ov148vw6rdUVRXcrWrpb0drdirbuVlS6W5H9ml3y8dtfSm1FeepuRam7FeXuVjR3t6LobkVLdytau1vR1t2KSncr6u6aPXd3zZ67u2bP3V2z5+6u2XN31+y5u2v23N01e+7umj13d82eu7tmR3fX7Ojumh3dXbOju2t2dHfNju6u2dHdNTu6u2ZHd9fs6O6avXR3zV66u2Yv3V2zl+6u2Ut31+ylu2v20t01e+numl1/Gvv6savsNEsXtMd+fIC6L8vH9/75Y9xjSam/JeX+ljT3t6Tob0lLf0ta+1vS1t+SSn9L2rtb0tbf1Xvr7+q99Xf13vq7em/9Xb23/q7eW39X762/q/fW39V76+/qXfq7epf+rt7FfBG4+4/bytrbgsyn9t2o3KfeFpR6W1DubUFzbwuK5gXl/dOC0p0FpaWc/7J7nT7/a/TtXNLS35LW/pa09bek0t+S9t6WtE9Tf0tK5iWteT+XFFt1Sbm/Jc39LSn6W9LS35LW/pa09bekX/XqffyQ3fBD0uT4IcnxQ7Ljh8yOHxKOH7I4fsjq+CGb44c4fuOT4zc+O37js+M3Pjt+47PjNz47fuOz4zc+C+5Erdv5Q/blv1vv1u15629Jpb8l7d0taZ76W1Lqb0ntV8HIxw+J+PRD6kvaznu/235vlD5rOn/6Q9Gf5+hrRzoPc6QxzJEuwxzpOsyRbsMcaRnmSPdRjjSmYY40DXOkw8xIMcyMFMPMSDHMjBTDzEgxzIwU7hnpvEdV1u3Oa5fp40lGghSPfZhDXaZxDjWNc6h5nEOdxznUGOdQl3EOdR3nULdxDnWcaWkZZ1pax5mW1nGmpXWcaWkdZ1oS/Ml4nH9JEMsWd5aUYj2ftRDbtzDHkpb+llTMS1r249VpjbvP8d+n89Vvb6nf/M987aTYhzpcwR9xv9ThprEON491uPNYhxtjHe4y1uGuYx3uNtbhjjVVbWNNVWWsqaqMNVWVsaaqMtZUVdqvzOt0RHWs270bFXlajlfnVJLgAPYXPwDBEzyefADp1Q8gv/oBzK9+APHqB7C8+gGsr34A26sfwKu/E++v/U6cp+m134nfDuC134nfDuC134nfDuC134nfDqD9l/iHdqbOZTq+dS7xEUv1f5abYz4+E81x98Fnz/q3wXkSPH0ExUnweBUUJ8HzY1CcBA/IQXESPAEIxUnwiCMUJ8EznFCcBA+pQnESPIULxSnRLgLFTLsoFGkXhSLtolCkXRSKgaJA8Su1y7P+mOON8SvFyxMZv1K9PJHxK+XL/jzGr9Qvz2Ocv1LAPJHxKxXMExm/UsI8kfErNcwTGQNGBSMVI2GkYiSMVIyEkYqRMFIxCsagYiSMXVfMPG3H0c7p059z1b/33ceXvB1u17WhP9yu57AfPNxn/iHgG2XXs9hrUXY9j70WZdcz2WtRdj2XvRTl0vVs9lqUX2k+ezLlV5r9nkzZ9d3m16IMKFWU1I6MktqRUVI7MkpqR0ZJ7agoV2pHRtn3O3haj/v0c57tjx5Y+35PfjJO3++yT8bp+33zyTh9vxM+F2fr+73tyTh935t7Mk7fd9uejNP3/bMn4wQ4t3GYkL+Dw4T8HRwm5O/gMCF/B4cJ+TZOYUL+Do59ztmm4wD2cvfPsde0HQewrsudw523cyHp4x9pztWXruddtHn7tOjqi9f5eO06z59fehgGhs2GC4bNhiuGzYYbhs2GBcNmwx3DVsN9wrDZMGHYbJgxbDakU9oNA8NmQzrlvuF6fN+1RM2QTmk3pFPaDemUdkM6pdUwTXRKuyGd0m5Ip7Qb0inthoFhsyGd0m5Ip7Qb0inthnRKuyGd0myY6JR2Qzql3ZBOaTekU9oNA8NmQzql3ZBOaTekU9oN6ZR2Qzql2TDTKe2GdEq7IZ3SbkintBsGhs2GdEq7IZ3SbkintBvSKe2GdEqz4UyntBvSKe2GdEq7IZ3SbhgYNhvSKe2GdEq7IZ3SbkintBvSKc2GQae0G9Ip7YZ0SrshndJuGBg2G9Ip7YZ0SrshndJuSKe0G9Ip/2T4DrMQHzdgKIobMGTCDRhm/xswAUwdhin9Bgyj9w0Y5ukbMAzJN2CYfOswK5PvDRgm3xswTL43YJh8b8AEMHUYJt8bMEy+N2CYfG/AMPnegGHyrcNsTL43YJh8b8Aw+d6AGXSO2eYPmJhrMIPOMfdhxnxXinx+48jfbv3wQy9+VyxjvoWpFcd8v1MrjvnmqFYc8x6SWjFQFCiOOdWpFcccAdWKY973UiuOeZNMrUi7CBQH3TdVrUi7KBRpF4Ui7aJQDBQFirSLQpF2USjSLgpF2kWhSLu0K+ZB91JVK9IuCkXaRaFIuygUA0WBIu1yVzHncvwLkzxPuaZIuygUaZcHFNf0oVj7jR50T8sfU1xyOda85L2myLyoUGReVCgyLyoUA0WBIvOiQpF5UaHIvKhQ5F63QpF73QLFQfe5VCvSLgpF2kWhSLsoFJm6FYpM3QpFpm6B4qA75f2YYtnOTwzKfufFc0zHKuaoftQ16MZ6TyVnhrKTM3DZyQNyNzkDsZ2c6dlOzqhtJ+duuJ2cW+du8kH3P3wqOfVpJ6c+7eTUp52cIVFLXj7oUu3W7aCbwz0PfNDNjH498P38l/jfHN4HOHdXzOBcUrTgaZqOP5NIU4oaOdXpJh90+5+nklOddnKq005OddrJA3I3OVO5nZzPPO3k3M6yk1OfdnLq000+6BZcvyb5Ggd5SrWPJgbd3Oup5NSnnZz6tJMH5G5y6tNOTn3ayalPOzn1aSenPt3k7J7pJ6c+7eTUp52c+rSTB+RucurTTk592smpTzs59Wknpz7d5Ox/6ienPsXkOZ3kOS01curTTk592skDcjc59Wknpz7t5NSnnZz6tJNTn2bymR1s/eTUp52c+rSTU5928oDcTU592smpTzs59Wknpz7t5NSnm5z9sP3k1KednPq0k1OfdvKA3E1OfdrJqU83ORsPy8njgzxKjZwh0U7O26eafJ1P8i3XyHn7tJPz9mkn5+atnZybt3Zybt66ydkm20/OXG4n5+atnZybt3bygNxNTn3ayalPOzn1aSenPu3k1KebnG2y/eTUp52c+rSTU58t5IdioChQpBEVimSfQpGSUygSZwpFekuguJBQCkWqSKFI6CgUaReFYqAoUKRdFIq0i0KRdlEo0i4CxZVJ577ivmznmtdUU2TSUSjy7vKAYvlYc/03mncXhSLvLgpF7owJFNmPXqLInTGFIvOiQpF5UaEYKAoUuTOmUKRdFIq0y13F7Xh0w1Z7PAl7pDcL0iyNguxg3ixIq7QK0imtgjRKq2Ag2ChIm7QK0iWtgjRJqyBN0ipIkzQKsslysyATdasgE3WrYCDYKMhE3SrIRH1XcP54jPac81ZTZKpWKDJZKxSZrtsVg717JYp0ikKRVlEoMuk8oBj7qbjMNUUmHYEie/M9oDhPp+Kc15oi7y4KRd5dFIrcDVMoBooCRe6KKRSZFxWKzIsKRe6MKRS5MyZQZMtIiSLtolCkXR5QPL/x/PZxX02RdlEoBooCRdpFoUi7KBRpl/uKb5+rHIox1+51s2GnRJF2ESiyraZEkXZRKNIuCkXaRaEYKAoUaReFIu2iUKRdFIq0i0KRdhEosimjRJF2USjSLgpF2kWhGCgKFGkXhSLtolCkXRSKtItCkXYRKLIbokSRdlEo0i4KRdpFoRgoChRpF4Ui7aJQpF0UirSLQpF2ESiutItCkXZRKNIuCkXaRaEYKAoUaReFIu2iUKRdFIq0i0KRdhEosteuRJF2USjSLu2KyxQoNj9/cZmYuh9Q3NKpuE81RSYdhSKTjkCRJ6pKFJl0FIpMOgpF7tIqFANFgSLzokKRu7QKRe7SKhRpF4Ui7SJQ5ImqjzytLR9rfvvPpaZIuygUaReFIu2iUAwUBYq0i0KRdlEo0i4KRdpFoUi7CBR5oupDih/7GESuKdIuCkXaRaFIuygUA0WBIu2iUKRd2vcaWniiqkSRdlEo0i4CRZ6oKlGkXRSKtItCkXZRKAaKAkXaRaFIuygUaReFIu2iUKRdBIo8UVWiSLsoFGkXhSLtolAMFAWKtItCkXZRKNIuCkXaRaFIuwgUeaKqRJF2USjSLgpF2kWhGCgKFGkXhSLtolCkXRSKtItCkXYRKPJEVYki7aJQpF0UirSLQjFQFCjSLgpF2kWhyNStUGTqFigWpm6FIlO3QpGpW6HIpHNXMe/Ldq55TTVFJh2FIndpFYrMiwpF5kWB4s68qFBkXlQoMi8qFLlLq1AMFAWKtItCkXZRKNIuDyjuxzeep1RqirSLQpF2aVdcJ9pFoUi7KBRpF4Ui7fKAYvlY8z7XFANFgSLtolCkXRSKtItCkXZRKNIuAkV24ZYo0i4KRdpFoUi7KBQDRYEi7aJQpF0UirSLQpF2USjSLgJFduGWKNIuCkXaRaFIuygUA0WBIu2iUKRdFIq0i0KRdlEo0i4CRXbhlijSLgpF2kWhSLsoFANFgSLtolCkXRSKtItCkXZRKNIuAkV24ZYo0i4KRdpFoUi7KBQDRYEi7aJQpF0UirSLQpF2ESiy8/EDimXLx5rLfufFKUe8v/jtP2t/Bsw2yX5yJlE7eUDuJmfGtZMzENvJmZ7t5IzadnI+U3CTsx21n5z6VJNvy0lequTUp52c+rSTB+RucurTTk592smpTzX5Op/kW66RU592curTTc6G4n5y6tNOTn3ayalPO3lA7ianPu3k1KednPq0k1OfdnLq001eqE87OfVpJ6c+7eTUp508IHeTU592curTTk592smpTzs59ekm36lPOzn1aSenPu3k1KedPCB3k1OfdnLq005OfdrJqU87OfVpJt8m6tNOTn3ayalPOzn1aScPyN3k1KednLlcS76X47XfHN4HOFO5Fzwxk5vBmcjN4MzjZnCmcTN4AO4FZxI3g/MpkBmcz4DM4JSmGZzS9IJnStMMTmmawSlNMzilaQYPwL3glKb4M59pSu8vTlOKGjmtaSenNu3k9KadnOJ0k880p52c6rST0512csrTTh6Qu8mpTzs59akmT+Ukn1ONnPq0k1OfdnLq000e1KednPq0k1Ofv+KQWCenPt1zeQTkbnLq005OfdrJqU87OfVpJ6c+3eQL9Wknpz7t5NSnnZz6tJMH5G5y6tNOTn3ayalPOzn1aSenPt3kK/VpJ6c+7eTUp52c+rSTB+RucurTTk592smpTzs59Wknpz7d5Bv1aSenPu3k1KednPq0kwfkbnLq005OfdrJqU87OfVpJ6c+3eSF+rSTU592curTTk592skDcjc59Wknpz7t5NSnnZz6dJPvzOVa8vJBl/YaOFO5GHw+vnFZtho4M7kZPAD3gjOpmMGZU8zg3CO3gpeJO+RmcOZwMzhzuBmcOdwMHoB7wbkvbgbnrrgZnNI0g1OaZnBKUwx+LqKUyv3wNyHAveCUphmc0jSDU5pm8ADcC05pmsEpTTM4pWkGpzTN4JSmFzxTmmZwStMMTmmawSlNM3gA7gWnNM3glKYZnNI0g1OaZnBK0ws+U5pmcErTDE5pmsEpTTN4AO4FpzTN4JSmGZzSNINTmmZwStMLHpSmGZzSNINTmmZwStMMHoB7wSlNMzilaQanNM3glKYZnNL0gi+Uphmc8DGDEz5m8ADcC074mMEJHzP4mGPh20uP53zP25YqMOuY49sDMGO+689ligOm/LzQX8KM+e78AMyY76IPwIz5bvcAzJi34x6AGfO22QMwg84xd2G2QeeY+zBj/sOEB2DGvI/2AAyT7w2YAKYOw+R7A4bJ9wYMk+8NGCbfGzBMvnWYQTctfwCGyfcGDJPvDZhBJ99tnz5g7nzSkvI6v7845a2qGCgKFAedqcWKgw7gYsVBp3Wx4qCjvVhx1E/ypYr7qB/7axUHLQyx4qA5IlakXRSKgaJAkXZRKNIuCkXaRaFIuygUaZd2xX3QPejVirSLQpF2USjSLgrFQFGgSLsoFGkXhSLtolCkXRSKtItAcdBdzdWKtMt9xXkvh2LkVFOkXRSKtMsDilt8KFZ/o5kX7yuucTwQ4e0/55oi86JCkXlRoci8KFAcdG/iH1QsxyrS9ukIPykyLyoUmRcVisyLCsVA8b7iR0dvqdYug25x+mOKZT2+cSqf13wqDrqr4w8p5jQdz9vKKUVNkfdohSLv0QpF3qMVirxHKxT5PFqhyP1FhSLzokKR+4sKRe4vChQH3SdQrUi7KBRpF4Ui7aJQDBQFirSLQpF2USjSLgpF2kWhSLsIFAfdeU6tSLsoFGkXhSLtolAMFAWKtItCkXZRKNIuCkXaRaFIuwgUh9128YcUlzgVl6WmSLsoFGkXhSLtolAMFAWKtItCkXZRKNIuCkXaRaFIuwgUR91qVaxIuygUaReFIu2iUGReFPxN6qg7g4oVmRcVisyLD/x99LmKVKJ2r3vUDUrFisyLCkXmRYUi86JCMVAUKHKvW6FIuygUaReFIu2iUKRdBIrskypRpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXZoV54l9UiWKtItCkXZRKNIuCsVAUaBIuygUaReFIu2iUKRdmneDeFOkXQSK7JMqUaRdFIq0i0KRdlEoBooCRdpFoUi7KBRpF4Ui7aJQpF0EiuzZK1GkXRSKtItCkXZRKAaKAkXmxfuKy/m3+mnZljvfOaZjFXPMc42c4dJOziTqJmcbaz85M66dnIHYTs70bCcPyN3kfKZgJ+cDCDs59Wknpz7t5NSnm5yNyP3kAbmUvHzQpb0GzojoBWdvSzH4XvKx4uqHE2yD6QbnkqIFT9O5dVeaUu3PJNjS0E9OddrJqU47OdXpJmcbRj85M7mdnKncTs5nnnbygNxNTn3ayalPOzn1qSZfzxenVPtogu0u/eTUp5ucjTT95NSnnZz6tJNTn3bygNxNTn3ayalPOzn1aSenPu3k1KebnG15/eTUp52c+rSTU5928oDcTU592smpTzs59Wknpz7F5DmdL85pqZFTn25yNlb2k1OfdnLq005OfdrJA3I3OfVpJ6c+7eTUp52c+rSTU59m8sTW2H5y6tNOTn3ayalPO3lA7ianPu3k1KednPq0k1OfdnLq003O5uZ+curTTk592smpTzs5Q6KaPD7Io9TIGRLd5GzGKydf55N8yzVy3j7t5Lx92skDcjc5N2/t5Ny8tZMzl9vJmcvt5Ny8dZOzTbafnPq0k1OfdnLq004ekLvJqc8W8kORoHxAseyH4jpVz0UaUaFI9ikUKTmBIrtISxTpLYUiCaVQpIoUioGiQJF2USjSLgpF2kWhSLsoFGkXgeJCuygUaReFIu2iUKRdFIqBokCRdlEo0i4KRdpFoUi7KBRpF4HiSrsoFGkXhSLtolCkXRSKgaJAkXZRKNIu9xXXyKdizDVF2kWhSLsoFGkXgeJGuygUaReFIu2iUKRdFIqBokCRdlEo0i4KRdpFoUi7CBQLU/ddxZzOvwN8+8/a3wEWpm6FIlO3QpGpW6EYKAoUmboVikzdCkWmboUiU7dCkU8MBIrsXS9RpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXdoVMzufSxRpF4Ui7aJQpF0Uikzd/6R4wDBI34BhNr4Bw7h7A4YJtg7DVrHuHR0zW8X6yQNyNzlTnZ2cedFOziRqJ2fGtZMzPbvJMzeL7eTcWbaTU59q8m05yUuVnPq0kwfkbnLq005OfdrJqU87OfVp3rc0s9O6nZyd1v3k1KednPq0k1OfdvKA3E1OfdrJqU87OfVpJ6c+7eTUp5ucreT95NSnnZz6tJNTn3bygNxNTn3ayalPOzn1aSenPu3k1KebfKE+7eTUp52c+rSTU5928oDcTU592smpTzs59Wknpz7t5NSnm3ylPu3k1KednPq0k1OfdvKA3E1OfdrJqU87OXO5lnwvx56p3xzeCb4xlZvBmcnN4EzkZnDmcTN4AO4FZxY3gzOJm8H5FMgMzmdAZnBK0wteKE0zOKVpBqc0zeCUphk8APeCU5pmcEpT/JnPNKXjxVOKGjmtaSenNu3k9KabfKc47eQ0p52c6rST05128oDcTU572smpTzs59akmT+Ukn1ONnPq0k1OfZvJ5oj7t5NSnnZz6tJNTn7/ikFgnD8i9c/k8UZ92curTTk592smpTzs59ekmT9SnnZz6tJNTn3Zy6tNOHpC7yalPOzn1aSenPu3k1KednPp0k2fq005OfdrJqU87OfVpJw/I3eTUp52c+rSTU592curTTk59usln6tNOTn3ayalPOzn1aScPyN3k1KednPq0k1OfdnLq005OfbrJg/q0k1OfdnLq005OfdrJA3I3OfVpJ6c+7eTUp52c+rSTU59u8oW5XEtePujSXgNnKheDz8eKy7LVwANwLzgTuRmcScUMzpziBV+5R24G5w65GZw53AzOHG4GD8C94MzhZnDui5vBuStuBqc0zeCUphd8ozTF4OciSqndD98oTTM4pWkGpzTN4AG4F5zSNINTmmZwStMMTmmawSlNL3ihNM3glKYZnNI0g1OaZvAA3AtOaZrBKU0zOKVpBqc0zeCUphd8pzTN4JSmGZzSNINTmmbwANwLTmmawSlNMzilaQanNM3glKYVPCZK0wxOaZrBKU0zOKVpBg/AveCUphmc0jSDU5pmcErTDE5pesETpWkGpzTN4ISPGTwA94ITPmZwwscMTvh4wXP7WDinchznvN4DX5b9/cXLlj4A3w7jWFDqbUG5twXNvS0oelvQYl7Qfjw0fp3W6oLW3ha09bag0tuC9s4WNE+9Lch9pS75+LUvpbqg3NuC5t4WFL0taOltQWtvC9p6W1DpbUF7ZwuKqbcF9Xaljt6u1NHblTp6u1JHb1fq6O1KHb1dqaO3K3X0dqVeertSL71dqZfertRLb1fqpbcr9dLblXrp7Uq99HalXnq7Ui+9XanX3q7Ua29X6rW3K/Xa25V67e1KvfZ2pV57u1KvvV2p196u1Gs/V+q3/+v//u4///C7f/nj7//y9hU//3/+15/+9a9/+POf3v/Pv/6///jH/8/ba/8/"},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3vriPJceXfZT4Li4zIjH96lcViMbblxQDCyLDGCxiC391s61aRja651QOxDk8y55O6p/NWnKDu+UUUGVH82w//8qd/+o//939/+vlf//LXH/74v//2w5//8s8//vLTX36+/e1vP7T/Jf1//utf/+3Hn7/8h7/+8uO///LDH9sffvjTz/9y+9//+sMP//rTn//0wx972X/9nz98+YHxW3/AfusP+G/9gfitP5C/9QfqN/6Att/6A/L9P/CHb86V2cfJitjPiurB2SGxHR6SYz99eGHXHh+HXa0/Hv67bP1HZEvr+nFUmg2o8P4Pvd4ld912oltExnZaon2uO8aeZJjkt7rHRbr/fnW79Op+6dXj0qvnpVevK6/e26VXl0uvrpdevV969Uu92i/1ar/Uq/1Sr/ZLvdov9eq41KvjUq+OS706LvXquNSr41Kvjku9Oi716rjUq+NSr9qlXrVLvWqXetUu9apd6lW71Kt2qVftUq/apV61S73ql3rVL/WqX+pVv9SrfqlX/VKv+qVe9Uu96pd61S/1alzq1bjUq3GpV+NSr8alXo1LvRqXejUu9Wpc6tW41Kt5qVfzUq/mpV7NS72al3o1L/VqXurVvNSrealX81Kv1qVerUu9Wpd6tS71al3q1brUq3WpV+tSr9alXq1LvSqtXXt5ufbyeu3l+7WXH9de3q69vF97+bj28nnt5a91rVzrWrnWtXKta+Va18q1rpVrXSvXulauda1c61q51rV6rWv1Wtfqta7Va1177UCTXDvRJNeONMnxTJNE9e3nsveTIN23Qbju93my7m2LkYAYdX2M4ymnJ8cQQAwFxOiAGAMQwwAxHBAD4PMO8HkH+HwAfD4APh8Anw+AzwfA5wPg8wHw+QD4fAB8PgA+N4DP7Qk+H21r4sbj2VuMg4Yv7w2f3A9rPzh7g6lvhx+vfDv8IV5nFt9nFj9mFm8zi/eZxcfM4nNm8TWxeG8zi5+5wvrMFdZnrrA+c4X1mSusz1xhfeYK6zNXWJ+5wsbMFTZmrrAxc4WNmStszFxhY+YKGzNX2Ji5wsbMFTZmrrA5c4XNmStszlxhc+YKmzNX2Jy5wubMFTZnrrA5c4XNmStszVxha+YKW5dW2I8YHRDjGfXKcouRDfp/gs0s3mcWHzOLz5nF17zitbWZxcvM4nVm8X1m8RNXWG0TV1htE1dYbRNXWG0TV1htM1dYmbnCyswVVmausDJzhZWZK6zMXGFl5gorM1dYmbnCyswVVmeusDpzhdWZK6zOXGF15gqrM1dYnbnC6swVVmeusDpzhe0zV9g+c4XtM1fYPnOFfcaDM14n/tIK+xHDr4/xjKdMjKqPw9bkKIYAYjzhl8l8e6CRRR7FMEAMB8QIQIwExHhCxffc/BGHv1fPeDrDaQwBxFBAjA6IMQAxDBDDATECECMBMQA+d4DPHeBzB/jcAT53gM8d4HMH+NwBPneAzx3g8wD4PAA+D4DPA+DzAPg8AD4PgM8D4PMA+DwAPn/GIl7s32ceGkcxBBBDATE6IMYAxDBADAfECECMBMSo62MUwOcF8HkBfF4AnxfA5wXweQF8XgCfF8Dndb3Pe2uAGAKIoYAYHRBjAGIYIIYDYgQgRgJiAHwuAJ8/Y+Y6xvbZRFg/iqGAGB0QYwBiGCCGA2IEIEYCYtT1MZ4xUnoaA+BzBfhcAT5XgM8V4HMF+FwBPleAzxXg8w7weQf4vAN83gE+7wCfd4DPO8DnHeDzDvB5B/h8AHw+AD5/xrcVhW+zgxF1FKMDYgxADAPEcECMAMRIQIy6PsYz5uFOYwggBsDnBvC5AXxuAJ8bwOcG8LkBfG4AnzvA5w7wuQN87gCfO8DnDvC5A3zuAJ87wOcO8HkAfB4AnwfA5wHweQB8HgCfB8DnAfD5M+bhUvTjcPavY3x7tvp2f1p2n2vTsespLj3PmLN7qh4h06NkejqZnkGmx8j0OFhPbHuW0qS+EvTtYduXMr3dl0s1+iY+ZhafM4uvicWXzCxeicW7bivw3uVIfJ9Z/JhZvM0snpnzp+KZOe+2i/dD8cycPxE/WptZPHOROhVPjcrcWmJPPRJPjcoz8cy0Sd8OV/Mj8cy0KdtUlI8D8cJMm1PxzLQ5Fc/cEp+KZ26JT8Uzc/5UPDPnT8Uzv2/zID76kXjmfv5UPHOFLdNdfB6Jp66wwz8Vr9QV9kw8dYU9E09dYc/EU1fY2u6kqupIPHWFTftc/HGFrdz0aJM8ES/R9ydlxsMjJmXU0bunvW+7edb9runw0ib7q2gqJ4fTWmyvoo3+ePgj2Vgp2Voo2V/ZMXnTZGWlZHWlZPtKyQ58srI/QrhH+1x/5D4W9OXft8qZtcm3ueX73PJjbvk5t/yaWv5oc8sXbvned/n+lfyD25O+f9zwUHyOz8b+HPuoh/fbtjuZob+/KgevCnmRfdGrQl78XvSqkBelF70q5LXuNa+KkZfQF70qv1fmo1fl98p89Kr031+Vg1dl/P6qHLwqx+81ZLX9VfF29qrckttelV7xeZ5jf72t329BROXww53a3kIqe3iixr7BMH5ls3sa+TG3/Jxbfk0t/1e26KeRL3PL17nl97nlj7nlz111fe6q68+oumOfxb41f3Yi3/vW3N1+c/vnh933QWn39MfDH/KfUXVNtxdJ7EzRkNhGPYbkOJGvfftwztUOPpzzZ1Rds9jlh5y9+vulb388+WzRo+/bDTHiW/nxjKo7dL+NcD353Zfbncv+m/awcPHlt/9DkvBJUj5JnU/S4JNkfJKcT1LwSUo+SUUnKfnonXz0Tj56Jx+9k4/eyUfv5KN38tE7+eidfPQuPnoXH72Lj97FR+/C07t0v2fV03cxcrsNlSYPb2L0w7dSapcx+leHP3K1hXL1hXKNhXLNhXKtZXK11hbKVRbKVRfKtS+U61go13X6Jmvr9E3W1umbrK3TN1lbqG+ShfomWahvkoX6Jlmob5KF+iZZqG+ShfomWahvkoX6Jlmob9KF+iZdqG/ShfomXahv0oX6Jl2ob9KF+iZdqG/ShfomXahv6gv1TX2hvqkv1Df1hfqmvlDf1Jn6pg9JTO3NhyR4F2J2lxQO/Y3IhXKtdXIdbaFcZaFcdaFc+0K5joVytYVy9YVyXahvGgv1TWOhvskW6ptsob7JFuqbbKG+yRbqm2yhvskW6ptsob7JFuqbbKG+yRfqm3yhvskX6pt8ob7pKc+FnCXXhfomX6hv8oX6Jl+ob/KF+qZYqG+KhfqmWKhvioX6JvyTSF+Y60J9UyzUN8VCfVMw9U0fkpjam79Lwj/t1dv+2DkfDfkbgX+M7Atz1YVy7QvlOhbK1RbK1RfKNRbKNRfKtdbJtRbqm2qhvqkW6ptqob4J/yzrF+a6UN9UC/VNtVDfVAv1TbVO3+Rtnb7J2zp9k7d1+iZv6/RNt8AL5bpO3+Rtnb7J2zp9k7d1+iZvC/VNslDfJAv1TbJQ3yQL9U34Z1m/MNeF+iZZqG+ShfomWahvkoX6Jl2ob1KmvulDElN78yEJ34X4/XAW9DdiLJSrLZSrL5RrLJRrLpRrrZMr/snQL8xVFspVF8p1ob4J/2ToF+a6UN/UF+qb+kJ9U1+ob+oL9U1job5pLNQ3jYX6prFQ34R/lvULc12obxoL9U1job5pLNQ3jYX6Jluob7KF+iZbqG+yhfom/LOsX5jrQn2TLdQ32UJ9ky3UN9lCfZMv1Df5Qn2TL9Q3+UJ9E/5Z1p/k+iGJqb35kATvQkJsOxw9ob8RsVCuuVCutU6u+CdDvzBXWShXXSjXvlCuY6FcbaFcF+qbYqG+KRbqm2KhvikX6ptyob4pF+qbcqG+Cf8s6xfmulDflAv1TblQ35QL9U25UN9UC/VNtVDfVAv1TbVQ34R/lvULc12ob6qF+qZaqG+qhfqmWqdvirZO3xRtnb4p2jp9U7R1+qZoY6Fc1+mboq3TN0Vj6ps+JDG1Nx+S8F2I5y7pywncbwT+ydAvzFUWylUXyrUvlOtYKFdbKFdfKNdYKNdcKNeF+iZdqG/ShfomXahv0oX6JvyzrF+Y60J9ky7UN+lCfZMu1DfpQn1TX6hv6gv1TX2hvqkv1Dfhn2X9wlwX6pv6Qn1TX6hv6gv1TX2hvmks1DeNhfqmsVDfNBbqm/DPsn5hrgv1TWOhvmks1DeNhfqmsVDfZEx904ckpvbmQxK8WqXsX7Sa4keSjE8SmhFfrrdfOupIUtFJgj8F9TskCZ8k5ZOEbs9V9klcvf3gWVnom44yuYN+tE3+mFu+zS3f55Yfc8vPueXX1PLhT9x8snzhlh91vx2or/R/e9hqO+ztrlljux2AP0TzlbmS1/On5joWypW81D41V/K6/Ftydd3e1/AuR7mSF/Gn5kpe8Z+Za5K3B0/N9Y3q62mub1Rf3fZc/TDXN6qvp7mS34k/Ndc36iXOcq134nBuoj31KNc3uqc7zfWN2JS+Ha7mR7m+EZvK+parj6Nc34hNp7m+0X3Oaa5vdJ9zmusb3eec5Jrtjerraa5vVF9Pc32je7qHXKMf5fpG93SnuY53ylX3XPMo13fqm4Z/nus79U1nub5T33SW6zv1TWe5vlPfVNv7ElV1kKu8U9+U9nmuz+ibfC9sEqInuY62X9panOU6apsBLLP+VbIfCejsCfTZExizJ2CzJ+CzJxCzJ5CzJ1CTJ/CU53+9NIHZK7HOXol19kr8lGdqvTSB2Suxzl6JdfZKrLNXYp29EvfZK/FTHhMVEXsC5Z8nMCS2u/QhOT4/7Nq3K7s+6L8d/pD/jDocY9zlny3qyX1RT6J9fjjGnmuY5IH8/lL5dqBo0Cmypyjqv6LoI4gjggQiSCKCFCDIU546cxpEEEEUEaQjggxEEITjB8LxA+H4gXD8QDjeEI43hOMN4XhDON4QjjeE4w3heEM43hCON4TjHeF4RzjeEY53hOMd4XhHON4RjneE4x3heEc4PhCOD4TjA+H4QDg+EI4PhOMD4fhAOD4Qjg+E4xPh+EQ4PhGOT4TjE+H4RDg+EY5PhOMT4fhEOL4Qji+E4wvh+EI4vhCOL4TjC+H4Qji+EI4vgOOrNUQQQQRRRJCOCDIQQQwRxBFBAhEkEUEQjheE4wXheEE4XhCOF4TjBeF4QTheEI4XhOMF4XhFOF4RjleE4xXheEU4XhGOV4TjFeF4RTheEY7vCMd3hOM7wvEd4fiOcDxi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5q4QM3eFmLkrxMxdIWbuCjFzV4iZu0LM3BVi5k4aYujuFkUgURQSpUOiDEgUg0RxSJSARElIFIj3BeJ9gXhfIN4XiPcF4n2BeF8g3heI9wXifYF4XyHeV4j3FeJ9hXhfId5XiPcV4n2FeF8h3leI9zvE+x3i/Q7xfod4v0O8/5S5vIzcopR+9VDCbw/fPvbezt5unj4/G9m278GJtHEk3y+Vv0UJSJSERClElKdM/Z1HEUgUhUTpkCgDEsUgUSDeHxDvD4j3B8T7BvG+QbxvEO8bxPsG8b5BvG8Q7xvE+wbxvkG87xDvO8T7DvG+Q7zvEO87xPsO8b5DvO8Q7zvE+wHxfkC8HxDvB8T7AfF+QLwfEO8HxPsB8X5AvJ8Q7yfE+wnxfkK8nxDvJ8T7CfF+QryfEO8nxPsF8X5BvF8Q7xfE+wXxfkG8XxDvF8T7BfF+IbwvrUGiCCSKQqJ0SJQBiWKQKA6JEpAoCYkC8b5AvC8Q7wvE+wLxvkC8LxDvC8T7AvG+QLwvEO8rxPsK8b5CvK8Q7yvE+wrxvkK8rxDvK8T7CvF+h3i/Q7zfId7vEO93iPc7xPuQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy1yeQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy1yeQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy1yeQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy1yeQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy1yeQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy1yeQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy1yeQuT6BzPUJZK5PIHN9ApnrE8hcn0Dm+gQy16eQuT6FzPUpZK5PIXN92gYkikGiOCRKQKIkJArE+5C5PoXM9Slkrk8hc30KmetTyFyfQub6FDLXp5C5PoXM9Slkrk8hc30KmetTyFyfQub6FDLXp5C5PoXM9Slkrk8hc30KmetTyFyfQub6FDLXp5C5PoXM9Slkrk8hc30KmetTyFyfQub6FDLXp5C5PoXM9Slkrk8hc30KmetTyFyfQub6FDLXp8+Y67u9ATK207fPJh+jfHt4tKyPw0NkfH44LOLjcHirI/2HVLm9jXFXpOPsVWp7lC9rR/tpGX5w2nrfrm3d6/ME7PaxwHb4dhf3+eG0tulIG/0o275UtmOpbG2pbH2pbGOpbBOfrdSebbTPE/gyBrhfOnw/rNX2DGr2DI5ndqfKQKbPQKfPoE+fwZg+g+O+oNU9g1FnGciwe5g4DOOYMIEJk5gwBQlzPIT9/DCCCaOYMB0TZmDCYCgQGAoEhgKBoUBgKJAYCiSGAomhQGIokBgK5FMoUOZ7nKr7u4L9y1cyfXO+clfVWjtU5ZSqglJVUqoqRlXVKFUJpSqlVNUpVQ1KVZRsL0q2FyXbi5Ltxcj23hjZ3tsLeCWW22ettz/afnqMXdWgVPUCD4rvnz2IaxypSkpVxahKGqUqoVSllKo6papBqcooVTmlqsvZvgVKVKACBdKGCiSoQIoK1FGBBiqQoQI5KhCKDIoigz6DDNpEtkDaxj9+J9IbpSqhVKWUqjqlqkGpyihVOaWqoFSVlKoo2T4o2T4o2T4o2T4o2T4o2T5eQIbzdy9HMaqyF/y2n78bYJ1S1aBUZZSqnFJVUKpKSlXFqMobpSqhVHU527dAHRVooAIZKpCjAgUqUKICFShQNFQgQQVCkSFQZIjnkCF3pKqUnxH49rnjdvz2Yd9+WuouyzhlOaes4JSVnLKKUlY2TlnCKUs5ZXVOWZyUT07KJyflk5PyyUn55KR8cVK+OClfnJQvTsoXJ+WLk/LFSfnipHxxUr4oKT8aJeVHo6T8aJSUH42S8qO9BBDWd1nuh7KSUpa85Fc+9/fdbp47lKWcsjqnrMEpyzhlvaKxGb7LsqZfyTr6CG577pI8PHZJ455CzJ9Czp9CTZ+CyvwpKH0K+zMppcZhCn3+FMb8Kdj8KfDXhbMUOj2RVHSX0g9ToCfSeQr0XuixTaDePlQ6TOElbV7Xewr9JIWITUrk4c1Zj/lTuLzN2wIVKNBoqECCCqSoQB0VaKACGSqQowIFKhCKDANFBkORwVBkMBQZDEUGQ5HBUGQwFBkMRQZDkcFQZHAUGRxFBkeRwVFkcBQZHEUGR5HBUWRwFBkcRYbv2AHwPAmUWdt3o93+dJd1fOtvut1lq/v9A5LjK8vYryx18K1r4ztWC7j16+T6++T6x+T6bXL9Mbn+mlt/Ts7PnJyfOTk/c3J+5uT8/I5dCG79k/P/O7YruPVPXr9q8vuXmrz+1uT1tyavv9+xU8Ktf/L6W5PX35q8/ha8/kZsA4EaJUeSik2StcYnSfgkKZ+kzidp8EkyPknOJyn4JNHR2xofvYWP3sJHb+Gjt/DRW/joLXz0Fj56Cx+9hY/ewkdv5aO38tFb+eitfPRWPnorH72Vj97KR2/lo7fy0bvz0bvz0bvz0bvz0bvz0bvz0bvz0bvz0bvz0bvz0Xvw0Xvw0Xvw0Xvw0Xvw0Xvw0Xvw0Xvw0Xvw0Xvw0dv46G189DY+ehsfvY2P3sZHb+Ojt/HR2/jobXz0dj56Ox+9nY/ezkdv56O389Hb+ejtfPR2Pno7H72Dj97BR+/go3fw0Tv46B189A4+egcfvYOP3sFH7+Sjd/LRO/nonXz0Tj56Jx+9k4/eyUfv5KN38tG7+OhdfPQuPnoXH72Lj97FR+/io3fx0Ztv19L4di2db9fS+XYtnW/X0vl2Lb3R0dv5di2db9fS+XYtnW/X0vl2LZ1v19L5di2db9fS+XYtnW/X0vl2LZ1v19L5di2d/7vezr7Tx7XNn8L0Xw7l/F9Xp/u1tfQwBfqvqztPYcyfAv1XdJ2nQP9NrOcp0H/j3mMKfpgC/TexnqfAX53PUuj81fk0Bf7qfJrCVNX5OIWpqvNxCvTVuet2v9CHHKbA/wWapynQV+fzFOir83kK9NX5PAX66nyawqCvzg8pWDtMgb46n6dAX527bm86dT9Ogb46d/GTFPir82kK/NX5NAX+6nzyDd0++EvbaQr8pe0sBeMvbacp8Je20xT4S9tpCvyl7TSFV0C1W9+Od/evUthkBaes5JRVlLK8ccp6CTvbdnUZIoeylFNW55Q1OGUZpyznlBWcspJTVlHKisYpi5PywUn54KR8cFI+OCkfnJQPTsoHJ+WDk/LJSfnkpHxyUj45KZ+clE9Oyicn5ZOT8slJ+eSkfHFSvjgpX5yUL07KFyfli5PyxUn54qR8cVK+KCkfjZLy0SgpH42S8tEoKR+NkvLRKCkfjZLy0SgpH42S8tE4KS+clBdOygsn5YWT8sJJeeGkvHBSXjgpL5yUF07KKyfllZPyykl55aS8clJeOSmvnJRXTsorJ+WVk/Kdk/Kdk/Kdk/Kdk/Kdk/Kdk/Kdk/Kdk/Kdk/Kdk/KDk/KDk/KDk/KDk/KDk/KDk/KDk/KDk/KDk/KDk/LGSXnjpLxxUt44KW+clDdOyhsn5Y2T8sZJeeOkvHNSnnP3NTh3X4Nz9zU4d1+Dc/c1OHdfg3P3NTh3X4Nz9zU4d1+Dc/c1OHdfg3P3NTh3X4Nz9zU4d1+Dc/c1OHdfg3P3NTh3X4Nz9zU4d1+Dc/c1OHdfg3P3NTh3X4Nz9zU4d1+Dc/c1OHdfg3P3NTh3X4Nz9zU4d1+Dc/c1OHdfg3P3NTh3X4Nz9zU5d1+Tc/c1OXdfk3P3NRsl5ZNz9zU5d1+Tc/c1OXdfk3P3NTl3X5Nz9zU5d1+Tc/c1OXdfk3P3NTl3X5Nz9zU5d1+Tc/c1OXdfk3P3NTl3X5Nz9zU5d1+Tc/c1OXdfk3P3NTl3X5Nz9zU5d1+Tc/c1X7L72nP/SqLRjmV1TlmDU5ZxynJOWcEpKzllFaWsl+y+focs4ZTFSfnBSfnBSfnBSfnBSfnBSfnBSfnBSXnjpLxxUt44KW+clDdOyhsn5Y2T8sZJeeOkvHFS3jkp75yUd07KOyflnZPyzkl556S8c1LeOSnvnJQPTso/aZtT9jjaRp7JsmzbcUvbT4+xqxqUqoxSlVOqCkpVSamqGFU9aY3z2aqEUpVSqqJke1KyPSnZnpRsz1ew3dve+bjGkaqkVFWMqqpRqhJKVUqpqlOqGpSqjFKVU6qiZHtRsr0Y2V6Nke3VGNlejZHt1RjZXo2R7dUY2V6Nke3VGNlejZHt1SjZLpRsF0q2CyXbhZLtQsl2oWS7ULJdKNkulGwXSrYrJduVku1P2euTMt/CSNU//L5oPWWt7/mqglJVUqoqRlVPWel7viqhVKWUqjqlqkGpipLtnZLtnZLtnZLt/RVsP+1kRqNUJZSqlFJVp1Q1KFUZpSqnVBWUqpJSFSXbjZLtRsl2o2S7UbLdKNlulGw3SrYbJduNku1GyXanZLtTst0p2e6UbHdKtjsl252S7U7Jdqdku1OyPSjZHpRsD0q2ByXbj3fivkzjb6qatzNVQ/0oyuFhFbF7wrofFpWD0xW1XbnJ/dXR0Q4O+/52q+f9whp9TzbfJ9mI7cqRfphsLZTs8WLguyYrKyWrKyXb3yhZjz3ZOEx2rJSsrZSsr5TsG3VQ58m+Uwd1muw7dVD3ZOuw9NQ7dVCnyb5TB+WbjHx4nM5jsu/UQXk7SfatOqizZMdKyb5RB5X7lVMP36moN2oqzpN9o6biPNk3aipOktXW3qipyNyTLTlM9o2aivNk36ipOE/2jZqK82THSsm+U1MRsSd7TOM3elvmPNl36qBOk32nDuo02XfqoM6SlXfqoE6TfacOak+22mHpkXfqoML3ZP0w2XfqoLxOkh0rJftOHdRpsu/UQZ0m+04d1Gmy79RBnSb7Th3UWbKKrrOSso303f7oXyW7aeqEmgahJiPU5ISaAq5p9F2T5aGmJNRUfJp6I9QkhJqUUFMn1DQINRmhJifUhOe47gsCOdqhpiTUVHyaRiPUJISalFBTJ9Q0CDUZoSYn1ETI8UHI8UHIcSPkuBFy3Ag5boQcN0KOGyHHjZDjRshxI+S4EXLcCTnuhBx3Qo47IcedkONOyHEn5LgTctwJOe6EHA9Cjgee4/fPRPPhUcKPmpRQUyfUNAg1GaEmPMdz1/T4Wf6jpiDUlISaik9TNkJNQqhJCTV1Qk2DUBOe4553jh9rckJNQagpCTUVn6ZqhJqEUJMSauqEmgahJkKOFyHHi5DjRcjx4uO4ND6OS+PjuDQ+jkvj47g0Po5L4+O4ND6OS+PjuDQ+jksj5LgQclwIOS6EHBdCjsO3V798HfD+vkrvh5qMUJMTagpCTUmoCc7x6ndNdvR5i2gj1CSEmpRQUyfUNAg1GaEmJ9QUhJrwHBe/c3wcaio+Tfh9zu/QJISalFBTJ9Q0CDUZoSYn1BSEmgg53gk5Pgg5Pgg5Pgg5Pgg5Pgg5Pgg5Pgg5Pgg5Pgg5Pgg5boQcN0KOGyHHjZDjRshxI+S4EXIcv89ZcdeUeqgpCTUVnyb8Pud3aBJCTXiOp++XbseaOqGmQajJCDU5oaYg1JSEmopPE36f8zs04Tnuduf44WfU+H3O79DUCTUNQk1GqMkJNQWhpiTUVHya8Puc36GJkONJyPEk5HgScjwJOZ6EHE9Cjichx5OQ40XI8SLkeBFyvAg5XoQcL0KOFyHHi5DjRcjx4uO44r9ruWnfL93boSYh1KSEmjqhpkGoCf5lc62P/dJ2rMkJNQWhpiTUVHya8N/4+h2ahFCTEmrqhJrwHBe9c1wONRmhJifUFISaklBT8WnSRqhJCDUpoaZOqImQ40rIcSXkuBJyXAk5roQc74Qc74Qc74Qc74Qc74Qc74Qc74Qc74Qc74Qc74QcH4QcH4QcH4QcH3iOh+yXjjzUNAg1GaEmJ9QUhJrwHM/dd3I4F62j+DRZI9QkhJqUUFMn1DQINRmhJifUhOe43y8ddagpCTUVnyZvhJqEUJMSauqEmgahJiPU5ISaCDnuhBx3Qo4HIceDkONByPEg5HgQcjwIOR6EHA9Cjgchx4OQ40nI8STkeBJyPAk5noQcT0KOJyHHk5DjScjxJOR4EXL8V/YUo7aFD8mHL+o41pT7p4TZ70H6l1y+OVv3bzdvcj98+wz44LDnJt8fnqh164139YNYfcS2GBYP3+fzqN6mVu9Tq4+p1efU6otZvceuPg7U91/Z5pxFvUytXqdWz1xrz9VT19pT9dS19q6+/FA9da09VU9da33rp7PJoXrqWrs3+L+mnrvWnqgX7lp7pp651qZsXVqqHqpnrlbn6pmr1bl65mp1rp65WmXu6uvYtczV6lw9c7U6V89crU7VK3O1OldPXa0idvWHzFHmO8Nz9dS19lQ9da09VU9da0/VU9faU/XUtXZXX8f9vVLX2v3rSKod3pUrda31+lx9p661p+qpa+2peupae6qeutaeqqeutafqqWvtqfon8H7UFsQeisoX9VuQAgQZDRFEEEEUEeQJyLD9EZqmeRhkIIIYIogjggQiyBMcb33jlT08BvAxSAGCWEMEEUQQRQTpiCADEcQQQRwRJBBBnuH4vUMxrcMgBQjiDRFEEEEUEaQjggxEEEMEcUSQQARBON4Rjg+E4wPh+EA4PhCOD4TjA+H4QDg+EI4PhOMD4fhEOD4Rjk+E4xPh+EQ4PhGOT4Tj8xmO3x/hZRGHQRIRpABBqiGCCCLIMxyfe5CH0dPHIB0RZCCCGCKII4IEIkgigtT1QcYz9k3OgzzD8fs8rEUeBlFEkI4IMhBBDBHEEUECESQRQQoQ5BlT7+dBEI4XhOMF4XhBOF4QjheE4wXheEE4XhCOV4TjFeF4RTheEY5XhOMV4XhFOF4RjleE4xXh+I5wfEc4viMc3xGO7wjHd4TjO8LxHeH4jnB8v9bxt7/9/x///acf/+nPf/rr7Se+/ON//PzPv/z0l58//vrLf/7b3//ldva/AQ=="},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"5Z3bjhzHEUT/hc+CUZlZt9SvGIZB62IQEChBogwYgv7dQ2lndg2O2Qxwq/a0+SReqrsilcxTO7Ed27+9+va7f/z6z7+/efv9j7+8+vqvv7364cdvXr978+Pby+9+e1X+YvbHn/7y0+u37//gl3evf3736uvy1avv3n57+e/vX736/s0P3736OrL9/rev3l/g6gWhXlDVC5p6QVcvGOoFU70gP/2Crz5Yl609rMwxbmvN/c7aauO6uNqst9V3b9w9xsPi7i2eLv5DtpfPkW0l/GGplVa3CrfP+v+d9qi7Heg2s3pdbaN8XPeotyJHs/mhbl+k+8+7x9K716V3b0vv3pfefSy9+1x691x59yhL725L7750VmPprMbSWY2lsxpLZzWWzmosndVYOqt16azWpbNal85qXTqrdems1qWzWpfOal06q3XprNals9qWzmpbOqtt6ay2pbPals5qWzqrbemstqWz2pbOals6q33prPals9qXzmpfOqt96az2pbPal85qXzqrfems9qWzOpbO6lg6q2PprI6lszqWzupYOqtj6ayOpbM6ls7qWDqrc+mszqWzOpfO6lw6q3PprM6lszqXzupcOqtz6azOpbOaS2c1l85qLp3VXDqruXRWc+ms5tJZzaWzmktnNZfOqpWy9va29va+9vax9vZ17e3b2tv3tbcfa28/195+7dTa2qm1tVNra6fW1k6trZ1aWzu1tnZqbe3U2tqptbVT62un1tdO7drHmWzt80y29oEm+7wnmmr49bGzGuG31fcfl4s5Hxb3Wj58XM4+7/mnZ310z1x+GtPlxzGVp5r+vEJ5UunhCvnZ29AfvpWfvlWe/Hm4Qn7+NuQHcEPuecg9D7nnVe55lXte5Z5X/YlruedV7nmVe17lnle551XueZN73uSeN7nnTe55k3ve5J43uedN7nmTe97knne5513ueZd73uWed7nnXc9WyD3vcs+73PMu93zIPR9yz4fc8yH3fMg9H3LPhx6okXs+5J4PuedT7vmUez7lnk+551Pu+ZR7PuWeTz1FJfd8yj1Puecp9zzlnqfc85R7nnLPU+55yj1PPTqn9txLka8w+QqXrwj5iipf0eQrunzFkK+Y8hVyz03uuZyNdTkc63I61uV4rMv5WJcDsi4nZF2OyLrJPXe55y733OWeu9xzl3vucs9d7rnsw7nsw7ns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"},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/62UTY7TQBCFy06cTIhjO07scRIj8WOLBWtYcgTugARCSAiENCuWHIFjcamhX1VXXn6kkUaaltouV7+vq7ra3YNMRG5CF3kusaXBI4XMwitB/yBu2aAkhSTuGjGo1BhlMnkVHs9Gnyp9hwHlSvim+szeqg0r9NkgCdBphpkR2oYGpCcAFqOnNxd1oi3wMA2wm4EjYcKPSMPE8yhejqk5ZUlsaZqFmYr+pNvRXFEIcqI50Tyid3Q7ulIUghXRFdFVRF/Q7WihKAQF0YJoEdFvdDtaKgpBSbQkWkb0B92OVopCUBGtiFb2vkaKxyP5k0cJa/pEt6NrRSFYE10TXUf0O92O1opCUBOtidbXidbHRB9AQrTfdDu6URSCDdEN0U1Ev9Dt6FZRCLZEt0S3Ef1Mt6ONohA0RBuiDd4vcbTueDArBYWn0Y8f1DL6EQ0zToWt1VDteahbgxszfQS/4C1FOx7w/UzNfdQf4gXSJyrs4ULXjH/Zly8XTD+6rGNgG0jNiUGPsMMbp/PrSVoXCb9P/B8c9Eo7bZhypjeq9WsF4MwUGesLb3esb8v6ducXX/MmjVPjq2WVdtTEgu3ikqwyf2Bp5rFN4s5AdtAaoYydZdbZxpzlfh8aVKY42FZk9xcNQU2B2HvOcRJaelNgU/r0OJ1u5cWnHD/351w7V7OJq+h1kX9hcZGjF7AdY1UlfQ2z+4f+HxPwja4SBwAA","debug_symbols":"7dvRalpBEMbxdznXUnZ2dnZ28yqlFJOYIgQN0RSK5N2rjeeYkKVehH/U6FVQJ5NvB35shDmr7nZy/fTr53R2N190V99X3f38ZryczmfrV6sufJPw793Fw3i2eWOxHD8uu6sw6iaz2/XP51F3N72fdFda7Xn0rq6abSur+1ArMTZqk3hfnKSkobrZOEf1bXGOpq+Lf4w2seUjsSVo3JZKsPSpweOH5l1ll9v25BaR1FeLh//n9jQc0k3K+9wK5X7pntDuhnbPaHdHuxe0eyW7x4B2F7R7RLujViNqNaJWI2o1olYjajWiVhW1qqhVRa0qalVRq4paVdSqolYVtaqo1YRaTajVhFpNqNWEWk2o1YRaTajVhFpNqFVDrRpq1VCrhlo11KqhVg21aqhVQ60aajWjVjNqNaNWM2o1o1YzajWjVjNqNaNWM2rVUauOWnXUqqNWHbXqqFVHrTpq1VGrjlotqNWCWi2o1YJaLajVglotqNWCWi2o1YJarajVilqtqNWKWq2o1YparajVilqtqNWKWpUQ2PbCto9se3YfIiS2PbsREdiViMDuRAR2KSKwaoVVK6xaYdXCW0zwGhO8x9ReZJLkw+9Z8D1/RFxzX+1lF0lSbVSbar+hZprrUN1sbVK1L46yp7iso26Li6XW/mA5o8O2V6W+6mHlnA4bz+mwek6HTed0WPv8w0odDrt3Obr0nb3ubs5Yah8/n3Z8P+345bTj15OOr+G048tpx4/HHT/rED+/id/4fqJ93/rq8mnXupWh7+6BnKj9VPQylcZUjvySPdBUjvzyO9BUjvxSOsxU0pHfdQeaypFfoQeayuVmbk3lcjO3ppIuU2lM5fL/ytuprF/8Hj9Ox9f3k83T+5vPnmY3/cP865fLPw8vn6xr/wI="},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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+OqtXnz1Vi++eqsXX73Vi6/e6sVXb/Xiq7d68dVbvfjqrV589VYvvnqrF1+91Yuv3urFV2/14qu3evHVW7346q1efPVWL756qxdfvdWLr97qxVdv9eKrt3rx1Vu9+OqtXnz1Vi++eqsXX73Vi6/e6sVXb/Xiq7d68dVbvfjqrV589VYvvnqrF1+91Yuv3urFV2/14qu3evHVW7346q1efPVWL756qxdfvdWLr97qxVdv9eKrt3rx1Vu9+OqtXnz1Vi++eqsXX73Vi6/e6sVXb/Xiq7d68dVbvfjqrV589VYvvnqrF1+91Yuv3urFV2/14qu3evHVW7346q1efPVWL756qxdfvdWLr97qxVdv9eKrt3rx1Vu9+OqtXnz1Vi++eqtXX73Vq6/e6tVXb/Xqq7d6XcRXuq5UVfXVW7366q1effVWr756q1dfvdWrr97q1Vdv9eqrt3r11Vu9+uqtXn31Vq++eqtXX73Vq6/e6tVXb/Xqq7d69dVbvfrqrV599VavvnqrV1+91auv3urVV2/16qu3evXVW7366q1effVWr756q1dfvdWrr97q1Vdv9eqrt3r11Vu9+uqtXn31Vq++eqtXX73Vq6/e6tVXb/Xqq7d69dVbvfrqrV599VavvnqrV1+91auv3urVV2/16qu3evXVW7366q1effVWr756q1dfvdWrr97q1Vdv9eqrt3r11Vu9+uqtXn31Vq++eqtXX73Vq6/e6tVXb/Xqq7d69dVbvfrqrV599VavvnqrV1+91auv3urVV2/16qu3evXVW7366q1effVWr756q1dfvdWrr97q1Vdv9eqrt3r11Vu9+uqtXn31Vq++eqtXX73Vq6/e6tVXb/Xqq7d69dVbvfrqrV599VavvnqrV1+91aur3up5cdVb/ZauJ1V1S9eTqrql60lV3dIVX+l6UlW3dD2pqlu6nlTVLV1PquqWri9V5aq3+i1dX6rKVW/1W7q+VJWr3uq3dH2pKle91W/p+lJVrnqr39L1papc9Va/petLVbnqrX5L15eqctVb/ZauL1Xlqrf6LV1fqspVb/Vbur5Ulave6rd0fakqV73Vb+n6UlWueqvf0vWlqlz1Vr+l60tVueqtfkvXl6py1Vv9lq4vVeWqt/otXV+qylVv9Vu6vlSVq97qt3R9qSpXvdVv6fpSVa56q9/S9aWqXPVWv6Xr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4tZqVZnehLfErdWqMr3bbolbq1XVelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W73Xelu913pbvdd6W71nen3767t+vL7r9br52p98H0vrr6+8//j0cly/+8rn9frK681X3tv667N72wYjStQVco7oyPTKedYRJepkWUeUqEdmHVGi7pt1RI0RRR9RIsfIOqJEt81ZR5TohjzriLhdCD8ibhd8R3Q+v/B+7b8fUaZtH1lHxO1C+BFxuxB+RNwu+I7o+B5RH4yoMaLoI+J2IfyIuF0IPyJuF8KPiNuF8CPidsF3RPvzN4D2/vvfADoybb3KOiJuF8KPiNuF8CPidiH8iBojij4ibhfCj4jbhfAj4nYh/Ii4XQg/Im4Xoo8o0/bHrCPidiH8iLhdCD8ibhfCj6gxougj4nYh/Ii4XQg/Im4Xwo+I24XwI+J2IfqIMm1BzjoibhfCj4jbhfAj4nYh/IgaI4o+Im4Xwo+I24XwI+J2IfyIuF0IPyJuF6KPaOd2IfyIuF0IPyJuF8KPiNuF8CNqjCj6iLhdCD8ibhfCj4jbhegj6nW9SPv2Yq9rL2KQdR1DDLKuCYhBNkBqQNZt1WKQdbuvGGTdhioGWfenVGKQdX+WpAV5YDYikJiNBeT9k8gHZiMCidmIQDZAakBiNhaQ94+MHpiNCCRmIwKJ2YhAYjYakCdmIwKJ2Wh+inhiNiKQmI0IZAOkBiRmIwKJ2YhAYjYikJiNCCRmowF5YTYikJiNCCRmIwKJ2YhANkBqQGI2IpCYjQgkZiMCidmIQGI2EpDnA7MRgcRsRCAxGxFIzEYEsgFSAxKzEYHEbEQgMRsRSMxGBBKz0YBcMBsRSMxGBBKzEYHEbEQgGyA1IDEbEUjMRgQSsxGBxGxEIDEbDcg1do9cXwmu7XjcgLyO59/5X8c2iBu77cnjtlpxYzcnedzY/UYeN3YL+SjuZ//mX+frS1+jf8djNwtnOLHbgi+cLfbdpjOc2PeVznASdUc9nERNUw+nVYXzib6Nv+dvkIkary/IRF3aF2TZlq4GWbbRq0GWbf9ikMG3108EsqxVqEGWNRA1yLK2ogbZAKkBidmIQGI2IpCYjQgkZiMCidloQAbfnD0RSMxGBBKzEYHEbEQgGyA1IDEbEUjMRgQSsxGBxGxEIDEbDcjgu68nAonZiEBiNiKQ1B/L38DcLn88gy/InQdk8HWkUUDe/1VW8HWkE4HksBGB5BpNBLIBUgOSazQRSHqkAWRf+q/P9m0dgKRHikByjSYCyTWaBmTwdaQTgcRsRCAxGxFIzEYEsgFSAxKzEYHEbEQgMRsRSMxGBLKu2Xzwffz1y72+8vbzIbr+jTL4QtKpUNa1GznKun4jR1nXcOQoGyhVKOtajhxlXc/5CGX/5vE338dPlHVNR46yruvIUWI7IpRX8CWlU6HEdmQosR0ZSmznY5THAGUDpQoltiNDie0M/yjkCr6E1BkORvIGDo4xhhN8AagzHDzgDRya/Rs4mdYx3T57fwVfkSmPm2kdkyFupnVMhriJmqYlbqLuaImbqA0a4q6J+p0lbqLGZombacmlIW6tVpVqyaUhbq1WlWrJpSFurVaVaW2lJW6tVpVptaQlbq1WlWn9oyVurVaVaUWjJW6tVpVp3aElbq1WlWl1oCVurVaVaQ2fJW6tVpVppZ0lbq1WlWk9nCVurVaVadWaJW6tVpVpbZklbq1WlWkFmCVurVaVaZ2WJW6tVpVpNZUlbq1WlWnNkyVurVaVaWWSJW6tVpVp/ZAlbq1WlWmVjyVurVbVW624tVpVpu1Rlri1WlWv1ap6rVaVac+WJW6tVpVpZ5Ulbq1WlWn/kyVurVaVaZeSJW6tVpVpL5Elbq1WlWnHjyVurVaVaV+OJW6tVpVp94wlbq1WlWmPiyVurVaVaSeKJW6tVpVpu4glbq1WVXgfwidLmNv667N72wYg2fkmAsnONxFIdr6JQLLzTQSSbdYKkNej8A4EMUi2WYtAss1aBJJt1iKQDZAakJiNBeT5/ML7tQ9AYjYikJiNCCRmIwKJ2VhAHt8g++9BFt7TIAaJ2YhAYjYikJiNCGQDpAYkZmMB+fo29n4MQGI2IpCYjQgkZiMCidloQGbaUOILErMRgcRsRCAxGxHIBkgNSMxGBBKzEYHEbEQgMRsRSMxGAzLTliBfkJiNCCRmIwKJ2YhANkBqQGI2IpCYjQgkZiMCidmIQGI2GpCZNnX5gsRsRCAxGxFIzEYEsgFSAxKzEYHEbEQgMRsRSMxGBBKz0YDMtC3PFyRmIwKJ2YhAYjYikLF75PJ4fvj6+n+5AXkdz7/zv45tEDd225PHjd3J5HFjNyd13OB76+RxY7eQj+J+9m/+7RuXX3BiNwtnOLHbgjOcBpwxnNj3lc5wEnVHPZxETVMPJ1Ev/eP0bfw9f4NM1HhdQQbfVjgRyLItXQ2ybKNXgyzb/tUgGyA1IMtahRpkWQNRgyxrK2qQmI0IJGajARl8Y+hEIDEbEUjMRgQSsxGBbIDUgMRsRCAxGxFIzEYEErMRgcRsNCCDb+2dCCRmIwKJ2YhAYjYikA2QGpCYjQgkZiMBuQRfkBsE5P3yxyX4gtyJQHLYSP4qawm+jnQikBw2IpBco4lAco0mAsk1mgZk8HWkQUD2pf/6bN/WAUh6pAgk12gikFyjiUA2QGpAYjYikJiNCCRmIwKJ2YhAYjYakMHXkU4EErMRgcRsRCDrms0H38dfv9zrK2/nj++j/0DZQKlCWddu5Cjr+o0cZV3DkaOs6zhylHUtR40y+HLSMCj7N4+/eZX3J8q6piNHWdd15CixHRnKBkoVSmxHhhLbkaHEdj5GeQxQYjsylNiOCmXwhaUuKL/h4C9v4GAkb+DgGG/gNOCM4eABb+DQ7N/AybSO6fbZ+yX4ikx53EzrmO7jBl83KY+bqGla4ibqjpa4idqgJW6rFTdRY7PEzbTk0hC3VqtKteTSELdWq0q15NIQt1aryrS20hK3VqvKtFrSErdWq8q0/tESt1aryrSi0RK3VqvKtO7QErdWq8q0OtASt1aryrSGzxK3VqvKtNLOErdWq8q0Hs4St1aryrRqzRK3VqvKtLbMErdWq8q0AswSt1aryrROyxK3VqvKtJrKErdWq8q05skSt1aryrQyyRK3VqvKtH7IErdWq8q0yscSt1arumq1qqtUq1ozbY+yxC3VqtZHqVa1Pkq1qvXRasUt1arWTDurLHFLtao10/4nS9xarSrTLiVL3FqtKtNeIkvcWq0q044fS9xarSrTvhxL3FqtKtPuGUvcWq0q0x4XS9xarSrTThRL3FqtKtN2EUvcWq2q8D6ET5Ywt/XXZ/e2DUCy800DsvAuBDFIdr6JQLLzTQSSbdYikA2QGpBssxaBZJu1CCTbrEUgMRsRSMzGAvJ8fuH92n8PsvDeAzFIzEYEErMRgcRsLCCPb5B9ALIBUgMSsxGBxGxEIDEbEUjMRgQSs7GA3J8/Rdz74KeImTZn+ILEbEQgMRsRSMxGBLIBUgMSsxGBxGxEIDEbEUjMRgQSs9GAzLS9xhckZiMCidmIQGI2IpANkBqQmI0IJGYjAonZiEBiNiKQmI0GZKYNUr4gMRsRSMxGBBKzEYFsgNSAxGxEIDEbEUjMRgQSsxGBxGw0IDNtcfMFidmIQGI2IpCYjQhkA6QGJGYjAonZiEBiNhqQwffWPdbn93E9+nkDUvwmQPAdd65oYnc9VzSx25srmgaaEZrYDcsVTezO5IomdgtyRRP7xtYVTew7WEc0W/B9g65oqrbh24dxtuB7DF3RVG3DBjQNNCM0Vdvw7XMeW/C9i65oqrZhA5qqbdiApmobvkcTfE+kK5qqbfj2Jwpb8P2TrmiqtmEDmgaaEZqqbdiApmobNqCp2oYNaKq2YQOaqm34Hk3w/Z6uaGjDQzS04SEa2vAQTQPNCA1teIiGNjxEQxseoqEND9HQhkdogm+wdUVDGx6ioQ0P0dCGh2gaaEZoaMNDNLThIRra8BANbXiIhjY8QhN866krGtrwEA1teIiGNjxE00AzQkMbHqKhDQ/R0IaHaGjDQzS04RGa2HsJz2N//nrveVxNieb+r+hibxr0RdNAM0ITutf4ognda3zRhO41vmhC9xpfNKF7jSua2HvyfNGEvuXzRUMbHqKp2obv/wQ+9r45XzRV27ABTdU2bEBTtQ3f/zFz7L1tvmiqtuF7NLF3q/miqdqGDWiqtmEDmqpt+P4nCrF3lPmiqdqGDWiqtmEDmqpt2ICmahs2oKnahu/RxN7H5Yumahs2oKnahg1oaMNDNA00IzS04SEa2vAQDW14iIY2PERDGx6hib1VzBcNbXiIhjY8REMbHqJpoBmhoQ0P0dCGh2how0M0tOEhGtrwAE2LvVXMFw1teIiGNjxEQxseommgGaGhDQ/R0IaHaGjDQzS04SEa2vAITeytYr5oaMNDNO3vjkb6t27NYYuTOECfPcAxe4Bz9gDX5AEcdgCJAyyzB1hnD7DNHmD2k3iNfRLf/ilrW2OfxIYAsU9iQ4DYJ7EhQOyT+PaP5doW+yQ2BIh9EhsCxD6JDQFin8SGALFPYkOA2Cfx/a3EFvskNgSIfRIbAsQ+iQ0BYp/E9wFa7JPYECD2SWwIEPskNgSIfRIbAsQ+iQ0BZj+J2+wncZv9JG6zn8Rt9pN4n/0k3mc/iffZT+J99pPY4RV5cYDZT+J99pN4n/0k3mc/iffZT+I++0ncZz+J++wncZ/9JHZ4wVocYPaTuM9+EvfZT+I++0ncZz+Jj9lP4mP2k/iY/SQ+Zj+JNe+gLs/vaV16Uwa4/40tzWulngHO2QNckwfQvM/pGWCZPcA6e4Bt9gBt9gD77AFmP4nP2Cfx/S++nrFPYkOA2CfxfYAr9klsCBD7JL7/tcsr9klsCBD7JDYEiH0SGwLEPokNAWKfxIYAsU/i+1uJK/ZJbAgQ+yS+DbA/Yp/EhgCxT2JDgNgnsSFA7JPYECD2SWwIEPskNgSIfRIbAkx+Eu+PyU/i/TH7SbzMfhIvs5/Ey+wn8TL7Sax54ckzwOwn8TL7SbzMfhIvs5/Ey+wn8Tr7SbzOfhKvs5/E6+wnseaFJ88As5/E6+wn8Tr7SbzOfhKvs5/E2+wn8Tb7SbzNfhJvs5/EmheePAPMfhJL3hd6tP0Z4HE9lAFuf2Nrl7wv5BlA8r6Qa4Bl9gDr7AG22QO02QPsswfoswc4Zg8w+0ncYp/Et7/4uu+xT2JDgNgnsSFA7JPYECD2SXz7a5e75H0h1wCxT2JDgNgnsSFA7JPYECD2SWwIEPskvr+V6LFPYkOA2CexIUDsk9gQIPZJbAgQ+yQ2BIh9EhsCxD6JDQFin8SGALFPYkOA2U/iY/aT+Jj9JD5mP4mP2U/iY/aT+Jj9JD5mP4mP2U/iY/aT+Jj9JD5nP4nP2U/ic/aT+Jz9JJa88OQaYPaT+Jz9JD5nP4nP2U/ic/aT+Jr9JL5mP4mv2U/ia/aTWPLCk2uA2U/ia/aT+Jr1JP76T//9j//xp3/8p3/9l//8+l/89b/8rz//81/+9G9//vUf//I///5//83XZ/8X"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_private_parameters"}}],"kind":"struct","path":"TokenBridge::claim_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_public_parameters"}}],"kind":"struct","path":"TokenBridge::claim_public_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_public_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::get_token_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::constructor_parameters"}}],"kind":"struct","path":"TokenBridge::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi"}]}},"file_map":{"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"143":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"146":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"303":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n// docs:end:token_types_all\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"360":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr","source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"395":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_bridge_contract/src/main.nr","source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n"},"44":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"86":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}