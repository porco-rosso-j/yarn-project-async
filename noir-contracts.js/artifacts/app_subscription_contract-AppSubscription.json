{"transpiled":true,"noir_version":"0.31.0+6237d96a0bc23a5ed656e7ba172fb57facd9c807","name":"AppSubscription","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3hbuxKdp7he5nfRsAiF8libiUIgkniBAMY4yCeBAgM33t07E1Kx6f6tDbXd74uqd5/x0lLKj7TYq+3eqvrn//03//+v/6f//lf/vLX//GP//Sn//if/vlP//CP/+3Pf/vLP/717f/65z9N/2Gu//r/+k//689//eX/4Z/+9uf//bc//cd12v/uT3//1//+9l91/Ze/+9P/+Ms//P3bf5d/+c9/98vXHD//Ncvc+pp6fU09Gl+z3PiarfU1pcznF5V5Wn77Vfudr4qp+VWxbudXxVZ++1Xl1lfNt75qufVVceur1ltftd36qv3WV9VbX3Xc+ar11nNjvfXcWG89N9Zbz4311nNjvfXcWG89N9Zbz4311nNjvfXc2G49N7Zbz43t1nNju/Xc2G49N7Zbz43t1nNju/Xc2G49N7Zbz4391nNjv/Xc2G89N/Zbz4391nNjv/Xc2G89N/Zbz4391nNjv/XcqLeeG/XWc6Peem7UW8+Neuu5UW89N+qt50a99dyot54b9dZz47j13DhuPTeOW8+N49Zz47j13DhuPTeOW8+N49Zz47j13DhuPTfKNN37snLvy+Z7X7bc+7K492XrvS/b7n3Zfu/L6r0vu/csKfeeJeXes6Tce5aUe8+Scu9ZUu49S8q9Z0m59ywp954l5d6zZL73LJnvPUvme8+S+d6zZL73LJnvPUvme8+S+d6zZL73LJnvPUuWe8+S5d6zZLn3LFnuPUuWe8+S5d6zZLn3LFnuPUuWe8+S5d6z5N4Garm3g1rubaGWe3uo5d4marm3i1rubaOWe/uo5d5Garm3k1rubaWWe3up5d5marm3m1rubaeWe/up5d6Garm3o1rubamWe3uq5d6marm3q1rubauWe/uq5d7GanmwJzDPy/lly3F8/LK/+82DYyn1x4Nj2abrwW/je+PRRxzx49HHur6/YTbHdC6p9Lekub8lLf0tKfpb0trfkrb+lrT3t6Ta35KO3pY0T93dveepu7v3PHV3956n7u7e89Td3Xueurt7z1N3d+956u7uPU/d3b3nqb+7d+nv7l36u3uX/u7epb+7d+nv7l36u3uX/u7epb+79+y+Cazr8ePB6/6+RzHv67mgubcFuZ/aa53PBdXaWtDW24L23hZUe1vQ0dmClqm3BZXeFiS4D83HhwWVJwt6ezvk/M7bfj12KdeClt4W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0wxOaZrBKU0veGEOV4LXcsLVcrS4mcKl3Mu54rruLW5mcCt3wO3kZjqxcjObWLnZA3dyz+yAW7mZu63czN1WbuZuK3fA7eRm39vKza63lZuqtHJTlVZuqlLKfS2i1tZ+90JVWrmpSis3VWnlpiqt3AG3k5uqtHJTlVZuqtLKTVVaualKJ3dQlVZuqtLKTVVaualKK3fA7eSmKq3cVKWVm6q0clOVVm6q0sm9UpVWbqrSyk1VWrmpSit3wO3kpiqt3FSllZuqtHJTlVZuqtLJvVGVVm6q0spNVVq5qUord8Dt5KYqrdxUpZWbqrRyU5VWbqrSyb1TlVZuMsfKTeZYuQNuJzeZY+Umc6zc6UFwuQBj2Z5xr+vx48HrXt793q7ix3rq1Nl6SmfrmTtbz9LZesK7nuP8wPZt2prrWTtbz9bZevbO1lM7W8/R13oO8/25zufve63N9ZTO1jN3tp6ls/VEZ+tZO1vP1tl69s7WUztbz9HVesrU1/25TH3dn8vU1/25TH3dn8vU1/25TH3dn8vU1/25TH3dn8vU1/25TJ3dn0tn9+fS2f25dHZ/Lp3dn0tn9+fS2f25dHZ/Lp3dn0tn9+fS2f157uz+PHd2f547uz/Pnd2f587uz3Nn9+e5s/vz3Nn9ee7m/vz2f/3fP//vv/z5v/7D3//T21f88v/5f/763/72l3/864//82//73/92//P22P/Pw=="},{"name":"subscribe","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"subscriber_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"expiry_block_number","type":{"kind":"field"},"visibility":"private"},{"name":"tx_count","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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if2J5bX0uueclun+L5flSEuve+S09LpHTktyLcW09LpHTkuve+S09LpHTkuve85pef9xqC3pSEuve8S0nNifWF5Lr3vktPS6R05Lr3vktCTXUkzLeeuelPefw2Jewhstb0XN/k/f/vPhjRlqj2rOW/loqDlv7aOh5rzVj4aa89Y/v1MzBtqJxFr+UfN/P31iql6Y2NX4auXnra2uVn7eSuxq5eet265Wnlz5i5T3mvAq5b1+vEp5rzWvUt7r0quU9xr2IuUndqi+WnmvYa9S3mvYq5T3GvYq5cmVv0h5r2GvUt5r2KuU9xr2KuW9hr1Kea9hL1J+Yrfxq5X3fF5D+fdusmFix+irlffc5qrdxnObq5T33OYi5bPnNlcp7/fzVynv9/NfK/+gpufokmqSqymopt+Nn1NzXfJOZKVDNf2+W1JNr/Mk1fTaTVJNr8cE1SxeY0mq6XXTSTXLftkYKC3/qPnk04Xu2ld6YELhUXuvnK7T3uus67Qn1/4y7b2Gu057r/iu097rw+u092ryOu299rxM++qV6nXae117nfZe116nvde112lPrv1l2ntde532Xtdep73Xtddp73Xtddp7XXuZ9s3r2uu097r2Ou29rr1Oe69rr9OeXPvLtPe69jrtva69Tnuva6/T3uva67T3uvYq7ePide112ntde532Xtdep73XtddpT679Zdp7XXud9l7XXqe917XXae917WXaB88xFbQ/MQEtBs8wr1Lez1kN5d/PJIrBT9mrlPcz9irl/eb4IuWj3xtfpbzfGn+t/IOanqNLqul59zk1U9hjDKnUN7sCtZ11Cg//cvhnVyBX/iLl/Vb3KuW91rxKea81r1Lea82rlPda8yLlV681FZRPtP/TKa1HynuteZXyXpdepbzXsFcpT678Rcp7DXuV8l7DXqW817C6yuflSHmvYa9S3mvYi5Qnr2HPKZ9/FMkpvFE+JLp7+KT0OO//8T088ir2Ou29jr1Oe69kr9OeXPvLtPdq9jrtvZ5V0f7+6vUtH41H2ntFe532XtNep71XtZdpn7yuvU57r2uv097rWg3tqS137eu/OeZn927Ja2Ab60S+TibWyWtrjXXK5efTlY7OHK+tr9Pea+vrtPfa+jrtvba+TPvstfV12nttfZ32XluraF/vM4tya0fae718nfbk2l+mvde112nvde112ntd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zvsbibiW67y/evxSy7fTaMLqdY+cll73yGnpdY+cluRaimnpdY+cll73nNPyxP3l6nWPnJZe98hp6XWPmJbkdY+cll73yGnpdY+cll73yGlJrqWYll73yGnpdY+cll73yGnpdY+cll73iGmZvO6R09LrHjktve6R09LrHjktybUU09LrHjktve6R09LrHjktve6R09LrHjEts9c9clp63SOnpdc9clp63SOnJbmWYlp63SOnpdc9clp63SOnpdc9clp63SOmZfG6R05Lr3vktPS6R05Lr3vktCTXUkzLefPLZd1jjEujd1qemGtQ5s0v5bWcN78U17LOm1/Kazlvfimv5bz55e+0PDEjos6bX8prSa6lmJbz3qvLaznvvfovtXzfi1+97pHT0useOS297hHTsnndI6el1z1yWnrdc07LE/eXzeseOS3JtRTT0useOS297pHT0useOS297pHT0useKS3j4nWPnJZe98hp6XWPnJZe98hpSa6lmJZe98hp6XWPnJZe98hp6XWPnJZe94hpObE7vLyWXvfIael1j5yWXvfIaUmupZiWXvfIael1j5yWXvfIael1j5yWXveIaRm97pHT0useOS297pHT0useOS3JtRTT0useOS297pHT0useOS297pHT0useMS1Xr3vktJw2vwz1Lk9oVN9p+X6uQZzXf1xBy2nzSwUtp80vFbScNr9U0HLa/PKXWr6fERHn9R+X13Je/3EFLae9V1fQctp79d9q+bYXP87rP66gJbmWYlp63SOnpdc9clp63SOnpdc957Q8cX85r/+4vJbz+o8raOl1j5yWXvfIael1j5yW5FqKael1j5yWXvfIael1j5yWXvfIael1j5iW8/qPK2jpdY+cll73yGnpdY+cluRaimnpdY+cll73yGnpdY+cll73yGnpdY+YlvP6jyto6XWPnJZe98hp6XWPnJbkWopp6XWPnJZe98hp6XWPnJZe98hp6XWPmJbV6x45Lb3ukdPS6x45Lb3ukdOSXEsxLb3ukdPS6x45LefNL8uS93+6lPZOyxNzDeb1H1fQct78Ul7LefNLeS3nzS/ltSTX8pSWJ3pL5/UfV9By3vxSXst579XltZz3Xl1eS697pLRc5/Uf/6WW7+vxdV7/cQUtve6R09LrHjktybUU09LrHjktve6R09LrHjktve6R09LrHjEt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WG5XpyKeLucayzXqVMTT5VxjuS+dini6nGssF6NTEU+Xc43lBnQq4ulyrrFcdU5FPF3ONZY7zamIp8u5xnJ5ORXxdDnXWG4ppyKeLucay3XkVMTT5VxjuXecini6nGssF4xTEU+Xc43lJnEq4ulyrrFcGU5FPF3ONZa7wamIp8u5xnIJOBXxdDnXWLP5T0U8Xc411vz8UxFPl3ONNeP+VMTT5VzTzaGv082hr9PNoa/TzaGv082hr9PNoW/TzaFv082hb9PNoW/TzaFvC00X8Ww5V5tuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfZtuDn2bbg59m24OfRtrRvmN93L/eGxv/vVS251JfPPZRPHvZxOtR1oOddJfrOVQOcTFWpJrKablUHnPxVoOlVFdrOVQudrFWg6VBV6s5VB3etdqOdY0/4u19LpHTkuve85pWfd/OLV0pKXXPXJakmsppqXXPXJaet1zTsvyo2U+0tLrHjktve6R09LrHjEtx3LUuFhLr3vktPS655yWaf8dMuWj3yHH8he5WEtyLcW09LpHTkuve+S09LpHTkuve+S09LpHTMuxXG0u1tLrHjktve6R09LrHjktybUU09LrHjktve6R09LrHjktve6R09LrHjEtx3KWulhLr3vktPS6R05Lr3vktCTXUkxLr3vktPS6R05Lr3vktPS6R05Lr3vEtBzL3e1iLb3ukdPS6x45Lb3ukdOSXEsxLb3ukdPS6x45Lb3ukdPS6x45Lb3uEdIyLWM5LF6sJXh+SfRDJNHbCXZlnz7QynoUMU0XMXiuphAxeEalEDF43qMQ8f/P3r9lN8/zzALghHp9S6R47LntubepPFby9m8likOCBaLucmGligWLBGAQAPdOfrfi350CP3fqfOgD7nHM1gd9ZuB0fcAzotP1Ac9yTtdnKc9ygD6B+nyrz1Je67go75r1Fy2X8ocna7mUpz1ZS8M+fHctDfv7vbVEn22pSkvDcUR3LQ3HHN21NByfdNcyUMtuWjLu6acl455+WjLu6acl455+WjLu6aYl+nxZVVoy7umnJeOefloy7umnZaCW3bRk3NNPS8Y9/bRk3NNPS8Y9/bRk3NNNy8C4p5+WjHv6acm4p5+WjHv6aRmoZTctGff005JxTz8tGff005JxTz8tGfd00xJ9QrgqLRn39NOSPtEtLX+etv7Qkj5RPy159tzT8kbnAfQpraq05NnTT0vm3PppyZxbPy0DteymJf3LW1om9+xklHZ/pSX9y35aMufWT0vm3Pppybinm5boU1pVacm4p5+WjHv6acm4p5+WgVp205JxTz8tGff005JxTz8tLcc9v2BSsnuusWT/ZY3OfVXTcuTTXU30Sa3K1LQc/fRX03L8019NyxFQfzUD1eyopuUo6FdqhniqGcOVmpbjoP5qWo6E+qvJWKinmoyFOqqJPr1VmZqMhXqqyVjo92omd6UmY6Geagaq2VFNxkI31SyfkWW9iizRJ7kqU5OxUE81GQv1VJOxUD81HfpEV2VqMhbqqSZjoXtqFn/6m2UPV2oyFuqpZqCaHdVkLNRTTcZCPdVkLNRTTcZCPdVkLPR7NcNFRs5Znks9QE3GQj3VZCz0gskXfRjdfK9PoD7f6sMI5Ht9GFN8rw+jhO/1od//vT5LefK1PDvB1HrRCcatNen51oqX8ohvrXgpr/XWipfyQ2+tOJhb8VK+4q0VL+X93VrxUv7crRUv5aHdWrE5n2utKbO3VmzO51prYuutFZvzudaafnprxeZ8rrUmid5asTmfa62pnLdWbM7nWmvC5a0Vm/O51poWeWvF5nyutSYv3lqxOZ9rrSmGt1ZszudaayLgrRWb87nWmq53a8XmfK5ozueK5nyuGMyt2JzPtdaUxFsrNudzRXM+11rzKu+seK2pkrdWbM7nWmtC460Vm/O51pp2eGvF5nyutSYH3lqxOZ9rrSl8t1Zszudaa6LdrRWb87nWmg53a8XmfK61Jq3dWrE5n2utqWW3VmzO51prAtitFZvzudaapHVrxeZ8rrUmUt1asTmfa63JTrdWbM7nWmtC0q0Vm/O51po0dGvF5nyutSb23FqxOZ9rrck3t1Zszudaa4LMrRWb87nWmsRya8XmfK61JprcWrE1n8uvNRnk1oqt+Vx+rQkbt1ZszefyWzC3Yms+l19r4sOtFVvzufxakxNurdicz7XWBIJbKzbnc63Vyf/Wis35XGt127+1YnM+11od8W+t2JzPtVbX+lsrNudzmetD7831offm+tB7c33ovbk+9N5cH3pvrg+9N9eH3pvrQ+/N9aH35vrQe3N96L25PvTeXB96b64PvTfXh96b60PvzfWh9+b60Htzfei9uT703lwfem+uD70314fem+tD7831offm+tB7c33ovbk+9N5cH3pvrg+9N9eH3pvrQ+/N9aH35vrQe3N96L25PvTeXB96b64PvTfXh96b60PvzfWh9+b60Htzfej9Wj3KH7y38+O+/vDfc6knE//DZ2Pw/z4bw36l5VIn/WQtl/IhJmu5lHcyV8u1esFP1nIpj2qylkv5apO1XMoLnKxloJbdtFwqWzhZS8Y9/bRk3HNPy/L8x7HGKy0Z9/TTknFPNy3XmscwWUvGPfe0zJ9apistGff005JxTz8tA7XspiXjnn5aMu7ppyXjnntaxufvkDFd/Q651nyRyVoy7umm5VozUSZrybinn5aMe/ppybinn5aBWnbTknFPPy0Z9/TTknFPPy0Z9/TTknFPLy33teYSTdaScU8/LRn39NOScU8/LQO17KYl455+WjLu6acl455+WjLu6acl455uWq41G2yylox7+mnJuKeflox7+mkZqGU3LRn39NOScU8/LRn39NOScU8/LRn3dNNyrfl8k7Vk3NNPS8Y9/bRk3NNPy0Atu2nJuKefluD+pcv7pzj5xw52+dl9oOb9asXgXmD/FaPP9RuwYnCPasCKwf2eASsG905+t+LfnQI3OnXu6FMAp+sD7kVM1wc8IzpdH/As53R9lvIsB+izlB/aXx/0yYgj9flNlHfN+ouWS/nDk7VcytOerKVhH767loFadtPScGzQXUvDcUR3LQ3HHN21NByfdNfScCzTW0v06aSqtGTc009Lxj39tGTc00/LQC27acm4p5+WjHv6acm4p5+WjHv6acm4p5uW6BOCVWnJuKeflox7+mnJuKefloFadtOScU8/LRn39NOScU8/LRn39NOScU83LdEnhKvSknFPPy0Z9/TTkj7RLS1vTA/e0acHa9ISfUorjJY3btKiT2lVpSXPnn5aMufWT8tALbtpyZxbPy3pX97SMrn077Np91da0r/spyVzbv20ZM6tm5boU1pVacm4p5+WjHv6acm4p5+WgVp205JxTz8tGff005JxTz8tGff009Jy3PMbJj6fiviyfX7a5081A/qcVmVqWo59+qtpOfrpr6bl+Ke/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"},{"name":"is_initialized","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"subscriber_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b30/aUBTHWwdaQVGRnwWVHwo6XVJg4l5M3JY97GUPe9i7A5xkThNgyf56M2/pCceb43LrTm96E5uw3db2fD/309sLbF7bmm928BJbEh2TNzh2Efzt/d/WYazl2TKn+COh0BmbOvg1aDjoZzUu2ndedxkVl+HSD68l2AnOWXl4LaOf28FxOG8LHYN6qYdXJmj/GM0+3NwNfn75/ev7aIITX0k9h57Km6iWXVT7eHc7m1wOZu+Hw8loOsVXU9Lvn6iYQhWvL8e3n4f4quTzKn0bTabju1t81bJiJaFwNWjXLLbR2RX3bEXKku97DbVXEY/Dz9OJqJ+eqJtCfpnqngpXacnViuQqg85JIX/pCPzZKBdqwz7khWVeigFzlONijb9ud8Oa32vwuib5xf1aD9qM49LD9y2J8tZR7kbQti3edzuY2xNBbeDYQNlZdue9gejjpvV4+9dclkU8W+w887mMv5/zMbuN2HnqnvaEq5zkalNylUHnYIZcBP5slAu1YT9HZPO5OHsrsvMKLvIET16zizyRzeeifyWyCwouCgRPQbOLApHNOC66Iruo4KJI8BQ1uygS2Yzjws8uKbgoETwlzS5KRDajizORXVZwUSZ4yppdlIlsRhf+Z2JXwYVL8LiaXbhENp+Lrv95qKLgokLwVDS7qBDZjHOn//miquCiSvBUNbuoEtmMz8hAZO8ouNgheHY0u4C8sMx5A5lzBjK7MWB2pDZPds+fP3cVXOwSPLuaXUBeWGY3BsyO1ObJ7o9E9p6Ciz2CZ0+zC8gLy5w3kDlnILNrIHPRQObqC7MW5jjMG47U5sk+878P1xRc1AiemmYXkBeWuRwDZkdq82T3/X//rCu4qBM8dc0u6kQ243d4/zNMQ8FFg+BpaHYBeWGZXQOZtw1kzhnInDeQuWAgc9FA5pKBzGUDmU2cnysGMlcNZDZxfjbxfdDE8RyHecOR2jzZff83MpsKLpoET1OziyaRzfh92/8/130FF/sEz75mF5AXlrliIHPOQGbXQOaXsaGHuWggc8FA5pd543nMjtTmye73RfaBgosDgudAswvIC8tcMJA5byBzw0BmNwbMjtTmye752S0FFy2Cp6XZBeSFZa7HgDlhLdaGXNhR8vSGaYkHnFkSoyUxplE7i5y1gdviW8eB708bZR2y+/DIMQ77h5Fm9wai7usI+iTqHvPX9X/n7CSolQxqHxOu3gRtm/k+naC6NsqB4wnUPrcX58J54APmA2AXa7+OgjZml69rSddl0DlH6Lpj6TrYh3st3PXQcx7F2FIZ18IDPMvn1oKnzc7jdR6tkUauLIkRNvzcZyLgiaifHuV9SeoTnt/weseo3n/aEg/st1B2BC76Ea3z68AaUvCalfxCv8Q58H1xcD0Si+lvbsZX49Hk05/xdPZoDTxeAwzbvbTfeuIc/AwzrlXt4Ey8VvUQMaclNvycwc/E2tq/Hbcl3zpCAAA=","debug_symbols":"1dzbSltRFIXhd8m1lDXGXEdfpZQSTyUgUTQWivjuje3eaklQIYL9r2SbmbXnuvrJzXe/ODs/ufvxfbW+uLpdHH+9X1xenS43q6v19ul+kb7UP/+8vV6uH59vN8ubzeI4HS3O12fbvw9Hi4vV5fniuOjhaGesuU2DLfen0d4fvh1tT26HnNw1DfZUd07uB5zc4+nkPTuPQ05unk/uuycr7Tu6OJXpS8V5vP6CEX2aHS9eoJz3zKrMW2s8z9pj37l55PngUuJ5Oqdpd4F3N3j3AO+ewbsX8O4VvHsD797Buw/u7gZ31eCuGtxVg7tqcFcN7qrBXfXhXVWqMS8kpze2f/dvsTH/Yir1xZFlWrsz1x7ItSMx1xZzbTPXDubambl2Ya5dmWszKxnMSgazkplZycysZGZWMjMrmZmVzMxKZmYlM7OSmVnJzKxkYVayMCtZmJUszEoWZiULs5KFWcnCrGRhVrIwK1mZlazMSlZmJSuzkpVZycqsZGVWsjIrWZmVrMxKNmYlG7OSjVnJxqxkY1ayMSvZmJVszEo2ZiUbs5KdWcnOrGRnVrIzK9mZlezMSnZmJTuzkp1Zyc6s5GBWcjArOZiVHMxKDmYlB7OSg1nJwazkYFZyMCupxMykErOTSsxQKjFLqcRMpRKzldt3Qvdm1lKJmUslaC8F7aWgvRS0l4L28gMsn8/ZG9pLQXspaC8F7aWgvTS0l4b20tBeGtrLDzB6PmdvaC8N7SXU5REU5hFU5hGU5hHU5hEU5xFU5xGU5xHU5xEU6BFU6BGU6BHU6BEU6RFU6RGU6RHU6REU6hFU6hGU6hHU6hEU6xFU6xGU6xHU6xEU7BFU7BGU7BHU7BEU7RFU7RGU7RHU7REU7hFU7hGU7hHU7hEU7xFU7xGU7xHU7xEU8BFU8BGU8BHU8BEU8RFU8RGU8RHU8REU8hFU8hGU8hHU8hEU8xFU8xGU8xHU8xEU9BFU9BGU9BHU9BEU9RFU9RGU9RHU9REU9hFU9hGU9hHU9hEU9xFU9xGU9xHU9zHU9zHU9zHU9zHU93Fi9tJQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ38dQ3yegvk9AfZ+A+j4B9X0iMXsZUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU94l3+D61vv6KEqXPwzHaPy/ZnXZWnaZd/Nb0yCNP06OUeJp2TvMFRL+A6RcI+gUy/QKFfoFKv0CjX6DTLzDgFwh6iYNe4viAEufU5uGc0xsr5dHnlUqKF9PR55XiU1cq+1bK/9NK26efy5vV8uTy/Hb7nccP79anm9XVenrc/Lr++8l29jc="},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"subscription_recipient_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"subscription_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"subscription_price","type":{"kind":"field"},"visibility":"private"},{"name":"gas_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"gas_token_limit_per_tx","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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xOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOszxOuzI7y+s2xUtiP0wvOEzZXCjpXC1kph5zph+xEG7HnCtpXC2kph+0ph/YCwJ1ky3I/Qp88TdqwUtlYKOxcKe4Raf56wbaWwtlLYvlJYXylsrBT2/gRl3V7C1twJe5Yt6P0rb6lcNOxcKOxX3tm5aNi2UlhbKWzHwx664b1/5R2tEwWIswfIswcYZw9QZw9wwOSw+6Pe3jekSkOqGFKlI1UcqRJIlUSqDKRKIVUQ9h1h3xH2HWHfEfYdYd8R9h1h3xH2HWHfEfYDYT8Q9gNhPxD2A2E/EPYDYT8Q9gNhPxD2E2E/EfYTYT8R9hNhPxH2E2E/EfYTYT8R9gfC/kDYHwj7A2F/IOwPhP2BsD8Q9gfC/kDYL4T9QtgvhP1C2C+E/ULYL4T9QtgvhP1C2J8I+xNhfyLsT4T9ibA/EfYnwv5E2J8I+5Ng37cNqdKQKoZU6UgVR6oEUiWRKgOpUkgVhP2GsN8Q9hvCfkPYbwj7DWG/Iew3hP2GsN8Q9g1h3xD2DWHfEPYNYd8Q9g1h3xD2DWEf8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8foc8friCK/vLBuV4wi98DxhbaWwfaWwvlLYWClsrhR2rBS2Vgo7Fwp7hB19liXDcYQ+fZ6wfaWwvlLYWClsrhR2rBS2Vgo7FwprKw0VR7z9cZ6wX5mg5m3c7T18J+xZtqDH195SuWbYWClsrhR2rBS2Vgo78bCHbniPr72jdZ4A7ewB7OwB+tkD+NkDHDA57P+otydSZSBVCqkyiSq+IVUaUsWQKh2p4kgVhH1H2HeEfUfYd4T9QNgPhP1A2A+E/UDYD4T9QNgPhP1A2A+E/UTYT4T9RNhPhP1E2E+E/UTYT4T9RNhPhP2BsD8Q9gfC/kDYHwj7A2F/IOwPhP2BsD8Q9gthvxD2C2G/EPYLYb8Q9gthvxD2C2G/EPYnwv5E2J8I+xNhfyLsT4T9ibA/EfYnwv4k2M9tQ6o0pIohVTpSxZEqgVRJpMpAqhRSBWG/Iew3hP2GsN8Q9hvCfkPYbwj7DWG/Iew3hH1D2DeEfUPYN4R9Q9g3hH1D2DeEfUPYN4T9jrDfEfY7wn5H2O8I+4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXl4jXNxCvbyBe30C8voF4fWNzpEogVQ5g/ywblccReuF5wtZKYedCYY9wPs8Ttq0U1lYK21cK6yuFjZXCHjFBnWTJ8DhCnz5P2LlQ2CNk8vOEbSuFtZXC9pXC+kphY6WwKw0VR7z9cZ6w9yeonrf+u9ve/5PiLFvQx1feUrlo2LZSWFspbF8prK8UNvCwh254H195R+tEAcbZA9TZA8yTB/Dt7AEOmBz2f9TrhlTpSBVHqgRSJZEqA6lSSJVJVIkNqYKwHwj7gbAfCPuBsB8I+4GwHwj7gbCfCPuJsJ8I+4mwnwj7ibCfCPuJsJ8I+4mwPxD2B8L+QNgfCPsDYX8g7A+E/YGwPxD2B8J+IewXwn4h7BfCfiHsF8J+IewXwn4h7BfC/kTYnwj7E2F/IuxPhP2JsD8R9ifC/kTYnwT7tW1IlYZUMaRKR6o4UiWQKolUGUiVQqog7DeE/Yaw3xD2G8J+Q9hvCPsNYb8h7DeE/Yawbwj7hrBvCPuGsG8I+4awbwj7hrBvCPuGsN8R9jvCfkfY7wj7HWG/I+x3hP2OsN8R9jvCviPsI15fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV5fIV7fRLy+iXh9E/H6JuL1zc2RKoFUSaTKQKoUUgVhH/H6JuL1zSO8vrNsVJ5H6IXnCesrhY2VwuZKYcdKYWulsHOhsEf4wOcJ21YKe8QEdZIlw/MIffo8YWOlsLlS2LFS2Fop7Fwo7BEvGpwnbFsp7EpDxRFvf5wnrN8Le6uw/X7MaC87ynu9hjS7c9bbiOfD3sp/v++0fltonhb9Xt/xnr791kpU7vW91Xzpu+30PWLc+h65zS/6fvrF/377t++//eMP3/309Ed+/b2/f/zTz9//+PH5lz//318//c7T2f8H"},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":1,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"dapp_payload::DAppPayload"},"visibility":"private"},{"name":"user_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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fzz5+tPJ128nX38++frLyddfT77+dvL193OvP5/8/ptPfv/NJ7//5pPff/PJ77/55PfffPL7bz75/Tef/P6bT37/LSe//5aT33/Lye+/5eT333Ly+29xff3Ptu1i2hfrd339319/dX39yXn9MFgu9f76XV9/Hli/6+vPA+t3ff15YP2u6/8H1u+6/n9g/a6v//v7L9X19f+B9buu//fX31zX/w+s3/X994H1u77/PrB+1/ffB9bv+v77wPpd338fWL/r++8D6z/5/bed/P7bTn7/7cfff7/0FD4fG0JZDw6h3jxpdPkrWwTh9BHE00eQTh+BnT6CfPoIyukjqH4i2NbUHK5pxF0zhPVGGEOxnTWFEK/07OaNlrjRS8viclXh6FUN3SFISzz5+tPJ128nX38++frLyddfT77+dvL193OvPywnX//J77/h5PffcPL7bzj5/Tec/P4bTn7/DSe//4aT33/Dye+/8eT333jy+288+f03nvz+O2LSxUvXf/L7bzz5/Tee/P4bT37/jSe//ybX1//dJ4xTcn39f2D9rq8/u09YpuT6+vPA+l1ffx5Yv+vrz/76zXX9/8D6Xdf/D6zf9fV/9wmhZK6v/w+s306+ftf1/wPrd33/fWD9ru+/D6zf9f33gfW7vv/urz+7vv8+sH7X998H1n/y+28++f13yISRV67/+PvvT55KXNr1CbLl5sm8myfIcjl9BPX0EbTTR9DPHkFZTh9BOH0E0XcEWzt/iSB8iODeL9v7wfVmCm7o13tHSVLRmlS0vuuCD0+Wf3Eu+q4LHonAd13wSAS+64JHIvBdFzwQQfVdFzwSge+64JEIfNcFD7ynU33f6x+JwPf9+5EIHN2TtzU5ustuaxpy3+zrVyA+fHvqizfd8vbJiGz319Qcrqkfvaaxz54Mma7zyvWHk68/nnz96eTrt5OvP598/eXk668nX387+fpPfv/tJ7//9pPff/vJ77/95PffIVN1Xrn+k99/+8nvv/3k999+8vtvP/f915Zz339tOff915Zz339tOff915Zz339tOff915Zz339tOff915Zz339tOfn9N7i+/u++O2jB9fX/gfW7vv7svjtlwfX154H1u77+PLB+19ef/fVH1/X/A+t3Xf8/sH7X1//dZ/8tur7+P7B+O/n6Xdf/D6zf9f33gfW7vv8+sH7X998H1u/6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20Kxthsqq2qxequ3WL3VW6ze6i1Wb/UWq7d6i9VbvcXqrd5i9VZvsXqrt1i91Vus3uotVm/1Fqu3eovVW73F6q3eYvVWb7F6q7dYvdVbrN7qLVZv9Rart3qL1Vu9xeqt3mL1Vm+xequ3WL3VW6ze6i1Wb/UWq7d6i9VbvcXqrd5i9VZvsXqrt1i91Vus3uotVm/1Fqu3eovVW73F6q3eYvVWb7F6q7dYvdVbrN7qLVZv9Rart3qL1Vu9xeqt3mL1Vm+xequ3WL3VW6ze6i1Wb/UWq7d6i9VbvcXqrd5i9VZvsXqrt1i91Vus3uotVm/1Fqu3eovVW73F6q3eYvVWb7F6q7dYvdVbrN7qLVZv9Rart3qL1Vu9xeqt3mL1Vm+xequ3WL3VW6ze6i1Wb/UWq7d6i9VbvcXqrd5i9VZvsXqrt1i91Vus3uotVm/1Fqu3eovVW73F6q3eYvVWb7F6q7dYvdVbrN7qLVZv9Rart3qL1Vu9x+qt3mP1Vu+xeqv3WL3V+0Kxthsqq+qxeqv3WL3Ve6ze6j1Wb/Ueq7d6j9Vbvcfqrd5j9VbvsXqr91i91Xus3uo9Vm/1Hqu3eo/VW73H6q3eY/VW77F6q/dYvdV7rN7qPVZv9R6rt3qP1Vu9x+qt3mP1Vu+xeqv3WL3Ve6ze6j1Wb/Ueq7d6j9Vbvcfqrd5j9VbvsXqr91i91Xus3uo9Vm/1Hqu3eo/VW73H6q3eY/VW77F6q/dYvdV7rN7qPVZv9R6rt3qP1Vu9x+qt3mP1Vu+xeqv3WL3Ve6ze6j1Wb/Ueq7d6j9Vbvcfqrd5j9VbvsXqr91i91Xus3uo9Vm/1Hqu3eo/VW73H6q3eY/VW77F6q/dYvdV7rN7qPVZv9R6rt3qP1Vu9x+qt3mP1Vu+xeqv3WL3Ve6ze6j1Wb/Ueq7d6j9Vbvcfqrd5j9VbvsXqr91i91Xus3uo9Vm/1Hqu3eo/VW73H6q3eY/VW77F6q/dYvdV7rN7qPVZv9R6rt3oP1Vt9W0L1Vr9tN1JWddtupKzqtt1IWdVtuxRru5Gyqtt2I2VVt+1Gyqpu242UVd22GyurCtVb/bbdWFlVqN7qt+3GyqpC9Va/bTdWVhWqt/ptu7GyqlC91W/bjZVVheqtftturKwqVG/123ZjZVWheqvfthsrqwrVW/223VhZVaje6rftxsqqQvVWv203VlYV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3WJULK838EeVro3quU4WWmcVWoeE1ilC63CceucN0laWlyFG1mlC63SZdVhehhhZJwmtk4XWWYXWIaF1itA6QufBJnQebELnwSZ0HjSh86AJnQdN6DxoQudBEzoPmtB50ITOgyZ0HjSh86AJnQdd6DzoQudBFzoPutB50IXOgy50HnSh86ALnQdd6DzoMucBLYvQOklonSy0ziq0DgmtU4TWqULrbELrNKF1hM6DJHQeJKHzIAmdB0noPEhC50ESOg+S0HmQhM6DJHQeJKHzIAudB1noPMhC50EWOg+y0HmQhc6DLHQeZKHzIAudB1noPFiFzoNV6DxYhc6DVeg8WIXOg1XoPFiFzoNV6DxYhc6DVeg8IKHzgITOAxI6D0joPCCh84CEzgMSOg9I6DwgofOAhM6DInQeCA1SJKFBiiQ0SJGEBimS0CBFKkLnQRE6D4rQeVCEzoMqdB5UofOgCp0HVeg8qELnQRU6D4TuJ5LQ/UQSup9IQvcTSeh+IgndTySh+4kkdD+RhO4nktD9RBK6n0hC9xNJ6H4iCd1PJKH7iSR0P5GE7ieS0P1EErqfSEL3E0nofiIJ3U8kofuJJHQ/kYTuJ5LQ/UQSup9IQvcTSeh+IgndTySh+4kkdD+RhO4nktD9xCJ0P7EI3U8sQvcTi9D9xLKQ0DpFaJ0qtM4mtE4TWkfoPBC6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7icWofuJReh+YhG6n1iE7idWofuJVeh+YhW6n1iF7ifWhYTWKULrVKF1NqF1mtA6QueB0P3EKnQ/sQrd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b5/E5rcXsfntRWx+exGb317E5reXSxWrV8tfFbH57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfnsRm99exOa3F7H57UVsfvssNr99FpvfPovNb5/F5rfPlypWr5a/msXmt89i89tnsfnts9j89llsfvssNr99FpvfPovNb5/F5rfPYvPbZ7H57bPY/PZZbH77nGm+97GV+4e3+azeRPdvU72Jns/Hvj8+vJ3Vm+j53FRvoudzU72Jns9N9SbKvy31Zpr/3FRvpvu3pd5M929LvYnyb1O9VaxeMX+Vaf5zU73D+qunGob1TE81hPZB13OU5XGQy76++Tfv/Gd/Vxx7UnOXikN7oS4Vh3ZDXSoO7Ye6VFzlKg7tibpUHNoVdak4tC/qUnFoF9WlYjnPFXt6c5eK5TxX7AnOXSqW81yxpzh3qVjOc8We5NylYjnPFXuac5eK5TxX7InOXSqW81yxpzp3qVjOc8We7NylYjnPFXu6c5eK5TxX7AnPXSqW81yxp+J+WvFS738Hu9TTilPdTk0Vp3pyLcv9bzWW9exvNWLPTu1ScaonV0vFseendqk4VVpsqjhVWmyqONV9vE7r70+vczmrONV93FRxqrTYVHGqtNhUcSrP1VRxKs/VVHEqz9VSceyZql0qTuW5mipO5bmaKpbzXLFnq3apeGDP9VTFwD7qqYrg3miavw8y1frm376WLmvsWahdKg7ujT6ruJTHQery94pr7HmoXSoO7o06VBzcG3WoOLg36lBxlas4uDf6sOLl7kHKNp1VHNxH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b9/E5rdvYvPbN7H57ZvY/PZNbH77Jja/fROb376JzW/fxOa3b2Lz2zex+e272Pz2XWx++y42v30Xm9++X6pYvVr+aheb376LzW/fxea372Lz23ex+e272Pz2XWx++y42v30Xm9++i81v38Xmt+9i89t3sfntu9j89l1sfvsuNr99F5vfvovNb9/F5rfvYvPbd7H57bvY/PZdbH77Lja/fReb376LzW/fxea372Lz23ex+e272Pz2XWx++y42v30Xm9++i81v38Xmt+9i89t3sfntu9j89l1sfvsuNr99F5vfvovNb9/F5rfvYvPbd7H57bvY/PZdbH77Lja/fReb376LzW/fxea372Lz23ex+e272Pz2XWx++y42v30Xm9++i81v38Xmt+9i89t3sfntu9j89l1sfvsuNr99F5vfvovNb9/F5rfvYvPbd7H57bvY/PZdbH77Lja/fReb376LzW/fxea372Lz23ex+e272Pz2XWx++y42v30Xm9++i81v38Xmt+9i89t3sfntu9j89l1sfvsuNr99F5vfvovNb9/F5rfvYvPbd7H57bvY/PZDbH77ITa//RCb336IzW8/LlWsXi1/dYjNbz/E5rcfYvPbD7H57YfY/PZDbH77ITa//RCb336IzW8/xOa3H2Lz2w+x+e2H2Pz2Q2x++yE2v/0Qm99+iM1vP8Tmtx9i89sPsfnth9j89kNsfvshNr/9EJvffojNbz/E5rcfYvPbD7H57YfY/PZDbH77ITa//RCb336IzW8/xOa3H2Lz2w+x+e2H2Pz2Q2x++yE2v/0Qm99+iM1vP8Tmtx9i89sPsfnth9j89kNsfvshNr/9EJvffojNbz/E5rcfYvPbD7H57YfY/PZDbH77ITa//RCb336IzW8/xOa3H2Lz2w+x+e2H2Pz2Q2x++yE2v/0Qm99+iM1vP8Tmtx9i89sPsfnth9j89kNsfvshNr/9EJvffojNbz/E5rcfYvPbD7H57YfY/PZDbH77ITa//RCb336IzW8/xOa3H2Lz2w+x+e2H2Pz2Q2x++yE2v/0Qm99+iM1vP8Tmtx9i89sPsfnth9j89kNrfvt20Zrffq1Xyl9d65XyV9d6pfzVtd4qVq+Uv7rWK+WvrvVK+atrvVL+6lqvmL/Smt9+rVfMX2nNb7/WK+avtOa3X+sV81da89uv9Yr5K6357dd6xfyV1vz2a71i/kprfvu1XjF/pTW//VqvmL/Smt9+rVfMX2nNb7/WK+avtOa3X+sV81da89uv9Yr5K6357dd6xfyV1vz2a71i/kprfvu1XjF/pTW//VqvmL/Smt9+rVfMX2nNb7/WK+avtOa3X+sV81da89uv9Yr5K6357dd6xfyV1vz2a71i/kprfvu1XjF/pTW//VqvmL/Smt9+rVfMX2nNb7/WK+avtOa3X+sV81da89uv9Yr5K6357dd6xfyV1vz2a71i/kprfvu1XjF/pTW//VqvmL/Smt9+rVfMX2nNb7/WK+avtOa3X+sV81da89uv9Yr5K6357dd6xfyV1vz2a71i/kprfvu1XjF/pTW//VqvmL/Smt9+rVfMX2nNb7/WK+avtOa3X+sV81da89uv9Yr5K6357dd6tfzVJDa/fRKb3z6JzW+fxOa3X6sRq1fLX01i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3T2Lz2yex+e2T2Pz2SWx++yQ2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3T2Lz2yex+e2T2Pz2SWx++yQ2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PZJbH77JDa/fRKb3z6JzW+fxOa3T2Lz2yex+e2T2Pz2SWx++yQ2v30Sm98+ic1vn8Tmt09i89snsfntk9j89klsfvskNr99EpvfPonNb5/E5rdPYvPbJ7H57ZPY/PYp03zv66kvj1OX483P/uQc8zwvvz88z/v0fY6j/sufXC7l/uFy2Z7ZHX/7yfvx+MnlzU9eavn92aXOZ+onciOo/7H6ibwZ6n+sfkV9YfUT+XbU/1j9RCkG9T9WP1GmQ/2P1U+UcFH/Y/UT/T4F9T9Uv2TaroL6H6tPr09ZfXp9WdXf7zCWYzlTn16fsvoV9YXVp9enrD69vqzqb9/qr2fq0+tTVp9en7L69PqE1c+06Q/1P1afXp+y+vT6sqq/3P+md1m3M/Xp9SmrX1FfWH16fcrq0+tTVp9en7L69PqU1afXJ6x+pq3TqP+x+vT6lNWn16esPr0+ZfUr6gurT69PWX16fcrq0+tTVp9en7L69PqE1Z/p9SmrT69PWX16fcrq0+tTVr+ivrD69PqU1afXp6w+vT5l9en1KatPr09Y/UqvT1l9en3K6tPrU1afXp+y+hX1hdWn16esPr0+ZfXp9SmrT69PWX16fcLqL/T6lNUn77uqf/0Jd5Gm45gt1W/YzbFU1BdWn7yvrD55X1l98r6y+uR9ZfXJ+8Lqr+R9ZfX52x5l9fnbHmX16fUpq19RP6n6DdsYV3p9yurT61NWn16fsvr0+rKq37CRbaXXJ6z+Rq9PWX16fcrq0+tTVp9en7L6FfWTqt/wN70bvT5l9en1KatPr09ZfXp9yurT6xNWf6fXp6w+vT5l9en1KatPr09Z/Yr6wurT61NWn16fsvr0+pTVp9enrD69PmH1D3p9yurT61NWn16fsvr0+pTVr6gvrD69PmX16fUpq0+vT1l9en3K6tPr01V/vtDrU1afXp+y+vT6lNWn16esfkV9YfXp9SmrT69PWX16fcrq0+tTVp9en7D6E70+ZfXp9SmrT69PWX3yvr36ths05olUHl8jsnN8jUi48TUih4bXqJAW42tEpouvEckrvkb8LUR8jSoahdeIPkN8jegz+Gr0fqvaXOgzxNeIPkN8jegzhNdops/gq9H7jT/zTJ8hvkb0GeJrRJ8hvkYVjcJrRJ8hvkb0GXw1avi7oJk+Q3yN6DPE14g+Q3iNKn2G+BrRZ4ivEX2G+BrRZ4ivUUWj8BrRZ4ivEX2G+BrRZ4ivEX2G+BrRZwiv0UKfIb5G9Bnia0SfIb5G9Bnia1TRKLxG9Bnia0SfIb5G9Bnia0SfIb5G9BnCa7TSZ4ivEX2G+BrRZ4ivEX2G+BpVNAqvEX2G+BrRZ4ivEX2G+BrRZ4ivEX2G8Bpt9Bnia0SfIb5G9Bnia0SfIb5GFY3Ca0Q+atFo2u885lJWS40a5kBu5KP4GpGPwmu0k4/ia0Q+iq8R+Si+RuSj+BpVNAqvEb+Hja8Rv4eNrxF9hvga0Wfw1ahhBvtOnyG8Rgd9hvga0WeIrxF9Bl+NGmZHH/QZ4mtU0Si8RvQZ4mtEnyG+RvQZ4mtEn8FXo4a/CzroM0TXqF7oM8TXiD5DfI3oM8TXiD5DfI0qGoXXiD5DfI3oM8TXiD5DfI3oM8TXiD5DeI0m+gzxNaLPEF8j+gzxNaLPEF+jikbhNaLPEF8j+gzxNaLPEF8j+gzxNaLPEF6jQp8hvkb0GeJrRJ8hvkb0GeJrVNEovEb0GeJrRJ8hvkb0GeJrRJ8hvkb0GcJrNNNniK8RfYb4GtFniK8RfYb4GlU0Cq8RfYb4GtFniK8R+ahJo8sd5Tw9VfgjcyBrJR/F14h8FF8j8lF8jchH8TWqaBReI/JRfI3IR/E14vew8TXi97DxNaLPEF6jhT6Dr0bvZ7DXhT5DfI3oM8TXiD5DfI0qGrlq9H52dF3oM8TXiD5DfI3oM8TXiD5DfI3oM4TXaKXP4KtRw98FrfQZ4mtEnyG+RvQZ4mtU0Si8RvQZ4mtEnyG+RvQZ4mtEnyG+RvQZwmu00WeIrxF9hvga0WeIrxF9hvgaVTQKrxF9hvga0WeIrxF9hvga0WeIrxF9hvAa7fQZ4mtEnyG+RvQZ4mtEnyG+RhWNwmtEnyG+RvQZ4mtEnyG+RvQZ4mtEnyG8Rgd9hvga0WeIrxF9hvga0WeIr1FFo/Aa0WeIrxF9hvga0WeIrxF9hugaLRfyUYtGl3m5a3TZL5YavZ8DuVzIR/E1Ih/F16iiUXiNyEfxNSIfxdeIfBRfI/JRfI34PWx4jSZ+DxtfI/oM8TWiz+Cr0fsZ7MtEnyG+RhWNwmtEnyG+RvQZfDV6Pzt6megzxNeIPkN8jegzhNeo0GeIrxF9hvga0Wfw1ajh74IKfYb4GlU0Cq8RfYb4GtFniK8RfYb4GtFniK8RfYbwGs30GeJrRJ8hvkb0GeJrRJ8hvkYVjcJrRJ8hvkb0GeJrRJ8hvkb0GeJrRJ8hvEaVPkN8jegzxNeIPkN8jegzxNeoolF4jegzxNeIPkN8jegzxNeIPkN8jegzhNdooc8QXyP6DPE1os8QXyP6DPE1qmgUXiP6DPE1os8QXyP6DPE1os8QXyP6DOE1WukzxNdINx8ZT2tcKySNSOpmDWuSuonAmqSub7cmqeuurUnqemBjkpuuU7Umqft7K2uSur9dsiZJxrEiWSFpM0t5I+NYkSTjWJEk41iRJOO0kGyYTbqRcYxI7mQcK5JkHCuSZBwrkmQcK5IVkja/W9zJOFYkyThWJMk4ViTJOFYkyThGJA8yjhVJMo4VSTKOFUkyjhXJCkkjkmQcK5JkHCuSZBwrkmQcK5JkHBuS64WMY0WSjGNFkoxjRZKMY0WyQtKIJBnHiiQZx4okGceKJBnHiiQZx4jkRMaxIknGsSJJxrEiScaxIlkhaUSSjGNFkoxjRZKMY0WSjGNFkoxjRLKQcaxIknGsSJJxrEjG9pNbuc+cO/ZyeUPy+un7h7f5rN7Yrs++3tjezL7e2A7Kvt7YPse83jm2G/mo3s+e/Me+Py6Vs6f5HNtheNOJ7Rq86cTudnrTqdB5QSeRi+xAJ5Hn7EAnkUPtl+XOz/xEMpH3dSaZyFX7kqyyft2cpKy3NycpmwPMScpmBnOSFZJGJGWziDlJ2dxiTpKMY0WSjGNFkoxjRDL4nvKRSJJxrEiScaxIknGsSFZIGpEk41iRJONYkSTjWJEk41iRJOMYkQy+I3kkkmQcK5JkHCuSZBwrkhWSRiTJOFYkyThWJMk4ViTJOFYkyThGJIPv3w1CsmH/7hp8/+5IJLlxjN50Db7rdCSS3DhGJIPvOh2JJF01K5J01axI4icbSK7T+vuz61zOSFZIGpGkq2ZFkq6aFUkyjhVJMo4VSTKOEcngu05HIknGsSJJxrEiScaxIlkhaUSSjGNFUjfjfHCOa933Cqd5feKx12eWuinHnqVuzrFnqZt0rFluwXeejsVSN+3Ys9TNO/YsdRPPRyz35cHyqGcsKyzNWOqmHnuW5B47luQeO5bkHjuW5B4zlsH3oAZkWS/TGUtyjx1Lco8dS3JPC8ta1gfLeTljWWFpxpLcY8eS3GPHktxjx5LcY8eS3GPGMvhuVBeWT3RIMq/okE1e0SFtvKJTofOCDongFR08/is6mfblvt++tqXal9tSb6Z9uQ31ZtqX21RvIs/ZVG8iF9lUbyJf2FRvFas3kXdrqjeRG2uqV8xfZdrJ2lSvmL/KtN+0qV4xf5VpV2hTvWL+KtPezaZ6xfxVph2WTfWK+atM+yCb6hXzV5l2KzbVK+avMu0pbKpXzF9l2vnXVK+Yv8q0P6+pXjF/lWkXXVO9Yv4q0163pnrF/FWmHWlN9Yr5q0z7xprqFfNXmXZ3NdUr5q8y7cFqqlfMX21i/moT81ebmL/KtCOtqd4qVq+Yv9rE/FWmfXJN9Yr5q0y72VrqzbRBraleMX+VaRtZU71i/irTZq+mesX8VaYtWU31ivmrTBunmuoV81eZtjc11SvmrzJtQmqqV8xfZdoq1FSvmL/KtKGnqV4xf5Vp001TvVr+as+0MaapXi1/tWfavNJUr5a/2i9VrF4tf7Vn2gTSVK+Wv9ozbdRoqlfMX2XaTNFUr5i/yrThoaleMX+VaVNCU71i/irTxoGmesX8VabJ/U31ivmrTBPwm+oV81eZptQ31SvmrzJNkm+qV8xfZZr23lSvmL8Sm9++i81v38Xmt+9i89t3sfntu9j89l1sfvsuNr99F5vfvovNb9/F5rfvmeZ7f7gdaj8e5yhvPrvU8vuzS53PSOru97MmqbsL0JpkhaQRSd0dg9YkdfcRWpPU3ThuTVJ337g1Sd1t48YkM03CdyZJxrEiScZpIbnff/ByLGckyThWJCskjUiScaxIknFaSG7fJNczkmQcK5JkHCuSZBwjkpm2UTiTJONYkSTjtJBc7r9bXNaz3y1m2s3hTLJC0ogkGceKJBnHiiQZx4okGceKJBnHiGSmjTDOJMk4ViTJOFYkyThWJCskjUiScaxIknGsSJJxrEiScaxIknGMSGbayuRMkoxjRZKMY0WSjGNFskLSiCQZx4okGceKJBnHiiQZx4okGceI5EHGsSJJxrEiScaxIknGsSJZIWlEkoxjRZKMY0WSjGNFkoxjRZKMY0PyyLSd0JlkbD+5Xh4k1+N4Q/LK/f7hbT6rt4rVG9ub2dcb20HZ1xvb59jXG9uNfFTvZ0/+himZR/Ates50gu/c86YTu9vpTSd2B9ObTiIX2YFOhc4LOokcar8sd37mJ5KJvK8zyUSu2pmkrF83Jynr7a1JBt8NORJJ2cxgTlI2X5iTlM0i5iQrJI1IknGsSJJxrEiScaxIknGsSJJxjEgG3886EkkyjhVJMo4VSTKOFckKSSOSZBwrkmQcK5JkHCuSZBwrkmQcI5KVjGNFkoxjRZKMY0WSjGNFEhfU8rbM+72SR/D9uwORDL7rNArJhje4gu86HYkkN44VyQpJI5J01axI0lWzIomfbCC5Tuvvz65zOSOJn7QiSVfNiGTwXacjkSTjWJEk41iRJONYkayQNCJJxrEiScaxIknGsSJJxrEiScYxIhl812lPkh+c4wrhm8fyNMduPZ5Z6qYce5a6OceepW7SsWdZYWnGUjft2LPUzTv2LHUTz0cst/nxk/dyxlI389iz1E095iyD7z8diyW5x44luceOJbnHjmWF5acsjzOW5B47luQeO5bknhfvjgTfcOpNh2zygk7wTaTedMgPr+iQCF7RweO/olMT7cRpmKAffP+mfb2Zdjy11Jtpx1NLvYk8Z1O9iVzk+3r3S/Dtjfb1JnJ6TfUm8m5N9WbaodlSbxWrV8pfXeuV8lfXeqX81bVeKX91rVfMX2Xac9lUr5i/yrSLsqleMX+VaV9kU71i/irTnsamesX8Vaadh031ivmrTPsDm+oV81eZdvE11SvmrzLttWuqV8xfZdoR11SvmL/KtG+tqV4xf5Vpd1lTvWL+KtMesKZ6xfxVpp1aTfWK+atM+6ma6hXzV5l2PTXVK+avMu1NaqpXzF9l2kHUVK+Yv6pVrF4xf1XF/FWm/VRN9Yr5qyrmrxYxf5Vpl1dTvWL+KtNerKZ6q1i9Yv4q0yaopnrF/FWmrUpN9Yr5q0wbiprqFfNXmbb9NNUr5q8ybc5pqlfMX2XaQtNUr5i/yrTRpaleMX+VaTtKU71i/irTlpGmetkv9z82bH6u5fdnlzqfkWS/nBVJ9stZkWS/nBVJ9ssZkRTes2BNkh3aViTZoW1Fkh3aViQrJI1IknGsSJJxWkju9x+8HMsZSTKOFUkyjhVJMo4RSeHtDp+Q3L5JrmckyThWJMk4ViTJOFYkKySNSJJxrEiScVpILvffLS7r2e8WM+3mcCZJxrEiScaxITll2lTiTJKMY0WSjGNFkoxjRbJC0ogkGceKJBnHiiQZx4okGceKJBnHiGSmbUHOJMk4ViTJOFYkyThWJCskjUiScaxIknGsSJJxrEiScaxIknGMSGba2OVMkoxjRZKMY0WSjGNFskLSiCQZx4okGceKJBnHiiQZx4okGceIZKatec4kyThWJMk4ViTJOFYkKySNSMb2k7XUO8ll29+QPLb7ZIBjm8/qje367OuN7c3M6w2+F8++3tg+x77e2G7ko3o/e/I3TMmcgm/R86ZTofOCTuxupzed2B1MbzqJXGQHOok8Zwc6iRxqvyx3fuZvksF3Fo5EMpGrdiYp69fNScp6e3OSFZJGJGUzgzlJ2XxhTlI2i5iTlM0t5iTJOEYkg+8NHYkkGceKJBnHiiQZx4pkhaQRSTKOFUkyjhVJMo4VSTKOFUkyjhHJ4Lt7RyJJxrEiScaxIknGsSJZIWlEkoxjRZKMY0WSjGNFkoxjRZKMY0Qy+HbtkUiScaxIknGsSJJxrEhWSBqRJONYkSTjWJEk41iRJONYkSTjGJEMvn83CMml3t/6XuopyQpJI5LcOC0kGyanBN91OhJJbhwbkiX4rtORSNJVsyJJV82KJH6ygeQ6rb8/u87ljGSFpBFJumpWJOmqWZEk41iRJONYkSTjGJEMvut0JJJkHCuSZBwrkmQcK5IVkkYkyThWJMk4ViTJOFYkyThWJMk4RiSD7zodiaRuxvngHNP8qHCqT9yn7fin3HUTkS933fzky73C3YW7bjYz4v7EUjed2bPUzWf2LHUTmj1L3YxmzjL4ttaxWJLT7FiSvexYkqfsWFZYmrEk97SwrOvjJy9Pn/573pyu6O+fnurTqffLM3lSkhd5MpU5eeN3Hkum/cppNSIDhtco0x7rtBqRWeNrRBaOrxEZO75GFY3Ca0RPIL5GdA/ia0SfIb5G9Bnia0SfIbxGC32G+BrRZ4ivEX2G+BrRZ4ivUUWj8BrRZ4ivEX2G+BrRZ4ivEX2G+BrRZwiv0UqfIb5G9Bnia0SfIb5G9Bnia1TRKLxG9Bnia0SfIb5G9Bnia0SfIb5G9BnCa7TRZ4ivEX2G+BrRZ4ivEX2G+BqRj1w1atiJWTbyUXiNdnydr0YN++l2fF18jfB18TXC18XXqKJReI34/VF8jchHrhq1zNjeyUfxNeL3R/E14vdH4TU66DPE14g+Q3yN6DPE14g+Q3yNKhqF14g+Q3yN6DPE14g+Q3yN6DPYa/TJT748Pjxd9vX7J/8xKf+g0xBfpflCr2EEleg2jKAS/YYRVKLjMIJKFZUGUImug7NK+/4487GdqUTfYQSV6DyMoBK9hxFUovcwgEoTvYcRVKL3MIJK9B6cVTq+t8de9jOV6D2MoFJFpQFUovcwgkr0HkZQid7DCCrRexhBJXoPcVSazn5zUeg9jKASvYcRVKL34KvSNH+rVM/upULvYQSVKioNoBK9hxFUovcwgkr0HkZQid7DCCrRe/hBlb65z3QTfLjTH2jhvtTlwX3Z33C/tjbr40kz1zPyZH4v8uR4c/KlPHDU5Yx7hbsLd7K2D3fSsw938rAPdxKuD3cyqz335f7hsk0n3CuZ1Yc7mdWHO4nVhzt51Yd7hbsLd/KqD3fyqg938qoPd/KqD3fyqgv3hbzqw5282sR9e/x9xnLUN9zbftO3kFi9yJNZvchXyDuRJ7d6kSe5epEnu3qRJ716kSe/OpFfSbBe5MmwXuTJsF7kybBe5CvknciTYb3Ik2G9yJNhvciTYb3Ik2GdyG9kWC/yZFgv8mRYL/JkWC/yFfJO5MmwXuTJsF7kybBe5MmwXuTJsE7kdzKsF3kyrBd5MqwXeTKsF/kKeSfyZFgv8mRYL/JkWC/yZFgv8mRYJ/IHGdaLPBnWizwZ1os8GdaLfIW8E3kyrBd5MqwXeTKsF3kyrBd5MqwP+Xohw3qRJ8N6kSfDepEnw3qRr5B3Ik+G9SJPhvUiT4b1Ik+G9SJPhnUiP5FhvciTYb3Ik2G9yJNhvchXyDuRJ8N6kSfDepEnw3qRJ8N6kSfDOpEvZFgv8mRYL/JkWC/yZFgv8hXyTuTJsF7kybBe5MmwXuTJsF7kybBO5GcyrBd5MqwXeTKsF3kyrBf5Cnkn8mRYL/JkWC/yZFgv8mRYL/JkWCfylQzrRZ4M60WeDOtFngzrRb5C3ok8GdaLPBnWizwZ1os8GdaLPBnWifxChvUiT4b1Ik+G9SJPhvUiXyHvRJ4M60WeDOtFngzrRZ4M60WeDOtEfiXDepEnw3qRJ8N6kSfDepGvkHciT4b1Ik+G9SJPhvUiT4b1Ik+GdSK/kWG9yJNhvciTYb3Ik2G9yFfIO5Enw3qRJ8N6kSfDepEnw3qRJ8M6kd/JsF7kybBe5MmwXuTJsF7kK+SdyJNhvciTYb3Ik2G9yJNhvciTYZ3IH2RYL/JkWC/yZFgv8mRYL/IV8k7kybBe5MmwXuTJsF7kybBe5MmwPuSXCxnWizwZ1os8GdaLPBnWi3yFvBN5MqwXeTLsf5zjiQ458xUdsuArOuS1F3QmMtUrOuSeV3TIJq/okB9e0anQeUEHH/6KDl75FR288is6ibzyse/3Dx/bWb2J3G9LvSWRn22qN5FDbao3kedsqjeRi2yqt4rVm8jpNdWbyLs11ZvIjTXVK+avipi/msX81Szmr2YxfzWL+au5itUr5q9mMX81i/mrWcxfzWL+qor5qyrmr6qYv6pi/qpWsXrF/FUV81dVzF9VMX+VaUN9S72Z9sI31SvmrzLtQG+qV8xfZdr33VSvmL/KtNu6qV4xf5Vpj3NTvWL+KtPO4qZ6xfxVpv28TfWK+atMu2ib6hXzV5n2rjbVK+avMu0YbapXzF9l2qfZVK+Yv8q0O7KpXjF/lWlPYlO9Yv4q007ApnrF/FWm/XdN9Yr5q0y73prqFfNXmfaaNdUr5q8y7fBqqlfMX2XaV9VUr5i/yrSbqaleMX+VaQ9RU71i/irTzp2mesX8Vab9Mk31ivmrTLtUmuoV81eZ9oY01avlr9ZMOzKa6tXyV2umfRBN9Wr5q/VSxerV8ldrpjn/TfVq+as10yz+pnrF/FWmeflN9Yr5q0wz7ZvqFfNXmebON9Ur5q8yzYZvqlfMX4nNb1/F5revYvPbV7H57avY/PZVbH77Kja/fRWb376KzW9fxea3r2Lz21ex+e2r2Pz2VWx++yo2v30Vm9++is1vX8Xmt69i89tXsfntq9j89lVsfvsqNr99FZvfvorNb1/F5revYvPbV7H57avY/PZVbH77Kja/fRWb376KzW9fxea3r2Lz21ex+e2r2Pz2VWx++yo2v30Vm9++is1vX8Xmt69i89tXsfntq9j89lVsfvsqNr99FZvfvorNb1/F5revYvPbV7H57avY/PZVbH77Kja/fRWb376KzW9fxea3r2Lz21ex+e2r2Pz2VWx++yo2v30Vm9++is1vX8Xmt69i89tXsfntq9j89lVsfvsqNr99FZvfvorNb1/F5revYvPbV7H57avY/PZVbH77mmm+9/XUl8epy/HmZ39yjqmuj5+8PH162o6//eT9ePzk8uYnL7X8/uxS5zONEnmGpBptmeaop9UokTdLq1EiP5lWo0QeOK1GFY3Ca5Qoa6TVKFH/Oa1GiXrmaTWizxBfI/oMvhrt9x+8HMuJRpn2iaTViD5DfI3oM8TXiD6Dr0bbt0brmUYVjcJrRJ8hvkb0GeJrRJ8hvkb0GeJrRJ/BV6Pl/ndBy3ryd0Fbpr1aaTWizxBfI/oM8TWizxBfo4pG4TWizxBfI/oM8TWizxBfI/oM8TWizxBeo0z7JdNqRJ8hvkb0GeJrRJ8hvkYVjcJrRJ8hvkb0GeJrRJ8hvkb0GeJrRJ8hvEaZ9iyn1Yg+Q3yN6DPE14g+Q3yNKhqF14g+Q3yN6DPE14g+Q3yN6DPE14g+Q3iNFvoM8TWizxBfI/oM8TWizxBfo4pG4TWizxBfI/oM8TWizxBeo1U3HxlPa1x1U4w1Sd2sYU1SNxFYk6yQNCKp666tSep6YGuSuk7VmqTu762sSer+dsmY5EbGsSJJxmkh2TBLeSPjWJEk41iRrJA0IknGaSHZMJt0I+NYkSTjWJEk41iRJOMYkdzJOFYkyThGv1vcyThWJMk4ViQrJI1IknGsSJJxrEiScaxIknGsSJJxjEgeZBwrkmQcK5JkHCuSZBwrkhWSRiTJOFYkyThWJMk4ViTJOFYkyTg2JPcLGceKJBnHiiQZx4okGceKZIWkEUkyjhVJMo4VSTKOFUkyjhVJMo4RyYmMY0WSjGNFkoxjRZKMY0WyQtKIJBnHiiQZx4okGceKJBnHiiQZx4hkie0ny6OEY94ub0ge230ywLHNZ/XGdn329VaxemM7KPt6Y/sc+3pju5GP6v3syX/sjx99nD7NYzsMbzqxXYMznTl2t9ObTuwOpjedRC6yA51EnrMDnapK55Msd37mJ5KJvK8zyUSu2pmkrF83Jynr7c1JyuYAa5JVNjOYk5TNF+YkZbOIOUnZ3GJOskLSiCQZx4okGceKJBnHiiQZx4okGceIZPDN3CORJONYkSTjWJEk41iRrJA0IknGsSJJxrEiScaxIknGsSJJxjEiGXy79kgkyThWJMk4ViRxQS1vy7zfK7kH3787EMngu06jkGx4gyv4rtORSHLjWJGkq2ZFskLSiCRdNSuS+MkGkuu0/v7sOpczkvhJK5J01axI0lUzIhl81+lIJMk4ViTJOFYkyThWJCskjUiScaxIknGsSJJxrEiScaxI6macD85x+3GPnzw/z7Fbn1gG33Y6FkvdnGPPUjfp2LPUzTr2LCsszVjq5h17lrqJ5yOW6zePP87xB0vdzGPPUjf12LMk91ixPIJvQB2LJbnHjiW5x44luedjltsZywpLM5bkHjuW5J7zd0eO4BtOvemQTV7RIW28oBN8u6g3HRLBKzp4/Fd0Mu14ej9B/wi+f9O+3kw7nlrqzbTjqaXeRJ6zqd5ELrKp3kS+sKXeksjpNdWbyLs11Ztph2ZLvWL+KtUOzZZ6xfxVqh2aLfWK+atMWzGb6hXzV5k2VzbVK+avMm2XbKpXzF9l2gDZVK+Yv8q0TbGpXjF/lWkzYVO9Yv4q05a/pnrF/FWmjXlN9Yr5q0zb55rqFfNXmTa5NdUr5q8ybUVrqlfMX2XaMNZUr5i/yrStq6leMX+VafNVU71i/irTFqmmesX8VaaNTE31ivmrTNuNmuoV81eZNgU11Svmr9YqVq+Yv8q0n6qpXjF/tYr5q1XMX2Xa5dVUr5i/yrQXq6leMX+VacdUU71i/irTvqamesX8VabdR031ivmrTHuEmuoV81eZdvI01SvmrzLtt2mqV8xfZdoV01SvmL/KtHelqV4xf5Vpg0lTvWL+Snjjwiebn2v5/dmlzmck2S9nRZL9clYk2S9nRZL9clYk2aFtQvK4CG9ZsCbJDm0rkuzQtiLJDm0rkhWSRiTJOC0k9/sPXo7ljCQZx4okGceKJBnHiiQZp4Xk9k1yPSEpvAnCmiQZx4okGceKJBnHimSFpBFJMk4LyccxlnU7I0nGsSJJxrEiScaxIknGMSKZaQeKM0kyjhVJMo4VSTKOFckKSSOSZBwrkmQcK5JkHCuSZBwrkmQcI5KZ9hA5kyTjWJEk41iRJONYkayQNCJJxrEiScaxIknGsSJJxrEiScYxIplpF5gzSTKOFUkyjhVJMo4VyQpJI5JkHCuSZBwrkmQcK5JkHCuSZBwjkpn28TmTJONYkSTjWJEk41iRjO0np8v9w8f1W96QPLb7ZIBjm8/qje367OuN7c3s643toMzrDb4Xz77e2G7ko3o/e/K/n5J5pRPbYXjTie0avOlU6LygE7uD6U0nkYvsQCeR5+xAJ5FD7Zflzs/8RDKR9/UlGXwb4kgkZf26OUlZb29OUjYHmJOskDQiKZsvzEnKZhFzkrK5xZwkGceKJBnHiGTwjaQjkSTjWJEk41iRJONYkayQNCJJxrEiScaxIknGsSJJxrEiScYxIhl8K/BIJMk4ViTJOFYkyThWJCskjUiScaxIknFsSE7B9+8GIdmwV3IKvn93JJLcODZvcE3Bd52ORJIbx4okXTUrknTVrEjSVTMiGXzXaRCS67T+/uw6lzOS+EkrknTVrEjSVbMiWSFpRJKMY0WSjGNFkoxjRZKMY0WSjGNEMviu05FIknGsSJJxrEjqZpwPznH7cY+fPO9P51ifWVZYmrHUzTn2LHWTjj1L3axjz1I37diz1M075iyDbz4Nw3L95vHHbN8/WOpmHnuWuqnHniW5x45lhaUZS3KPHUtyjx1Lcs/HLLczluQeO5bkHjOWwbehurB8okOSeUWHbPKKDmnjFZ0KnRd0SASv6ODxX9HJtOPp/QT9Kfj+Tft6M+14aqg3+C5L+3oTec6mehO5yKZ6E/nCpnqrWL2JvFtTvZl2aLbUK+avUu3QbKlXzF+l2qHZUq+Yv8q0FbOpXjF/lWlzZVO9Yv4q03bJpnrF/FWmDZBN9Yr5q0zbFJvqFfNXmTYTNtUr5q8ybflrqlfMX2XamNdUr5i/yrR9rqleMX+VaZNbU71i/irTVrSmesX8VaYNY031ivmrTNu6muoV81eZNl811SvmrzJtkWqqV8xfZdrI1FSvmL/KtN2oqV4xf5VpU1BTvWL+6hDzV4eWvyqZ9lM11avlr8pFy1+Vi5a/KpcqVq+WvyqZ9mI11avlr0qmHVNN9Yr5q0z7mprqFfNXmXYfNdUr5q8y7RFqqlfMX2XaydNUr5i/yrTfpqleMX+VaVdMU71i/irT3pWmesX8VaYNJk31ivkr4Y0Ln2x+ruX3Z5c6n5Fkv5wRSeFtC9Yk2S9nRZL9clYk2aFtRbJC0ogkO7StSLJD24okO7StSJJxrEiScVpI7vcfvBzLCUnhzQrWJMk4ViTJOFYkyTgtJLdvkusZyQpJI5JkHCuSZBwrkmQcK5JkHCuSZJwWksv9d4vLeva7xUy7OZxJknGsSJJxrEiScaxIVkgakSTjWJEk41iRJONYkSTjWJEk4xiRzLQfx5kkGceKJBnHiiQZx4pkhaQRSTKOFUkyjhVJMo4VSTKOFUkyjhHJTDuqnEmScaxIknGsSJJxrEhWSBqRJONYkSTjWJEk41iRJONYkSTjGJHMtCfOmSQZx4okGceKJBnHimSFpBFJMo4VSTKOFUkyjhHJ4HvxLuV+juOy7m9IWk8RCL5Dz5dNbM/nyya2i/NlU2Fzyia20/JlE9s7+bKJ7YZ82cTu4fqyid2V9WQzB99n6MtG1Re/n6gzB9+T6MtG1Re3sKmwOWWj6ovfTwGZg+919GWj6otb2Kj64hY2qr64gU3wPZS+bFR98fvfM8zB91v6slH1xS1sKmxO2aj64hY2qr64hY2qL25ho+qLW9io+uIGNsH3h/qywRefs8EXn7PBF5+zqbA5ZYMvPmeDLz5ngy8+Z4MvPmeDLz5lE3xHri8bfPE5G3zxORt88TmbCptTNvjiczb44nM2+OJzNvjiczb44lM2wfeq+rLBF5+zwRefs8EXn7OpsDllgy8+Z4MvPmeDLz5ngy8+Z4MvPmUTe+/hvi33PwPet6Nasml47y72JkNnNhU2p2xC+xtnNqH9jTOb0P7GmU1of+PMJrS/8WUTew+fM5vQfT9nNvjiczaqvrjh3fnY++yc2aj64hY2qr64hY2qL254Bzr2XjhnNqq+uIFN7N1tzmxUfXELG1Vf3MJG1Rc3/J4h9g40ZzaqvriFjaovbmGj6otb2Kj64hY2qr64gU3sfV/ObFR9cQsbVV/cwgZffM6mwuaUDb74nA2++JwNvvicDb74nA2++JRN7L1lzmzwxeds8MXnbPDF52wqbE7Z4IvP2eCLz9ngi8/Z4IvP2eCLz9jU2HvLnNngi8/Z4IvP2eCLz9lU2JyywRefs8EXn7PBF5+zwRefs8EXn7KJvbfMmQ2++JxN/XE2tm/HVYctUdYVrMNXsA1fwT58BcfoFTjsGLKuYBq+gjJ8BfPwFQx/J5fYd/L7d2BriX0nt1QQ+05uqSD2ndxSQew7+f07dnWOfSe3VBD7Tm6pIPad3FJB7Du5pYLYd3JLBbHv5IZexRz7Tm6pIPad3FJB7Du5pYLYd3JDBTX2ndxSQew7uaWC2HdySwWx7+SWCmLfyS0VDH8n1+Hv5Dr8nVyHv5Pr8HfyMvydvAx/Jy/D38nL8Heyw5x66wqGv5OX4e/kZfg7eRn+Tl6Gv5PX4e/kdfg7eR3+Tl6Hv5MdZmRbVzD8nbwOfyevw9/J6/B38jr8nbwNfydvw9/J2/B38jb8nWwzZ3W6H6pMa7WsoOFvvGymobpWsA9fwTF6BTbzP10rmIavoAxfwTx8BXX4CpbhKxj+Tt5j38kNfzG7x76TWyqIfSc3VHDEvpNbKoh9Jzf8teYR+05uqSD2ndxSQew7uaWC2HdySwWx7+SWCmLfyQ29iiP2ndxSQew7+X0FyyX2ndxSQew7uaWC2HdySwWx7+SWCmLfyS0VxL6TWyqIfSe3VDD6nbxcRr+Tl8vwd/I0/J08DX8nT8PfydPwd7LNDCnXCoa/k6fh7+Rp+Dt5Gv5Onoa/k8vwd3IZ/k4uw9/JZfg72WaGlGsFw9/JZfg7uQx/J5fh7+Qy/J08D38nz8PfyfPwd/I8/J1sM0PKtYLh72ST+UWXutwruBwXywre/43XYjK/yLUCk/lFvhVMw1dQhq9gHr6COnwFy/AVrMNXsA1fwfB3co19J7//i9lliX0nt1QQ+05uqSD2ndxSQew7+f1fay4m84t8K4h9J7dUEPtObqkg9p3cUkHsO7mlgth3ckOvYo19J7dUEPtObqkg9p3cUkHsO7mlgth3cksFse/klgpi38ktFcS+k1sqiH0nt1Qw/J28DX8nb8Pfydvwd/I2/J28DX8nb8Pfydvwd/I2/J28DX8nb8Pfyfvwd/I+/J28D38n78PfySYzpHwrGP5O3oe/k/fh7+R9+Dt5H/5OPoa/k4/h7+Rj+Dv5GP5ONpkh5VvB8HfyMfydfIx6J1//t//3f/q//sv/9D//7//b/339J27/z//nv/4v/+2//B//9ff/+t/+v//z6/9z/ez/Dw=="},{"name":"assert_block_number","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"expiry_block_number","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/92Zy67iRhCGm8vhnBAw5k4wBoPtc13nLHKkLLPMK0S5KYpyU5LJIrOMImUTKW+QB5qnmq6qLv+ANYwajVpHg2Rsqv/PVV19gcKFaRlzZQ9jUuNeZDGR6dhTg45PjV7Zi6Y9GpFpqKmkRqKapZOZFl+RsL2zb92PjboY0NsFv3ce+Jqu7HFZmAahFxd0Z3OpTQUFw1i31PCuOEJ+delNNIR9UKDF3vBze/5QxFdO3CubYjQ9YD3RdOWS0V9gVrTPKAn6QPtA+w59AbOiEaMkiIBGQCOHZjArOmCUBAOgA6ADh34Ps6IxoySIgcZAY4f+DLOiQ0ZJMAQ6BDqUcx0Z+CP9d+7F9ulLmBUdMUqCEdAR0JFDf4RZ0TGjJBgDHQMd1wMdV4GeQKy3lzArOmGUBBOgE6ATh34Ls6JTRkkwBToFOnXoNzArOmOUBDOgM6AzOm9pab3AwowZNFiNuvxIbUpdovaObYPXnF3ND10tBJ7JpbZQAhcQLbHAkw5fJk6/chtI2mAh7WUrOjjiX+WTdpeYtFTZR3AsDU0xUqN6WNKZVud3e2EdBfzY0HVFc8xcyi53Idub2+bmgn9CTJW2GdK2ONzPuuiuTULjs8NoSbysol3uZUk0Cxc4oX/ArGjCKPcMaAI0qfcxqbaFE4j19jXMiq4YTWSkFF0BXdW9rartwRMZ+CM9fyT2RyJ/ZHgascn+HWZFZQ6TIAWaAk3r3s5GJqcRG+BvMCu6ZpQEa6BroOu6t3U1G04g1tsXMCu6YZQEG6AboBuHfgWzohmjJMiAZkCzeqBZ9WXhifT8keQ0Yvv0A8yKbhklwRboFui27m1bZdATif2R5WnE9uknmBXdMUqCHdAd0F3d264aWk9k4o+k/kjkjyT+yNAfiYP0pRcksNFpxM61P2FWNGeUBDnQHGhe95ZXafBENv7IJEhgiT8y9EdGQZAzMjYNkuSBPxL7I/0gGUuD9OXZzrG3bBf0zdX4BxXCE4MGZYHWAXlVWC3kjvuFVcGuikNXpcC543KUICVEN6g0bqWwunX6O1dY3UthdU8mOjjiv+WTdpeY+1Jl13AsDU0xUqN6uKFzZu/0ci+so4AfXXlonlwol/InUUsLK6BI2fwoZehqUey3tEQro1AVU4taXZpjtOrI0h+J/ZHEH+n7IwN/pBek+5E/MvRHVkGQiT+SBhn9tT+y8UdGQebYGeslC5KxMyb/GTvMNshQhpnJUZDRH5pnuo+F2WDPWJW7IN0PMy2f7RwbBUHOyNg0SJLP+HrtBxmXMD+u3qc59pbtgr6xmv/hF/2T2X9Mkh89Jin1t/3isAgq2VV56Ooa9dY1WqhkuIboFpXBnRRBd1qxuMrjQYqgB1fh3HPE/5qqpJk75qFU2Q0cS0NTjNSoHqgQusvsnf7aC+so4EdXNZonfrTWKvj5+P6LPpf81J47X8oTp5b72Ik4SWRaiIhu3RJrC4L2GwXtTnWHtkRAIZk2ijFu5pT8T1ccsgwdj8YrOl4DksLCQ3AgAAA=","debug_symbols":"vd3Rah5VFMXxd8l1kZm91tpnpq8iIlGrBEoqNgpSfHdTTdOCn8Z/6vYqfMnZhzNZWbn4cWDeXX336puff/j65vb7N2+vXn757ur1m2+v727e3N5/ene1fbFvf3z37Y/Xt++/8fbu+qe7q5fbi6tXt9/df/3txdX3N69fXb3M/tuLvyw7k4eF51qPS/eqC2u9rw+LvR9+XH3mwuIurYfFXdGni7968f7U+2ecet9UDyv3Lf5fz12f89s+94/HzhPH3vfdH1bva/vnYy8/PuPKfvz12Jo59p+be3LzTG7ek5uvyc2Pyc3Pwc1rm9x8n9y8JjefbGhNNrQmG1qTDa3JhtZkQ2uyoZpsqCYbqsmGarKhmmyoJhuqyYZqsqGabKgmG+rJhnqyoZ5sqCcb6smGerKhnmyoJxvqyYZ6sqGZbGgmG5rJhmayoZlsaCYbmsmGZrKhmWxoJhvakw3tyYb2ZEN7sqE92dCebGhPNrQnG9qTDe3Jhq7Jhq7Jhq7Jhq7Jhq7Jhq7Jhq7Jhq7Jhq7Jhq7Jhh6TDT0mG3pMNvSYbOgx2dBjsqHHZEOPyYYekw09Jht6Tjb0nGzoOdnQc7Kh52RDz8mGnpMNPScbek429Jxs6L5to7vvo7vX6O6jtxY2j+4+em9hG724sI3eXNhGry5so13dR7u6j3Z1H+3q7A2j2StGs3eMPuuSkVUfboFZqsfFly+v6TgeFre3S5fuPqfY//H9v3//X+Bh4IQD4KLRw8BOB4oOiA6YDoQONB1YdIAmXTRp0aRFkxZNWjRp0aRFkxZNWjRp0aRFkzZN2jRp06RNkzZN2jRp06RNkzZN2jTp0KRDkw5NOjTp0KRDkw5NOjTp0KRDk26adNOkmybdNOmmSTdNumnSTZNumnTTpBdNetGkF0160aQXTXrRpBdNetGkF0160aQPmvRBkz5o0gdN+qBJHzTpgyZ90KQPmvRBkz5p0idN+qRJnzTpkyZ90qRPmvRJkz5p0idMuraNDux0oOiA6IDpQOhA04FFBw46QJPeadI7TXqnSe806Z0mvdOkd5r0TpOmRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyIoaWVEjK2pkRY2sqJEVNbKiRlbUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyJoaWVMja2pkTY2sqZE1NbKmRtbUyJoaWVMja2pkTY2sqZE1NbKmRtbUyJoaWVMja2pkTY2sqZE1NbKmRtbUyJoaWVMja2pkTY2sqZE1NbKmRtbUyJoaWVMja2pkTY2sqZE1NbKmRtbUyJoaWVMja2pkTY2sqZE1NbKmRtbUyJoaWVMja2pkTY2sqZE1NbKmRtaXjUzr8bVAOnZ9OnbhzTorHxZ79cd3CF1+s846H9+sc+zHp4sfDtRPHsjrwnMczxs7/2Zsexz75K1Ij2OXke3psf15Yxf/bHSsj892Xni2y+z29JifN5Ynn+3iWD9vbD1v7Hje2EnH7j/8cv3TzfU3r1+9vR95/7Ofb7+9u3lz+/Dx7tcf//zJ/drfAQ=="},{"name":"assert_not_expired","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"expiry_block_number","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/92ZyY7bRhCGW/tEETftEUVtFGc9Z4DMIccc8wpBNgQBgqxOkPgUwAZ892P5qdxV3cVfEmEaLRgNwQIotqr/j1W9Ttdwr1pKXelLqUzZD1lUqLr61qDrSyUlXWjqqxGqhpgKqiSqWViZanGJhO2d/up/rsRFRF8d/u4+cJlK+urtVYPQboeerHrW3NlTMIz1CwnviiPkT5++jIawT/ao0Q/8Wt8/NeIrKx4UTWNUA2ADo+mbIqO/wSxowCgJAqAB0MCiz2AWNGSUBCHQEGho0Q3MgkaMkiACGgGNLPozzILGjJIgBhoDjS36K8yCJoySIAGaAE3MvYpE7kjwwb3oNn0Ls6BDRkkwBDoEOrToLzALOmKUBCOgI6CjaqCjMtAaRHt7DrOgY0ZJMAY6Bjq26I8wCzphlAQToBOgE4v+ALOgU0ZJMAU6BTql+5aW1jMszJhBhdUoy4/UqpAlqp/YVvjM2NXs2NXcwFNTlBrqwDlECyzwtMvF1OqXdgPJGiykvWxJF0f8h/klzSUmK0T2GRybiqYxUqV4WNCdVudPB2GdBPzYkHVFc0z1zF7XMdub3epmBv+CmLLbpui2+fF+1kdzdSc0vjqOlsSLMtrFQS8ZzdwGTujfMAuaMsotA5oCTattTMttoQbR3r6HWdAlo6kZKUGXQJdVb8tye3BEIndk4I7E7kjojiT1iO7sv2AW1MxhEmRAM6BZ1dvZyLge0QH+CbOgK0ZJsAK6ArqqeluVs6EG0d6+gVnQNaMkWANdA11Xva3LIXZEBu5I4I6c0ZZxPaJ77l+YBd0wSoIN0A3QjUV/h1nQLaMk2ALdAt1WA92Wq9cRydyRsTsycUdCdyR1RxJ3JPbSloGXwIb1iJ6e/8Es6I5REuyA7oDuqt52ZTfUINrbdzALmjNKghxoDjSvesvLaeqIhO5I6o4k7sjQC3JGj028dHLkjsTuSOClxzIvbbnYObatR6i68QLH/ScGFc74cqjPyyxpbp54mCXt2dX+2FVh4NxyOfKJAqIbpA23Jku6tfo7myXdmyzpnkx0ccT/m1/SXGLuC5Fdw7GpaBojVYqHG7pv9JP+OQjrJOBHm+upJxtKx/zHp2UzpB5QdNnspMvQ1P3+sKZltGYUysxoXkkyc4xWFVm4I7E7krojgTsSuSMDL80P3ZHEHVl6QcbuSOZl9FdehnJwqW05Y1zW7sjGy6rMvDR/4mUhn7H1JepCNyU/u+XQHdl6af7Oy7S82Dk29IJc7EI+429l4GVc/JyUPqY59p7tgqqbr3A8f1KHLzDykxcYhRzU58cZTcGuimNX10ierlFD5/9riG5xzL8zGc2dpB82jXgwGc2DTVfuOeKXqsxPZpZ5KER2A8emommMVCkeKKu52+gnPT8I6yTgR5sCqid+6dUKuc0kKfgdOje4Z6w9CNrvFLS75RPYhFfilCC1uWWvqcSezQhwp76h6y3rz63s0R8AAA==","debug_symbols":"vd3halzXFcXxd9FnU+7da6197vWrlFKUxCkCI4dYKRSTd6/cjGRBpnX/cnY+idGcfTijpSXQjwP3080P77775R9/v7v/8cPHm7d//XTz/sP3tw93H+4fX3262f6yb//57sefbu8/f+Pjw+3PDzdvtzc37+5/ePz665ubH+/ev7t5m/3XN79bdiaXhedaz0v3qitrva+nxd4PP68+c2Vxl9ZlcVf0cvHf3nw+9f4Np9431WXlvsV/6rnrW37a5/7l2PnKsfd999PqfW3/+9jLz59xZT9+f2zNHPu3zT25eSY378nN1+Tmx+Tm5+DmtU1uvk9uXpObTza0Jhtakw2tyYbWZENrsqE12VBNNlSTDdVkQzXZUE02VJMN1WRDNdlQTTZUkw31ZEM92VBPNtSTDfVkQz3ZUE821JMN9WRDPdnQTDY0kw3NZEMz2dBMNjSTDc1kQzPZ0Ew2NJMN7cmG9mRDe7KhPdnQnmxoTza0Jxvakw3tyYb2ZEPXZEPXZEPXZEPXZEPXZEPXZEPXZEPXZEPXZEPXZEOPyYYekw09Jht6TDb0mGzoMdnQY7Khx2RDj8mGHpMNPScbek429Jxs6DnZ0HOyoedkQ8/Jhp6TDT0nG3pONnTfttHd99Hda3T30VsLm0d3H723sI1eXNhGby5so1cXttGu7qNd3Ue7uo92dfaG0ewVo9k7Rt90yciqp1tglup58fXLazqOy+L2du3S3bcU+w++//f//xW4DJxwAFw0ugzsdKDogOiA6UDoQNOBRQdo0kWTFk1aNGnRpEWTFk1aNGnRpEWTFk1aNGnTpE2TNk3aNGnTpE2TNk3aNGnTpE2TDk06NOnQpEOTDk06NOnQpEOTDk06NOmmSTdNumnSTZNumnTTpJsm3TTppkk3TXrRpBdNetGkF0160aQXTXrRpBdNetGkF036oEkfNOmDJn3QpA+a9EGTPmjSB036oEkfNOmTJn3SpE+a9EmTPmnSJ036pEmfNOmTJn3CpGvb6MBOB4oOiA6YDoQONB1YdOCgAzTpnSa906R3mvROk95p0jtNeqdJ7zRpamRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjayokRU1sqJGVtTIihpZUSMramRFjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNzNTITI3M1MhMjczUyEyNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjSzUyEKNLNTIQo0s1MhCjaypkTU1sqZG1tTImhpZUyNramRNjaypkTU1sqZG1tTImhpZUyNramRNjaypkTU1sqZG1tTImhpZUyNramRNjaypkTU1sqZG1tTImhpZUyNramRNjaypkTU1sqZG1tTImhpZUyNramRNjaypkTU1sqZG1tTImhpZUyNramR93cj0+B/kZUY583LsyhNdVp6eXePVXxZff6LLOp+f6HLsx8vFlwMd/+VA9XSgfvFMmi+f43zV2HWP+/rY1d+tx7X9PPbiKTtfxup1Y3rdmL/62a6O5XVj/bqxRcceX/zz9ue72+/ev/v4OPL5vV/uv3+4+3B/efnwr59+e+dx7b8B"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000a0aba6e5"},{"kind":"string","value":"SubscriptionNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"target_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"subscription_token_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"subscription_recipient_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"subscription_price","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"subscriptions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"gas_token_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"gas_token_limit_per_tx","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"expiry_block_number","type":{"kind":"field"}}],"kind":"struct","path":"AppSubscription::assert_block_number_parameters"}}],"kind":"struct","path":"AppSubscription::assert_block_number_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"subscriber_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce","type":{"kind":"field"}},{"name":"expiry_block_number","type":{"kind":"field"}},{"name":"tx_count","type":{"kind":"field"}}],"kind":"struct","path":"AppSubscription::subscribe_parameters"}}],"kind":"struct","path":"AppSubscription::subscribe_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"subscription_recipient_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"subscription_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"subscription_price","type":{"kind":"field"}},{"name":"gas_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_token_limit_per_tx","type":{"kind":"field"}}],"kind":"struct","path":"AppSubscription::constructor_parameters"}}],"kind":"struct","path":"AppSubscription::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":1,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"dapp_payload::DAppPayload"}},{"name":"user_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AppSubscription::entrypoint_parameters"}}],"kind":"struct","path":"AppSubscription::entrypoint_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"expiry_block_number","type":{"kind":"field"}}],"kind":"struct","path":"AppSubscription::assert_not_expired_parameters"}}],"kind":"struct","path":"AppSubscription::assert_not_expired_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    constants::{GENERATOR_INDEX__IVSK_M, GENERATOR_INDEX__OVSK_M}, hash::poseidon2_hash\n};\n\nuse std::field::bytes32_to_field;\n\nuse crate::oracle::unsafe_rand::unsafe_rand;\n\nuse crate::event::event_interface::EventInterface;\nuse crate::note::note_interface::NoteInterface;\n\nuse crate::encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n};\n\npub fn compute_encrypted_event_log<Event, NB, MB, OB>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    let eph_sk: Scalar = fr_to_fq(unsafe_rand());\n    let eph_pk = eph_sk.derive_public_key();\n\n    // TODO: (#7177) This value needs to be populated!\n    let recipient = AztecAddress::from_field(0);\n\n    let ivpk_app = compute_ivpk_app(ivpk, contract_address);\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_Header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk_app);\n    let outgoing_body_ciphertext: [u8; 176] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk_app).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now \n\n    let eph_pk_bytes = pub_key_to_bytes(eph_pk);\n    for i in 0..64 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[128 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[176 + i] = outgoing_Header_ciphertext[i];\n    }\n    for i in 0..176 {\n        encrypted_bytes[224 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 400;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[400 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (64 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (176 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field elememt to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let r_bytes = r.to_be_bytes(32);\n\n    let mut high_bytes = [0; 32];\n    let mut low_bytes = [0; 32];\n\n    for i in 0..16 {\n        high_bytes[16 + i] = r_bytes[i];\n        low_bytes[16 + i] = r_bytes[i + 16];\n    }\n\n    let low = bytes32_to_field(low_bytes);\n    let high = bytes32_to_field(high_bytes);\n\n    Scalar::new(low, high)\n}\n\nfn compute_ivpk_app(ivpk: Point, contract_address: AztecAddress) -> Point {\n    // It is useless to compute this, it brings no value to derive fully.\n    // Issue(#6955)\n    ivpk\n    /*\n    // @todo Just setting infinite to false, but it should be checked.\n    // for example user could define ivpk = infinity using the registry\n    assert((ivpk.x != 0) & (ivpk.y != 0), \"ivpk is infinite\");\n\n    let i = fr_to_fq(poseidon2_hash([contract_address.to_field(), ivpk.x, ivpk.y, GENERATOR_INDEX__IVSK_M]));\n    let I = i.derive_public_key();\n\n    let embed_I = Point { x: I.x, y: I.y, is_infinite: false };\n    let embed_ivpk = Point { x: ivpk.x, y: ivpk.y, is_infinite: false };\n\n    let embed_result = embedded_curve_add(embed_I, embed_ivpk);\n\n    Point::new(embed_result.x, embed_result.y)*/\n}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL, utils::arrays::find_index\n};\n\nunconstrained fn compute_unconstrained<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note)\n}\n\nfn compute<Note, N, NB, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: Point,\n    ivpk: Point,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: Point,\n    ivpk: Point,\n    inner_compute: fn(AztecAddress, Field, Field, Point, Point, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists_index = find_index(\n        context.note_hashes.storage,\n        |n: NoteHash| n.counter == note_hash_counter\n    );\n    assert(\n        note_exists_index as u32 != MAX_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n    );\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(contract_address, storage_slot, ovsk_app, ovpk, ivpk, note);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let header = context.get_header();\n        let ovpk = header.get_ovpk_m(context, ov);\n        let ivpk = header.get_ivpk_m(context, iv);\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, N, NB, M>(\n    context: &mut PrivateContext,\n    ovpk: Point,\n    ivpk: Point\n) -> fn[(&mut PrivateContext, Point, Point)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, compute_unconstrained);\n    }\n}\n"},"104":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash\n};\n\nuse std::aes128::aes128_encrypt;\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk_app: Point,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk_app: Point) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk_app }\n    }\n\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 176] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer: [u8; 160] = [0; 160];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk_app = self.recipient_ivpk_app.serialize();\n        let serialized_recipient_ivpk_app_x = serialized_recipient_ivpk_app[0].to_be_bytes(32);\n        let serialized_recipient_ivpk_app_y = serialized_recipient_ivpk_app[1].to_be_bytes(32);\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n            buffer[i + 96] = serialized_recipient_ivpk_app_x[i];\n            buffer[i + 128] = serialized_recipient_ivpk_app_y[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash(\n            [\n            ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y,\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ]\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::outgoing_body::EncryptedLogOutgoingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash\n    };\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body() {\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        );\n        let recipient_ivsk_app = Scalar::new(\n            0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        );\n        let sender_ovsk_app = Scalar::new(\n            0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        );\n\n        let eph_pk = eph_sk.derive_public_key();\n        let recipient_ivpk_app = recipient_ivsk_app.derive_public_key();\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk_app);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        let expected_outgoing_body_ciphertext = [\n            127, 84, 96, 176, 101, 107, 236, 57, 68, 8, 53, 202, 138, 74, 186, 54, 74, 193, 245, 7, 109, 59, 218, 33, 1, 31, 205, 225, 241, 209, 64, 222, 94, 245, 4, 150, 47, 241, 187, 64, 152, 20, 102, 158, 200, 217, 213, 82, 1, 240, 170, 185, 51, 80, 27, 109, 63, 231, 235, 120, 174, 44, 133, 248, 10, 97, 60, 40, 222, 190, 147, 76, 187, 48, 91, 206, 48, 106, 56, 118, 38, 127, 82, 4, 182, 188, 44, 224, 31, 129, 47, 107, 134, 252, 20, 25, 122, 191, 158, 69, 35, 255, 215, 171, 196, 45, 91, 184, 83, 80, 238, 201, 1, 233, 235, 159, 171, 130, 158, 64, 176, 165, 132, 30, 84, 81, 71, 195, 145, 47, 82, 247, 210, 192, 23, 4, 220, 90, 56, 109, 46, 105, 79, 251, 165, 141, 185, 233, 191, 118, 219, 153, 191, 162, 99, 238, 241, 249, 9, 74, 210, 241, 54, 28, 126, 226, 85, 235, 174, 75, 239, 207, 100, 184, 248, 194\n        ];\n\n        for i in 0..expected_outgoing_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_outgoing_body_ciphertext[i]);\n        }\n        assert_eq(expected_outgoing_body_ciphertext.len(), ciphertext.len());\n    }\n}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {\n        let full_key = point_to_symmetric_key(secret, point);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    let expected_header_ciphertext = [\n        228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 23, 131, 32, 226, 26, 176, 43, 39, 239, 177, 177, 192, 85, 216, 17, 15, 18, 187, 35, 225, 135, 192, 63, 88, 29, 173, 232, 46, 72, 82, 187, 139\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext);\n}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nstruct EncryptedLogIncomingBody<M> {\n    plaintext: [u8; M]\n}\n\nimpl<M> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, N>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, MR>(event: T, randomness: Field) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk_app: Point) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk_app);\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use crate::encrypted_logs::incoming_body::EncryptedLogIncomingBody;\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, traits::Serialize, abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n        context::PrivateContext\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_content_hash(self) -> Field {1}\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n            (1, 1)\n        }\n\n        fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {(1,1)}\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body() {\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_note_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 48, 153, 169, 1, 25, 182, 93, 39, 39, 207, 251, 218, 234, 147, 156, 13, 110, 180, 190, 199, 41, 6, 211, 203, 176, 110, 165, 186, 110, 127, 199, 22, 201, 149, 92, 249, 219, 68, 145, 68, 179, 29, 233, 34, 98, 123, 197, 234, 169, 53, 44, 14, 81, 60, 92, 27, 250, 134, 49, 248, 57, 119, 236, 118, 158, 104, 82, 243, 98, 164, 60, 72, 74, 27, 177, 194, 221, 225, 193, 150, 67, 235, 205, 106, 150, 24, 126, 186, 220, 178, 199, 189, 113, 54, 181, 55, 46, 15, 236, 236, 9, 159, 5, 172, 237, 154, 110, 50, 241, 64, 92, 13, 37, 53, 20, 140, 42, 146, 229, 63, 97, 25, 159, 63, 235, 104, 68, 100\n        ];\n\n        assert_eq(expected_note_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_note_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_note_body_ciphertext[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar::new(\n            0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        );\n\n        let ivpk_app = Point::new(\n            0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            false\n        );\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk_app);\n\n        let expected_event_body_ciphertext = [\n            228, 9, 65, 81, 62, 59, 249, 207, 90, 196, 206, 72, 39, 199, 82, 196, 63, 127, 188, 251, 150, 188, 238, 205, 3, 86, 102, 164, 175, 12, 137, 158, 163, 111, 205, 10, 229, 230, 46, 202, 110, 107, 156, 180, 67, 192, 161, 201, 66, 122, 29, 35, 42, 33, 153, 216, 199, 208, 103, 207, 126, 153, 189, 136, 19, 220, 238, 15, 169, 29, 255, 11, 123, 107, 70, 192, 53, 40, 36, 93, 187, 32, 123, 136, 104, 23, 229, 245, 152, 90, 84, 2, 136, 112, 42, 27, 82, 214, 104, 14, 250, 48, 199, 245, 88, 22, 200, 77, 38, 51, 127, 56, 138, 255, 16, 46, 179, 129, 215, 185, 185, 116, 148, 16, 133, 62, 56, 180, 10, 132, 109, 77, 206, 199, 21, 167, 7, 163, 171, 158, 244, 23, 18, 121, 108, 42, 107, 7, 48, 84, 212, 104, 39, 16, 109, 7, 108, 129, 60, 80, 112, 241, 223, 140, 186, 158, 38, 74, 230, 213, 159, 175, 142, 228, 128, 160\n        ];\n\n        assert_eq(expected_event_body_ciphertext.len(), ciphertext.len());\n\n        for i in 0..expected_event_body_ciphertext.len() {\n            assert_eq(ciphertext[i], expected_event_body_ciphertext[i]);\n        }\n    }\n}\n"},"110":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<N>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N, M>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nfn constrain_get_notes_internal<Note, N, M, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> where Note: NoteInterface<N, M> {\n    let mut returned_notes = BoundedVec::new();\n\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        let opt_note = filtered_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            // The below code is used to collapse a sparse array into one where the values are guaranteed to be at the \n            // front of the array. This is highly useful because the caller knows that the returned array won't have\n            // more than option.limits notes, and can therefore loop over this limit value instead of the entire array,\n            // resulting in a smaller circuit and faster proving times.\n            // We write at returned_notes[num_notes] because num_notes is only advanced when we have a value in \n            // filtered_notes.\n            returned_notes.push(note);\n        };\n    }\n\n    // As long as we only loop till `options.limit` the array will be guaranteed to be at most of length `options.limit`.\n    assert(returned_notes.len() <= options.limit, \"Got more notes than limit.\");\n    // We will however check that nothing else was returned after the limit.\n    for i in options.limit..filtered_notes.len() {\n        assert(filtered_notes[i].is_none(), \"Got more notes than limit.\");\n    }\n\n    assert(returned_notes.len() != 0, \"Cannot return zero notes\");\n\n    returned_notes\n}\n\nunconstrained fn get_note_internal<Note, N, M>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, M, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained pub fn view_notes<Note, N, M>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"112":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\nfn compute_inner_note_hash<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N, M>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, N, M>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, N, M, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"113":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_inner_note_hash, compute_note_hash_for_consumption}, note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(inner_note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let inner_note_hash = compute_inner_note_hash(*note);\n\n    context.push_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let (note_hash, nullifier) = note.compute_note_hash_and_nullifier(context);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let note_hash_for_consumption = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a non-transient note and we don't populate the note_hash with real\n        // value (if we did so the `notifyNullifiedNote` oracle would throw).\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a transient note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can find it and squash both\n        // the note and the nullifier.\n        note_hash\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, note_hash_for_consumption, nullifier_counter) == 0);\n\n    context.push_nullifier(nullifier, note_hash_for_consumption)\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(self) {}\n}\n"},"117":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_header.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse dep::protocol_types::traits::{Empty, Eq, Serialize};\n\nstruct NoteHeader {\n    contract_address: AztecAddress,\n    nonce: Field,\n    storage_slot: Field,\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    // Check the nonce to see whether a note is transient or not.\n    note_hash_counter: u32, // a note_hash_counter of 0 means non-transient\n}\n\nimpl Empty for NoteHeader {\n    fn empty() -> Self {\n        NoteHeader { contract_address: AztecAddress::zero(), nonce: 0, storage_slot: 0, note_hash_counter: 0 }\n    }\n}\n\nimpl Eq for NoteHeader {\n    fn eq(self, other: Self) -> bool {\n        (self.contract_address == other.contract_address) & \n        (self.nonce == other.nonce) & \n        (self.storage_slot == other.storage_slot)& \n        (self.note_hash_counter == other.note_hash_counter)\n    }\n}\n\nimpl NoteHeader {\n    pub fn new(contract_address: AztecAddress, nonce: Field, storage_slot: Field) -> Self {\n        NoteHeader { contract_address, nonce, storage_slot, note_hash_counter: 0 }\n    }\n}\n\nimpl Serialize<4> for NoteHeader {\n    fn serialize(self) -> [Field; 4] {\n        [self.contract_address.to_field(), self.nonce, self.storage_slot, self.note_hash_counter as Field]\n    }\n}\n"},"121":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"122":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"123":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"124":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<M>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<M>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\nunconstrained pub fn emit_encrypted_event_log<M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<N, M>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<N, M>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<N, M>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<N>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"125":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"127":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"128":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field\n) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number as Field, N)\n}\n\nunconstrained pub fn storage_read<T, N>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"135":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::PublicKeys;\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\nfn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: Point::new(result[0], result[1], result[2] as bool),\n        ivpk_m: Point::new(result[3], result[4], result[5] as bool),\n        ovpk_m: Point::new(result[6], result[7], result[8] as bool),\n        tpk_m: Point::new(result[9], result[10], result[11] as bool)\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"138":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        inner_note_hash,\n        counter\n    )\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, NB, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"140":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"145":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr","source":"use dep::protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions, note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field\n}\n// docs:end:struct\n\nmod test;\n\nimpl<T, Context> Storage<T> for PrivateMutable<T, Context> {}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_note_hash_and_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_note_hash_and_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<N, M>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier, 0);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N, M>(\n        self,\n        new_note: &mut Note\n    ) -> NoteEmission<Note>  where Note: NoteInterface<N, M> {\n        let prev_note: Note = get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(self.context, prev_note);\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<N, M>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note>  where Note: NoteInterface<N, M> {\n        let is_initialized = check_nullifier_exists(self.compute_initialization_nullifier());\n\n        // check_nullifier_exists() is an unconstrained function - we can constrain a true value by providing an \n        // inclusion proof of the nullifier, but cannot constrain a false value since a non-inclusion proof would only \n        // be valid if done in public.\n        // Ultimately, this is not an issue ginen that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate \n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able to produce\n        //    an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious oracle\n        // (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce a proof.\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<N, M>(self) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        let mut note = get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(self.context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, &mut note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UnconstrainedContext> {\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N, M>(self) -> Note where Note: NoteInterface<N, M> {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"155":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation \n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the \n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a \n// reduced delay, invalidating prior private reads.\nstruct ScheduledDelayChange<INITIAL_DELAY> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option, \n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numeric value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\nimpl<INITIAL_DELAY> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This \n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is \n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in \n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33) \n            + (self.post.is_some() as u64 * (1 << 32)) \n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<INITIAL_DELAY> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some { Option::some(pre_inner) } else { Option::none() },\n            post: if post_is_some { Option::some(post_inner) } else { Option::none() },\n            block_of_change,\n            _dummy: [0; INITIAL_DELAY],\n        }\n    }\n}\n\nimpl<INITIAL_DELAY> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"157":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable_private_getter.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, traits::{FromField, ToField}, address::AztecAddress,\n    header::Header\n};\n\nuse crate::context::PrivateContext;\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n    shared_mutable::SharedMutable, scheduled_delay_change::ScheduledDelayChange,\n    scheduled_value_change::ScheduledValueChange\n}\n};\n\nstruct SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    context: &mut PrivateContext,\n    // The contract address of the contract we want to read from\n    other_contract_address: AztecAddress,\n    // The storage slot where the SharedMutable is stored on the other contract\n    storage_slot: Field,\n    // The _dummy variable forces INITIAL_DELAY to be interpreted as a numberic value. This is a workaround to\n    // https://github.com/noir-lang/noir/issues/4633. Remove once resolved.\n    _dummy: [Field; INITIAL_DELAY],\n}\n\n// We have this as a view-only interface to reading Shared Mutables in other contracts.\n// Currently the Shared Mutable does not support this. We can adapt SharedMutable at a later date\nimpl<T, INITIAL_DELAY> SharedMutablePrivateGetter<T, INITIAL_DELAY> {\n    pub fn new(\n        context: &mut PrivateContext,\n        other_contract_address: AztecAddress,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        assert(other_contract_address.to_field() != 0, \"Other contract address cannot be 0\");\n        Self { context, other_contract_address, storage_slot, _dummy: [0; INITIAL_DELAY] }\n    }\n\n    pub fn get_value_in_private(self, header: Header) -> T where T: FromField + ToField + Eq {\n        // We create a dummy SharedMutable state variable so that we can reuse its historical_read_from_public_storage\n        // method, greatly reducing code duplication. \n        let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), self.storage_slot);\n        let (value_change, delay_change, historical_block_number) = dummy.historical_read_from_public_storage(header, self.other_contract_address);\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // If our context has the same header as the one we pass in via the parameter, we are trying to read the \"current\" value\n        // and thus need to set the tx max block number below. If the context header is not the same as the one we pass in, this means\n        // we are trying to read a historical value and thus have no constraint on the max block number that this transaction can be included in.\n        if (self.context.historical_header.global_variables.block_number.eq(header.global_variables.block_number)) {\n            self.context.set_tx_max_block_number(block_horizon);\n        }\n\n        value_change.get_current_at(historical_block_number)\n    }\n}\n"},"159":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\nstruct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> {\n    fn serialize(self) -> [Field; 3] where T: ToField {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> {\n  fn deserialize(input: [Field; 3]) -> Self  where T: FromField {\n    Self {\n        pre: FromField::from_field(input[0]),\n        post: FromField::from_field(input[1]),\n        block_of_change: FromField::from_field(input[2]),\n    }\n  }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>  {\n    fn eq(self, other: Self) -> bool where T: Eq {\n        (self.pre == other.pre) & (self.post == other.post) & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{pedersen_hash, poseidon2_hash}, header::Header, address::AztecAddress,\n    traits::{FromField, ToField}\n};\n\nuse crate::context::{PrivateContext, PublicContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::unsafe::zeroed;\n\nmod test;\n\nstruct SharedMutable<T, INITIAL_DELAY, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, INITIAL_DELAY, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// TODO: extract into a utils module once  we can do arithmetic on generics, i.e. https://github.com/noir-lang/noir/issues/4784\nfn concat_arrays<N, M, O>(arr_n: [Field; N], arr_m: [Field; M]) -> [Field; O] {\n    assert_eq(N + M, O);\n    let mut out: [Field; O] = [0; O];\n    for i in 0..N {\n        out[i] = arr_n[i];\n    }\n    for i in 0..M {\n        out[N+i] = arr_m[i];\n    }\n    out\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, INITIAL_DELAY, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field where T: ToField {\n        // TODO(#5491 and https://github.com/noir-lang/noir/issues/4784): update this so that we don't need to rely on\n        // ScheduledValueChange serializing to 3 and ScheduledDelayChange serializing to 1\n        let concatenated: [Field; 4] = concat_arrays(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 0], 0)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 1], 0)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        pedersen_hash([self.storage_slot, 2], 0)\n    }\n\n    // It may seem odd that we take a header and address instead of reading from e.g. a PrivateContext, but this lets us\n    // reuse this function in SharedMutablePrivateGetter.\n    fn historical_read_from_public_storage(\n        self,\n        header: Header,\n        address: AztecAddress\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) where T: FromField + ToField + Eq {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = get_public_storage_hints(address, self.storage_slot, historical_block_number);\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        // @todo This is written strangely to bypass a formatting issue with the if that is breaking ci.\n        let (a, b, c) = if hash != 0 {\n            let a = SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint);\n            (a, value_change_hint, delay_change_hint)\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            let b = ScheduledValueChange::deserialize(zeroed());\n            let c = ScheduledDelayChange::deserialize(zeroed());\n            (hash, b, c)\n        };\n\n        assert_eq(hash, a, \"Hint values do not match hash\");\n        assert_eq(value_change_hint, b, \"Non-zero value change for zero hash\");\n        assert_eq(delay_change_hint, c, \"Non-zero delay change for zero hash\");\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> {\n    pub fn schedule_value_change(self, new_value: T) where T: ToField {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) where T: ToField {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) where T: ToField {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, INITIAL_DELAY> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> {\n    pub fn get_current_value_in_private(self) -> T where T: FromField + ToField + Eq {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage(self.context.get_header(), self.context.this_address());\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, INITIAL_DELAY>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"167":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"169":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"170":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"172":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"173":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"175":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"176":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"179":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point::new(fields[0], fields[1], fields[2] as bool),\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"184":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"193":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"194":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"199":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"208":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"21":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    fn new(x: Field, y: Field, is_infinite: bool) -> Self {\n        Self { x, y, is_infinite }\n    }\n\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n// Scalar represented as low and high limbs\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    pub fn derive_public_key(self) -> EmbeddedCurvePoint {\n        let public_key = fixed_base_scalar_mul(self.lo, self.hi);\n        EmbeddedCurvePoint { x: public_key[0], y: public_key[1], is_infinite: false }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, key: EmbeddedCurveScalar) -> bool {\n        (key.hi == self.hi) & (key.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n#[foreign(multi_scalar_mul)]\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> [Field; 3]\n// docs:end:multi_scalar_mul\n{}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(\n    scalar_low: Field,\n    scalar_high: Field\n) -> [Field; 3]\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    let scalar = EmbeddedCurveScalar { lo: scalar_low, hi: scalar_high };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"211":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"216":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"217":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"22":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"220":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"227":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"23":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"235":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<N> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<N> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<N> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<N> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"236":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<M, N>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<M, N>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<N>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"237":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"238":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"239":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"240":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"241":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"243":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"246":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn pub_key_to_bytes(pk: Point) -> [u8; 64] {\n    assert(!pk.is_infinite, \"Point at infinity is not a valid public key.\");\n    let mut result = [0 as u8; 64];\n    let x_bytes = pk.x.to_be_bytes(32);\n    let y_bytes = pk.y.to_be_bytes(32);\n    for i in 0..32 {\n        result[i] = x_bytes[i];\n        result[i + 32] = y_bytes[i];\n    }\n    result\n}\n"},"247":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"249":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"25":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[no_predicates]\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\n#[no_predicates]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n"},"263":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"273":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"274":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"mod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod sort_by_counters;\nmod sort_get_order_hints;\nmod sort_get_sorted_hints;\nmod sort_get_sorted_tuple;\nmod sort_get_split_order_hints;\n\n// Re-exports.\nuse assert_sorted_array::assert_sorted_array;\nuse assert_split_sorted_transformed_value_arrays::{assert_split_sorted_transformed_value_arrays_asc, assert_split_sorted_transformed_value_arrays_desc};\nuse assert_sorted_transformed_value_array::assert_sorted_transformed_value_array;\nuse sort_by_counters::{sort_by_counters_asc, sort_by_counters_desc};\nuse sort_get_order_hints::{OrderHint, sort_get_order_hints_asc, sort_get_order_hints_desc};\nuse sort_get_sorted_hints::sort_get_sorted_hints;\nuse sort_get_split_order_hints::{sort_get_split_order_hints_asc, sort_get_split_order_hints_desc, SplitOrderHints};\n\nuse crate::traits::{Empty, is_empty};\nuse crate::abis::side_effect::{Positioned, Ordered};\n\npub fn array_to_bounded_vec<T, N>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\nunconstrained fn filter_array_to_bounded_vec_unsafe<T, N>(arr: [T; N], should_propagate: [bool; N]) -> BoundedVec<T, N> {\n    let mut vec = BoundedVec::new();\n    for i in 0..N {\n        if should_propagate[i] {\n            vec.push(arr[i]);\n        }\n    }\n    vec\n}\n\npub fn filter_array_to_bounded_vec<T, N>(arr: [T; N], should_propagate: [bool; N]) -> BoundedVec<T, N> where T: Eq {\n    let vec_hint = filter_array_to_bounded_vec_unsafe(arr, should_propagate);\n    let mut verifying_index = 0;\n\n    for i in 0..N {\n        if should_propagate[i] {\n            assert_eq(arr[i], vec_hint.get(verifying_index));\n            verifying_index += 1;\n        }\n    }\n    assert_eq(verifying_index, vec_hint.len());\n\n    vec_hint\n}\n\nunconstrained pub fn find_index_hint<T, N>(array: [T; N], find: T) -> u32 where T: Eq {\n    let mut index = 0;\n    for i in 0..array.len() {\n        if array[i] == find {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, N>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\nunconstrained fn count_non_empty_elements<T, N>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut length = 0;\n    let mut seen_empty = false;\n    for elem in array {\n        if is_empty(elem) {\n            seen_empty = true;\n        } else if !seen_empty {\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, N>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let length = count_non_empty_elements(array);\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Deprecated. Use tests/utils/assert_array_eq instead.\npub fn array_eq<T, N, S>(array: [T; N], expected: [T; S]) -> bool where T: Empty + Eq {\n    let mut eq = array_length(array) == S;\n\n    for i in 0..S {\n        eq &= array[i].eq(expected[i]);\n    }\n\n    eq\n}\n\npub fn find_index<T, N, Env>(array: [T; N], find: fn[Env](T) -> bool) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\npub fn array_cp<T, N, S>(array: [T; N]) -> [T; S] where T: Empty {\n    let mut result: [T; S] = [T::empty(); S];\n    for i in 0..S {\n        result[i] = array[i];\n    }\n    result\n}\n\npub fn array_concat<T, N, M, S>(array1: [T; N], array2: [T; M]) -> [T; S] {\n    assert_eq(N + M, S, \"combined array length does not match return array length\");\n    let mut result = [array1[0]; S];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, N>(array1: [T; N], array2: [T; N]) -> [T; N] where T: Empty + Eq {\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, N>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N]\n) where T: Eq + Empty {\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\npub fn assert_deduped_array<T, N, Env>(\n    original_array: [T; N],\n    deduped_array: [T; N],\n    run_lengths: [u32; N]\n) where T: Positioned + Ordered + Empty + Eq {\n    /*\n    The original_array here needs to be sorted based on the `position` field of the container,\n    *and* a secondary sort based on the `counter` field of the container. \n\n    For example, the storage slot in the case of public data update requests.\n    The run_lengths array should contain the length of each run of the original_array.\n    The deduped_array should contain the deduplicated array.\n\n    For example, if the original array is writing `(position,value,counter)`s:\n    [ (1,1,1), (1,2,4), (2,3,3), (3,4,2), (3,5,5), (3,6,6), (4,7,8), (4,8,9), (5,9,7), (0,0,0), ... padding with zeros ]\n    then run_lengths array is:\n    [\n        2, // run of 1s\n        1, // run of 2\n        3, // run of 3s\n        2, // run of 4s\n        1, // run of 5\n        0,\n        0,\n        ... padding with zeros\n    ]\n    \n    then the deduped_array should be:\n    [ (1,2,4), (2,3,3), (3,6,6), (4,8,9), (5,9,7), (0,0,0), ... padding with zeros ]\n    */\n\n    let deduped_len = validate_array(deduped_array); // This also makes sure that the array is padded with empty items.  \n    let run_lengths_len = array_length(run_lengths); // Don't have to be a \"validated\" array because non zero padded values don't hurt.  \n    assert_eq(deduped_len, run_lengths_len, \"Deduped array length does not match number of run lengths\");\n\n    let mut seen_empty = false;\n    // container at the start of the current run\n    let mut start_run_index = 0;\n    // the index we are collapsing into\n    let mut deduped_index = 0;\n    // the length of the current run we are collapsing\n    let mut run_counter = run_lengths[deduped_index];\n    for i in 0..N {\n        let current_container = original_array[i];\n        if is_empty(current_container) {\n            seen_empty = true;\n        } else {\n            assert(!seen_empty, \"Empty values must be padded to the right\");\n            assert(run_counter > 0, \"Invalid run length\");\n            assert(\n                current_container.position().eq(original_array[start_run_index].position()), \"The position of the current container must match the start of the run\"\n            );\n            run_counter -= 1;\n            if run_counter == 0 {\n                assert(\n                    deduped_array[deduped_index].eq(current_container), \"The container we are collapsing into must match the current container\"\n                );\n                start_run_index = i + 1;\n                deduped_index += 1;\n                run_counter = run_lengths[deduped_index];\n            } else {\n                // we're in a run, so this container must have a lower counter.\n                // note we don't check for overflow here, as the run_lengths array must be correct.\n                assert(\n                    current_container.counter() <= original_array[i + 1].counter(), \"Containers in a run must be sorted by counter\"\n                );\n            }\n        }\n    }\n\n    assert_eq(deduped_index, deduped_len, \"Final deduped index does not match deduped array length\");\n}\n\nmod tests {\n\n    use crate::utils::arrays::assert_deduped_array;\n    use crate::abis::side_effect::{Positioned, Ordered};\n    use crate::traits::{Empty, is_empty};\n\n    struct TestContainer {\n        value: Field,\n        position: Field,\n        counter: u32,\n    }\n\n    impl Positioned for TestContainer {\n        fn position(self) -> Field {\n            self.position\n        }\n    }\n\n    impl Ordered for TestContainer {\n        fn counter(self) -> u32 {\n            self.counter\n        }\n    }\n\n    impl Empty for TestContainer {\n        fn empty() -> Self {\n            TestContainer { value: 0, position: 0, counter: 0 }\n        }\n    }\n\n    impl Eq for TestContainer {\n        fn eq(self, other: Self) -> bool {\n            self.value.eq(other.value) & self.position.eq(other.position) & self.counter.eq(other.counter)\n        }\n    }\n\n    #[test]\n    fn assert_deduped_array_basic_test() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 1, counter: 4 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 2 },\n            TestContainer { value: 5, position: 3, counter: 5 },\n            TestContainer { value: 6, position: 3, counter: 6 },\n            TestContainer { value: 7, position: 4, counter: 8 },\n            TestContainer { value: 8, position: 4, counter: 9 },\n            TestContainer { value: 9, position: 5, counter: 7 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 2, position: 1, counter: 4 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 6, position: 3, counter: 6 },\n            TestContainer { value: 8, position: 4, counter: 9 },\n            TestContainer { value: 9, position: 5, counter: 7 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let run_lengths = [2, 1, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test]\n    fn assert_deduped_array_empty_arrays() {\n        let original_array = [TestContainer { value: 0, position: 0, counter: 0 }; 12];\n        let deduped_array = [TestContainer { value: 0, position: 0, counter: 0 }; 12];\n        let run_lengths = [0; 12];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test]\n    fn assert_deduped_array_no_duplicates() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 2, counter: 2 },\n            TestContainer { value: 3, position: 3, counter: 3 },\n            TestContainer { value: 4, position: 4, counter: 4 },\n            TestContainer { value: 5, position: 5, counter: 5 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let deduped_array = original_array;\n        let run_lengths = [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test]\n    fn assert_deduped_array_single_run_at_end() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 2, counter: 2 },\n            TestContainer { value: 3, position: 3, counter: 3 },\n            TestContainer { value: 4, position: 4, counter: 4 },\n            TestContainer { value: 5, position: 5, counter: 5 },\n            TestContainer { value: 6, position: 6, counter: 7 },\n            TestContainer { value: 7, position: 6, counter: 8 },\n            TestContainer { value: 8, position: 6, counter: 9 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 2, counter: 2 },\n            TestContainer { value: 3, position: 3, counter: 3 },\n            TestContainer { value: 4, position: 4, counter: 4 },\n            TestContainer { value: 5, position: 5, counter: 5 },\n            TestContainer { value: 8, position: 6, counter: 9 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let run_lengths = [1, 1, 1, 1, 1, 3, 0, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test]\n    fn assert_deduped_array_all_duplicates() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 1, counter: 3 },\n            TestContainer { value: 4, position: 1, counter: 4 },\n            TestContainer { value: 5, position: 1, counter: 5 },\n            TestContainer { value: 6, position: 1, counter: 6 },\n            TestContainer { value: 7, position: 1, counter: 7 },\n            TestContainer { value: 8, position: 1, counter: 8 },\n            TestContainer { value: 9, position: 1, counter: 9 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 9, position: 1, counter: 9 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let run_lengths = [9, 0, 0, 0, 0, 0, 0, 0, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test(should_fail_with = \"Empty values must be padded to the right\")]\n    fn test_empty_not_padded_right() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 3, position: 2, counter: 3 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 0, position: 0, counter: 0 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let run_lengths = [2, 1, 0, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test(should_fail_with = \"The position of the current container must match the start of the run\")]\n    fn test_mismatched_position_in_run() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let run_lengths = [3, 1, 1, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test(should_fail_with = \"The container we are collapsing into must match the current container\")]\n    fn test_mismatched_deduped_value() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let run_lengths = [2, 1, 1, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test(should_fail_with = \"Deduped array length does not match number of run lengths\")]\n    fn test_run_lengths_not_zero_padded() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 },\n            TestContainer { value: 0, position: 0, counter: 0 }\n        ];\n        let run_lengths = [2, 1, 1, 1]; // Last element should be 0\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n\n    #[test(should_fail_with = \"Deduped array length does not match number of run lengths\")]\n    fn test_deduped_padding_not_zero_padded() {\n        let original_array = [\n            TestContainer { value: 1, position: 1, counter: 1 },\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 }\n        ];\n        let deduped_array = [\n            TestContainer { value: 2, position: 1, counter: 2 },\n            TestContainer { value: 3, position: 2, counter: 3 },\n            TestContainer { value: 4, position: 3, counter: 4 },\n            TestContainer { value: 1, position: 1, counter: 1 }// Last element should be 0\n        ];\n        let run_lengths = [2, 1, 1, 0];\n        assert_deduped_array(original_array, deduped_array, run_lengths);\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test(should_fail_with=\"combined array length does not match return array length\")]\nfn array_concat_fails_inconsistent_lengths() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let _concated: [Field; 4] = array_concat(array0, array1);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"},"275":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"289":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"290":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"30":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"303":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"315":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n// docs:end:token_types_all\n"},"32":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"38":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"4":{"path":"std/cmp.nr","source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"47":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len);\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n    // TODO: Allow imports from \"super\"\n    use crate::collections::bounded_vec::BoundedVec;\n\n    #[test]\n    fn empty_equality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n        assert_eq(bounded_vec1, bounded_vec2);\n    }\n\n    #[test]\n    fn inequality() {\n        let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n        let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n        bounded_vec1.push(1);\n        bounded_vec2.push(2);\n\n        assert(bounded_vec1 != bounded_vec2);\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n}\n"},"50":{"path":"/usr/src/noir-projects/noir-contracts/contracts/app_subscription_contract/src/subscription_note.nr","source":"use dep::aztec::prelude::{AztecAddress, PrivateContext, NoteHeader, NoteInterface};\nuse dep::aztec::{\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, keys::getters::get_nsk_app\n};\n\nglobal SUBSCRIPTION_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal SUBSCRIPTION_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// Stores a public key composed of two fields\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[aztec(note)]\nstruct SubscriptionNote {\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    expiry_block_number: Field,\n    remaining_txs: Field,\n}\n\nimpl NoteInterface<SUBSCRIPTION_NOTE_LEN, SUBSCRIPTION_NOTE_BYTES_LEN> for SubscriptionNote {\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl SubscriptionNote {\n    pub fn new(npk_m_hash: Field, expiry_block_number: Field, remaining_txs: Field) -> Self {\n        SubscriptionNote { npk_m_hash, expiry_block_number, remaining_txs, header: NoteHeader::empty() }\n    }\n}\n"},"51":{"path":"/usr/src/noir-projects/noir-contracts/contracts/app_subscription_contract/src/main.nr","source":"mod subscription_note;\nmod dapp_payload;\n\ncontract AppSubscription {\n    use crate::{dapp_payload::DAppPayload, subscription_note::{SubscriptionNote, SUBSCRIPTION_NOTE_LEN}};\n\n    use aztec::{\n        prelude::{\n        AztecAddress, FunctionSelector, PrivateContext, NoteHeader, Map, PrivateMutable, PublicMutable,\n        SharedImmutable\n    },\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note\n    };\n    use authwit::{auth_witness::get_auth_witness, auth::assert_current_call_valid_authwit};\n    use gas_token::GasToken;\n    use token::Token;\n\n    #[aztec(storage)]\n    struct Storage {\n        // The following is only needed in private but we use ShareImmutable here instead of PrivateImmutable because\n        // the value can be publicly known and SharedImmutable provides us with a better devex here because we don't\n        // have to bother with sharing the note between pixies of users.\n        target_address: SharedImmutable<AztecAddress>,\n        subscription_token_address: SharedImmutable<AztecAddress>,\n        subscription_recipient_address: SharedImmutable<AztecAddress>,\n        subscription_price: SharedImmutable<Field>,\n        subscriptions: Map<AztecAddress, PrivateMutable<SubscriptionNote>>,\n        gas_token_address: SharedImmutable<AztecAddress>,\n        gas_token_limit_per_tx: SharedImmutable<Field>,\n    }\n\n    global SUBSCRIPTION_DURATION_IN_BLOCKS = 5;\n    global SUBSCRIPTION_TXS = 5;\n\n    #[aztec(private)]\n    fn entrypoint(payload: DAppPayload, user_address: AztecAddress) {\n        assert(context.msg_sender().to_field() == 0);\n        assert_current_call_valid_authwit(&mut context, user_address);\n\n        let mut note = storage.subscriptions.at(user_address).get_note().note;\n        assert(note.remaining_txs as u64 > 0, \"you're out of txs\");\n\n        note.remaining_txs -= 1;\n\n        // We are emitting both the outgoing and the incoming logs to the subscriber here because passing a separate\n        // outgoing_viewer arg to entrypoint function is impractical and the outgoing are not so valuable here.\n        storage.subscriptions.at(user_address).replace(&mut note).emit(encode_and_encrypt_note(&mut context, user_address, user_address));\n\n        context.set_as_fee_payer();\n\n        // TODO(palla/gas) Assert gas_token_limit_per_tx is less than this tx gas_limit\n        let _gas_limit = storage.gas_token_limit_per_tx.read_private();\n\n        context.end_setup();\n\n        AppSubscription::at(context.this_address()).assert_not_expired(note.expiry_block_number).enqueue_view(&mut context);\n\n        payload.execute_calls(&mut context, storage.target_address.read_private());\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(\n        target_address: AztecAddress,\n        subscription_recipient_address: AztecAddress,\n        subscription_token_address: AztecAddress,\n        subscription_price: Field,\n        gas_token_address: AztecAddress,\n        gas_token_limit_per_tx: Field\n    ) {\n        storage.target_address.initialize(target_address);\n        storage.subscription_token_address.initialize(subscription_token_address);\n        storage.subscription_recipient_address.initialize(subscription_recipient_address);\n        storage.subscription_price.initialize(subscription_price);\n        storage.gas_token_address.initialize(gas_token_address);\n        storage.gas_token_limit_per_tx.initialize(gas_token_limit_per_tx);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    #[aztec(view)]\n    fn assert_not_expired(expiry_block_number: Field) {\n        assert((context.block_number()) as u64 < expiry_block_number as u64);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    #[aztec(view)]\n    fn assert_block_number(expiry_block_number: Field) {\n        assert(\n            (context.block_number() + SUBSCRIPTION_DURATION_IN_BLOCKS) as u64\n            >= expiry_block_number as u64\n        );\n    }\n\n    #[aztec(private)]\n    fn subscribe(\n        subscriber_address: AztecAddress,\n        nonce: Field,\n        expiry_block_number: Field,\n        tx_count: Field\n    ) {\n        assert(tx_count as u64 <= SUBSCRIPTION_TXS as u64);\n\n        Token::at(storage.subscription_token_address.read_private()).transfer_from(\n            context.msg_sender(),\n            storage.subscription_recipient_address.read_private(),\n            storage.subscription_price.read_private(),\n            nonce\n        ).call(&mut context);\n\n        // Assert that the given expiry_block_number < current_block_number + SUBSCRIPTION_DURATION_IN_BLOCKS.\n        AppSubscription::at(context.this_address()).assert_block_number(expiry_block_number).enqueue_view(&mut context);\n        let header = context.get_header();\n        let subscriber_npk_m_hash = header.get_npk_m_hash(&mut context, subscriber_address);\n\n        let mut subscription_note = SubscriptionNote::new(subscriber_npk_m_hash, expiry_block_number, tx_count);\n        storage.subscriptions.at(subscriber_address).initialize_or_replace(&mut subscription_note).emit(encode_and_encrypt_note(&mut context, context.msg_sender(), subscriber_address));\n    }\n\n    unconstrained fn is_initialized(subscriber_address: AztecAddress) -> pub bool {\n        storage.subscriptions.at(subscriber_address).is_initialized()\n    }\n}\n"},"52":{"path":"/usr/src/noir-projects/noir-contracts/contracts/app_subscription_contract/src/dapp_payload.nr","source":"use dep::aztec::prelude::{PrivateContext, AztecAddress};\nuse dep::aztec::protocol_types::{constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::pedersen_hash, traits::{Hash, Serialize}};\n\nuse dep::authwit::entrypoint::function_call::{FunctionCall, FUNCTION_CALL_SIZE_IN_BYTES};\n\nglobal DAPP_MAX_CALLS: u64 = 1;\n// FUNCTION_CALL_SIZE * DAPP_MAX_CALLS + 1\nglobal DAPP_PAYLOAD_SIZE: u64 = 6;\n// FUNCTION_CALL_SIZE_IN_BYTES * DAPP_MAX_CALLS + 32\nglobal DAPP_PAYLOAD_SIZE_IN_BYTES: u64 = 130;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\nstruct DAppPayload {\n  function_calls: [FunctionCall; DAPP_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<DAPP_PAYLOAD_SIZE> for DAppPayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; DAPP_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, DAPP_PAYLOAD_SIZE> = BoundedVec::new();\n    for call in self.function_calls {\n      fields.extend_from_array(call.serialize());\n    }\n    fields.push(self.nonce);\n    fields.storage\n  }\n}\n\nimpl Hash for DAppPayload {\n  fn hash(self) -> Field {\n    pedersen_hash(\n      self.serialize(),\n      GENERATOR_INDEX__SIGNATURE_PAYLOAD\n    )\n  }\n}\n\nimpl DAppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; DAPP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, DAPP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..DAPP_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_slice(self.nonce.to_be_bytes(32));\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext, target_address: AztecAddress) {\n        for i in 0..DAPP_MAX_CALLS {\n            let call = self.function_calls[i];\n            // whitelist the calls that the user can do only go to the expected Dapp contract\n            assert(call.target_address == target_address);\n            if call.is_public {\n                context.call_public_function_with_packed_args(\n                    call.target_address,\n                    call.function_selector,\n                    call.args_hash,\n                    call.is_static,\n                    false\n                );\n            } else {\n                let _result = context.call_private_function_with_packed_args(\n                    call.target_address,\n                    call.function_selector,\n                    call.args_hash,\n                    call.is_static,\n                    false\n                );\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"54":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<N>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<N>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"64":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::{Point, pub_key_to_bytes},\n    utils::arr_copy_slice\n};\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret_fields = multi_scalar_mul([point], [secret]);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/6061): make the func return Point struct directly\n    let shared_secret = pub_key_to_bytes(Point::new(shared_secret_fields[0], shared_secret_fields[1], false));\n    let mut shared_secret_bytes_with_separator = [0 as u8; 65];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[64] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn check_point_to_symmetric_key() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar::new(\n        0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    );\n    let point = Point::new(\n        0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        false\n    );\n\n    let key = point_to_symmetric_key(secret, point);\n    // The following value gets updated when running encrypt_buffer.test.ts with AZTEC_GENERATE_TEST_DATA=1\n    let expected_key = [\n        49, 167, 146, 222, 151, 129, 138, 184, 87, 210, 245, 249, 99, 100, 1, 59, 223, 180, 5, 99, 14, 7, 177, 236, 159, 203, 231, 72, 220, 180, 241, 23\n    ];\n    assert_eq(key, expected_key);\n}\n"},"65":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point::new(x_coordinate, y_coordinate, false)\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"66":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH, hash::poseidon2_hash,\n    point::Point, traits::{Deserialize, Serialize, Empty, is_empty}\n};\nuse crate::keys::constants::{NUM_KEY_TYPES, NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH = 12;\n\nstruct PublicKeys {\n    npk_m: Point,\n    ivpk_m: Point,\n    ovpk_m: Point,\n    tpk_m: Point,\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : Point::empty(),\n            ivpk_m : Point::empty(),\n            ovpk_m : Point::empty(),\n            tpk_m : Point::empty()\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m == other.npk_m ) &\n        ( self.ivpk_m == other.ivpk_m ) &\n        ( self.ovpk_m == other.ovpk_m ) &\n        ( self.tpk_m == other.tpk_m )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash(\n                [\n                self.npk_m.x,\n                self.npk_m.y,\n                self.npk_m.is_infinite as Field,\n                self.ivpk_m.x,\n                self.ivpk_m.y,\n                self.ivpk_m.is_infinite as Field,\n                self.ovpk_m.x,\n                self.ovpk_m.y,\n                self.ovpk_m.is_infinite as Field,\n                self.tpk_m.x,\n                self.tpk_m.y,\n                self.tpk_m.is_infinite as Field,\n                GENERATOR_INDEX__PUBLIC_KEYS_HASH\n            ]\n            )\n        }\n        )\n    }\n\n    pub fn get_key_by_index(self, index: Field) -> Point {\n        assert(index as u8 < NUM_KEY_TYPES, \"Invalid key index\");\n        if index == NULLIFIER_INDEX {\n            self.npk_m\n        } else if index == INCOMING_INDEX {\n            self.ivpk_m\n        } else if index == OUTGOING_INDEX {\n            self.ovpk_m\n        } else {\n            self.tpk_m\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.x,\n            self.npk_m.y,\n            self.npk_m.is_infinite as Field,\n            self.ivpk_m.x,\n            self.ivpk_m.y,\n            self.ivpk_m.is_infinite as Field,\n            self.ovpk_m.x,\n            self.ovpk_m.y,\n            self.ovpk_m.is_infinite as Field,\n            self.tpk_m.x,\n            self.tpk_m.y,\n            self.tpk_m.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: Point::new(serialized[0], serialized[1], serialized[2] as bool),\n            ivpk_m: Point::new(serialized[3], serialized[4], serialized[5] as bool),\n            ovpk_m: Point::new(serialized[6], serialized[7], serialized[8] as bool),\n            tpk_m: Point::new(serialized[9], serialized[10], serialized[11] as bool)\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x146f68c0e0ba4067d61a3304bbfdec0797d5df1357db6c01247c48bfb345c7d7;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: Point { x: 1, y: 2, is_infinite: false },\n        ivpk_m: Point { x: 3, y: 4, is_infinite: false },\n        ovpk_m: Point { x: 5, y: 6, is_infinite: false },\n        tpk_m: Point { x: 7, y: 8, is_infinite: false }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.x, deserialized.npk_m.x);\n    assert_eq(keys.npk_m.y, deserialized.npk_m.y);\n    assert_eq(keys.ivpk_m.x, deserialized.ivpk_m.x);\n    assert_eq(keys.ivpk_m.y, deserialized.ivpk_m.y);\n    assert_eq(keys.ovpk_m.x, deserialized.ovpk_m.x);\n    assert_eq(keys.ovpk_m.y, deserialized.ovpk_m.y);\n    assert_eq(keys.tpk_m.x, deserialized.tpk_m.x);\n    assert_eq(keys.tpk_m.y, deserialized.tpk_m.y);\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"81":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"88":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::storage::{raw_storage_read, storage_read};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = block_number_oracle();\n        let contract_address = contract_address_oracle();\n        let chain_id = chain_id_oracle();\n        let version = version_oracle();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<N>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n\n#[oracle(getContractAddress)]\nunconstrained fn contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn version_oracle() -> Field {}\n"},"89":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"94":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"95":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}